<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mods Play - Ggames</title>
    <link rel="icon" type="image/png" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTl6Ljabwgx-VXdZz8FcAoygQprujSsCoXc32Y_iU0FjYVPu1B6MffWwp8gcCVuV8TWn39FRk9OIe1nc-esubVJYmdLsTptAoR9GyqNuw4R5MBaeaoWXTc3JaqH2YVNtEmfReQqohvQKvHiI0XwE5na2ty2B9Bt4oELxYv2BaZ7R3UmeylpiVEIbiLnCB/s320/soccer-ball-png.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Estilos básicos */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { min-height: 100vh; background-color: #f0f0f0; font-family: Arial, sans-serif; }
        .content { padding: 20px; margin-bottom: 80px; display: none; }
        h1 { color: #333; margin-bottom: 10px; text-align: center; }

        /* Tela de carregamento */
        #loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f0f0f0; display: flex; justify-content: center; align-items: center; z-index: 1001; }
        .loading-spinner { border: 16px solid #f3f3f3; border-top: 16px solid #3498db; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Estilos do contador */
        #timer-container { text-align: center; margin-bottom: 20px; font-size: 1.2em; color: #555; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .timer-unit { display: inline-block; padding: 5px 10px; margin: 0 4px; background-color: #e9ecef; border-radius: 4px; font-weight: bold; color: #333; }
        #timer-container.expired #countdown { color: #dc3545; font-weight: bold; }

        /* Estilos da lista de palpites (Acordeão) */
        #predictions-list { display: flex; flex-direction: column; gap: 15px; }
        .user-container { background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.08); overflow: hidden; }
        .user-header { display: flex; justify-content: space-between; align-items: center; padding: 15px; cursor: pointer; background: #f9f9f9; font-weight: bold; border-bottom: 1px solid #eee; }
        .user-header {
    /* ... (mantenha os outros estilos que já existem aqui) ... */
    transition: filter 0.2s ease, background-color 0.2s ease;
}
.user-header:hover { 
    filter: brightness(95%); /* Escurece ligeiramente qualquer cor de fundo */
}
.user-header.active .toggle-icon { transform: rotate(180deg); }
.toggle-icon { transition: transform 0.3s ease; }
        
        .games-list { max-height: 0; overflow: hidden; transition: max-height 0.5s ease-in-out; }
        .user-header.active + .games-list { max-height: 10000px; }

        .game-container { border-top: 1px solid #f0f0f0; }
        .game-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px 12px 30px; cursor: pointer; background: #fff; font-size: 0.9em; }
        .game-header:hover { background: #f9f9f9; }
        .game-header.active .toggle-icon { transform: rotate(180deg); }
        
        .predictions-sublist { list-style: none; max-height: 0; overflow: hidden; transition: max-height 0.4s ease-in-out; background: #fcfcfc; }
        .game-header.active + .predictions-sublist { max-height: 1000px; padding: 10px 15px 15px 45px; }

        .prediction-item { padding: 12px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s ease; background: #fff; }
        .prediction-item:last-child { margin-bottom: 0; }
        .prediction-item:hover { border-color: #2176ff; background: #f0f7ff; }
        .prediction-item.selected { background-color: #28a745; color: white; border-color: #1e7e34; font-weight: bold; }
        
        /* Mensagem de fallback */
        .info-message { text-align: center; color: #666; font-size: 1.1em; background: white; padding: 20px; border-radius: 8px; margin-top: 15px; }

        /* Estilo para o botão de submissão */
        .submit-button { padding: 12px 25px; background-color: #28a745; color: white; border: none; border-radius: 8px; font-size: 1.1em; font-weight: bold; cursor: pointer; transition: background-color 0.3s ease; width: 100%; max-width: 400px; }
        .submit-button:hover:not(:disabled) { background-color: #218838; }
        .submit-button:disabled { background-color: #aaa; cursor: not-allowed; }
         .user-header .selection-indicator {
            color: #28a745; /* Cor verde de sucesso */
            margin-left: 8px;
            font-size: 0.9em;
            opacity: 0; /* Começa invisível */
            transition: opacity 0.3s ease;
        }

        .user-header.has-selection .selection-indicator {
            opacity: 1; /* Torna-se visível */
        }
        
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-spinner"></div>
    </div>

    <div class="content">
        <h1></h1>
        <div id="timer-container"></div>
        <div id="modsplay-content"></div>
        <div id="submit-container" style="margin-top: 25px; text-align: center;"></div>
    </div>

    <script src="config.js"></script>
    <script type="module">



        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, doc, getDoc, collection, getDocs, query, where, orderBy, limit, writeBatch, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        const loadingScreen = document.getElementById('loading-screen');
        const content = document.querySelector('.content');
        const contentTitle = document.querySelector('h1');
        const timerContainer = document.getElementById('timer-container');
        const modsplayContent = document.getElementById('modsplay-content');
        
        let countdownInterval = null;
        let selectedPredictions = {};
        let currentTemporada = null; // Variável para guardar a temporada

        onAuthStateChanged(auth, async (user) => {
            if (!user) { window.location.href = 'index.html'; return; }
            const userInfo = await getDoc(doc(db, 'users', user.uid));
            if (!userInfo.exists() || userInfo.data().aceite !== "Yes") { window.location.href = '404.html'; return; }
            try {
            // 1. Obter as configurações do menu a partir do Firestore
            const menuSettingsDoc = await getDoc(doc(db, 'paineis', 'paineis menu'));
            const menuSettings = menuSettingsDoc.exists() ? menuSettingsDoc.data() : {};

            // 2. Chamar a função global do menu-component.js para aplicar a visibilidade
            if (window.updateMenuVisibility) {
                window.updateMenuVisibility(menuSettings);
            }
        } catch (error) {
            console.error("Erro ao carregar as configurações do menu:", error);
        }
            await initializeModsPlay();
        });

        async function initializeModsPlay() {
            try {
                const modsPlayQuery = await getDocs(collection(db, 'modsplay'));
                if (modsPlayQuery.empty) { showInfoMessage("Nenhum evento Mods Play ativo no momento."); return; }
                const modsPlayData = modsPlayQuery.docs[0].data();

                const modDoc = await getDoc(doc(db, 'mods', modsPlayData.modId));
                if (!modDoc.exists()) { showInfoMessage("Erro: O Mod associado ao evento não foi encontrado."); return; }
                const modData = modDoc.data();
                contentTitle.textContent = modData.nomeMod;

                startCountdown(modsPlayData.dataFim.toDate());
                
                if (modData.nomeMod === "CRUSH BONES") {
                    await renderCrushBonesContent(modsPlayData);
                } else {
                    showInfoMessage("Este Mod não tem uma funcionalidade especial ativa.");
                }

            } catch (error) {
                console.error("Erro ao inicializar Mods Play:", error);
                showInfoMessage("Ocorreu um erro ao carregar o conteúdo.");
            } finally {
                loadingScreen.style.display = 'none';
                content.style.display = 'block';
            }
        }

   function startCountdown(endTime) {
            clearInterval(countdownInterval);
            const update = () => {
                const timeLeft = endTime.getTime() - new Date().getTime();

                if (timeLeft <= 0) {
                    clearInterval(countdownInterval); // Pare o intervalo imediatamente
                    timerContainer.innerHTML = `<span id="countdown">Tempo Esgotado!</span>`;
                    timerContainer.classList.add('expired');
                    
                    // --- CORREÇÃO IMPORTANTE AQUI ---
                    // Verifique se os elementos existem antes de tentar usá-los.
                    const predictionsList = document.getElementById('predictions-list');
                    if (predictionsList) {
                        predictionsList.style.pointerEvents = 'none';
                    }

                    const submitButton = document.getElementById('submit-crushbones-btn');
                    if (submitButton) {
                        submitButton.setAttribute('disabled', 'true');
                    }
                    
                    return;
                }
                const d = Math.floor(timeLeft / 86400000);
                const h = Math.floor((timeLeft % 86400000) / 3600000);
                const m = Math.floor((timeLeft % 3600000) / 60000);
                const s = Math.floor((timeLeft % 60000) / 1000);
                timerContainer.innerHTML = `Tempo Restante: ${d > 0 ? `<span class="timer-unit">${d}d</span>` : ''}<span class="timer-unit">${h}h</span><span class="timer-unit">${m}m</span><span class="timer-unit">${s}s</span>`;
            };
            update();
            countdownInterval = setInterval(update, 1000);
        }

 async function renderCrushBonesContent(modsPlayData) {
            // (A primeira parte da função continua igual: obter temporada, verificar participação, etc.)
            const latestSeasonQuery = query(collection(db, 'palpites'), orderBy('temporada', 'desc'), limit(1));
            const latestSeasonSnapshot = await getDocs(latestSeasonQuery);
            if (latestSeasonSnapshot.empty) { showInfoMessage("Ainda não existem palpites para exibir."); return; }
            const latestSeason = latestSeasonSnapshot.docs[0].data().temporada;
            currentTemporada = latestSeason;

            const checkQuery = query(collection(db, 'palpitesmods'), 
                where('userId', '==', auth.currentUser.uid),
                where('temporada', '==', latestSeason),
                where('ronda', '==', modsPlayData.ronda),
                limit(1)
            );
            const existingPicksSnapshot = await getDocs(checkQuery);
            const hasAlreadyPlayed = !existingPicksSnapshot.empty;

            const palpitesQuery = query(collection(db, 'palpites'), where('ronda', '==', modsPlayData.ronda), where('temporada', '==', latestSeason));
            const palpitesSnapshot = await getDocs(palpitesQuery);
            if (palpitesSnapshot.empty) { showInfoMessage("Nenhum palpite encontrado para esta ronda."); return; }

            const groupedPalpites = {};
            palpitesSnapshot.forEach(doc => {
                const palpite = doc.data();
                if (!groupedPalpites[palpite.userId]) groupedPalpites[palpite.userId] = {};
                if (!groupedPalpites[palpite.userId][palpite.jogoId]) groupedPalpites[palpite.userId][palpite.jogoId] = [];
                groupedPalpites[palpite.userId][palpite.jogoId].push(palpite);
            });

            const userIds = Object.keys(groupedPalpites);
            const jogoIds = new Set(palpitesSnapshot.docs.map(doc => doc.data().jogoId));

            const [userNames, gameNames] = await Promise.all([
                fetchNames(userIds, 'users', 'nometabela'),
                fetchNames(Array.from(jogoIds), 'jogos', 'nomeJogo')
            ]);
            
            // --- INÍCIO DA LÓGICA DE ORDENAÇÃO ---
            // 1. Criar um array de objetos, combinando ID e nome para facilitar a ordenação.
            const sortedUsers = userIds
                .map(id => ({
                    id: id,
                    name: userNames[id] || 'Utilizador Desconhecido'
                }))
                .sort((a, b) => a.name.localeCompare(b.name)); // 2. Ordenar o array alfabeticamente pelo nome.
            // --- FIM DA LÓGICA DE ORDENAÇÃO ---

            let html = '<div id="predictions-list">';

            // 3. Alterar o loop para usar o nosso novo array ordenado.
            for (const user of sortedUsers) {
                const userId = user.id; // Extrair o ID do utilizador do objeto
                
                if (userId === auth.currentUser.uid) { continue; }

                // --- LÓGICA DAS CORES ---
                // 4. Gerar uma cor única para o fundo do cabeçalho do utilizador.
                const userColor = generatePastelColorFromId(userId);

                let gamesHtml = '';
                for (const jogoId in groupedPalpites[userId]) {
                    const jogoNomeCompleto = gameNames[jogoId] || 'Jogo Desconhecido';
                    const jogoNomeCurto = jogoNomeCompleto.split(' - ')[0];
                    let predictionsHtml = '';
                    const palpitesDoJogo = groupedPalpites[userId][jogoId][0];
                    Object.keys(palpitesDoJogo)
                        .filter(key => key.startsWith('palpite') && !key.includes('Status'))
                        .sort()
                        .forEach(key => {
                            const itemClass = hasAlreadyPlayed ? 'prediction-item readonly' : 'prediction-item';
                            predictionsHtml += `<li class="${itemClass}" data-jogo-id="${jogoId}" data-palpite-key="${key}" data-original-user-id="${userId}">
                                                  ${palpitesDoJogo[key]}
                                                </li>`;
                        });
                    if (predictionsHtml) {
                         gamesHtml += `<div class="game-container">
                                        <div class="game-header"><span>${jogoNomeCurto}</span><i class="fas fa-chevron-down toggle-icon"></i></div>
                                        <ul class="predictions-sublist">${predictionsHtml}</ul>
                                     </div>`;
                    }
                }
                
                if (gamesHtml) {
                     // 5. Aplicar a cor gerada como um estilo inline no cabeçalho.
                     html += `<div class="user-container" data-user-id="${userId}">
                                <div class="user-header" style="background-color: ${userColor};">
                                    <span>${user.name}<i class="fas fa-check-circle selection-indicator"></i></span>
                                    <i class="fas fa-chevron-down toggle-icon"></i>
                                </div>
                                <div class="games-list">${gamesHtml}</div>
                             </div>`;
                }
            }
            html += '</div>';
            modsplayContent.innerHTML = html;

            if (!hasAlreadyPlayed) {
                const submitContainer = document.getElementById('submit-container');
                submitContainer.innerHTML = `<button id="submit-crushbones-btn" class="submit-button">Confirmar Seleções</button>`;
                document.getElementById('submit-crushbones-btn').addEventListener('click', submitCrushBonesSelections);
            } else {
                modsplayContent.innerHTML += '<p class="info-message" style="margin-top: 25px;">As tuas seleções para esta ronda já foram registadas.</p>';
            }

            addAccordionListeners(hasAlreadyPlayed);
        }
        
    async function submitCrushBonesSelections() {
            const button = document.getElementById('submit-crushbones-btn');
            if (Object.keys(selectedPredictions).length === 0) {
                alert("Nenhum palpite selecionado!");
                return;
            }

            button.disabled = true;
            button.textContent = 'A processar...';

            try {
                // --- INÍCIO DA LÓGICA ANTI-DUPLICAÇÃO ---
                const modsPlayData = (await getDocs(collection(db, 'modsplay'))).docs[0].data();
                const ronda = modsPlayData.ronda;

                // 1. Procurar todos os palpites que o user JÁ FEZ para esta ronda/temporada
                const existingPicksQuery = query(collection(db, 'palpitesmods'), 
                    where('userId', '==', auth.currentUser.uid),
                    where('temporada', '==', currentTemporada),
                    where('ronda', '==', ronda)
                );
                const existingPicksSnapshot = await getDocs(existingPicksQuery);
                const submittedGameIds = new Set(existingPicksSnapshot.docs.map(doc => doc.data().jogoId));
                
                // 2. Filtrar as novas seleções, removendo as que correspondem a jogos já palpitados
                const newSelections = {};
                for (const jogoId in selectedPredictions) {
                    if (!submittedGameIds.has(jogoId)) {
                        newSelections[jogoId] = selectedPredictions[jogoId];
                    }
                }

                if (Object.keys(newSelections).length === 0) {
                    alert("Todos os palpites selecionados já foram submetidos anteriormente nesta ronda.");
                    button.disabled = false;
                    button.textContent = 'Confirmar Seleções';
                    return;
                }
                // --- FIM DA LÓGICA ANTI-DUPLICAÇÃO ---

                // Obter o nome do mod
                const modId = modsPlayData.modId;
                const modDoc = await getDoc(doc(db, 'mods', modId));
                const nomeMod = modDoc.exists() ? modDoc.data().nomeMod : "Mod Desconhecido";

                const batch = writeBatch(db);

                // AGORA SÓ PERCORREMOS AS NOVAS SELEÇÕES FILTRADAS
                for (const jogoId in newSelections) {
                    const selection = newSelections[jogoId];

                    const palpiteData = {
                        userId: auth.currentUser.uid,
                        temporada: currentTemporada,
                        ronda: ronda,
                        dataPalpite: serverTimestamp(),
                        nomeMod: nomeMod,
                        modId: modId,
                        palpiteSelecionado: selection.palpiteText,
                        jogoId: jogoId,
                        copiedFromUserId: selection.originalUserId
                    };

                    const palpitesModsRef = doc(collection(db, 'palpitesmods'));
                    batch.set(palpitesModsRef, palpiteData);

                    const boxRef = doc(collection(db, 'box'));
                    batch.set(boxRef, palpiteData);
                }

                await batch.commit();
                
                document.getElementById('predictions-list').style.pointerEvents = 'none';
                button.style.display = 'none';
                modsplayContent.innerHTML += `<p class="info-message">As tuas novas seleções foram registadas com sucesso!</p>`;

            } catch (error) {
                console.error("Erro ao submeter seleções:", error);
                alert("Ocorreu um erro ao confirmar as seleções. Tente novamente.");
                button.disabled = false;
                button.textContent = 'Confirmar Seleções';
            }
        }

        async function fetchNames(ids, collectionName, fieldName) {
            if (ids.length === 0) return {};
            const nameMap = {};
            const promises = ids.map(id => getDoc(doc(db, collectionName, id)));
            const results = await Promise.all(promises);
            results.forEach(docSnap => {
                if (docSnap.exists()) { nameMap[docSnap.id] = docSnap.data()[fieldName]; }
            });
            return nameMap;
        }

        function updateUserSelectionIndicators() {
            // Primeiro, remove o indicador de todos os utilizadores
            document.querySelectorAll('.user-header').forEach(header => {
                header.classList.remove('has-selection');
            });

            // Depois, obtém uma lista de todos os IDs de utilizadores cujos palpites foram selecionados
            const selectedUserIds = new Set(
                Object.values(selectedPredictions).map(selection => selection.originalUserId)
            );

            // Finalmente, adiciona o indicador apenas aos utilizadores selecionados
            selectedUserIds.forEach(userId => {
                const userContainer = document.querySelector(`.user-container[data-user-id="${userId}"]`);
                if (userContainer) {
                    userContainer.querySelector('.user-header').classList.add('has-selection');
                }
            });
        }


function generatePastelColorFromId(id) {
    let hash = 0;
    for (let i = 0; i < id.length; i++) {
        hash = id.charCodeAt(i) + ((hash << 5) - hash);
    }
    const h = hash % 360; // Gera uma "Hue" (matiz) entre 0 e 360
    // Usamos Saturação e Luminosidade altas para garantir cores pastel claras
    return `hsl(${h}, 80%, 92%)`; 
}
        
      function addAccordionListeners(isReadOnly = false) {
            // Listeners para abrir/fechar os acordeões (Users e Jogos) - sempre ativos
            document.querySelectorAll('.user-header, .game-header').forEach(header => {
                header.addEventListener('click', () => header.classList.toggle('active'));
            });

            // Só adiciona os listeners de clique nos palpites se NÃO estiver em modo "só de leitura"
            if (!isReadOnly) {
                document.querySelectorAll('.prediction-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const jogoId = item.dataset.jogoId;
                        const palpiteKey = item.dataset.palpiteKey;
                        const originalUserId = item.dataset.originalUserId;
                        const palpiteText = item.innerText.trim();

                        // Desmarca o item antigo desse jogo (se houver)
                        document.querySelectorAll(`.prediction-item[data-jogo-id="${jogoId}"]`).forEach(el => el.classList.remove('selected'));
                        
                        // Marca o novo item clicado
                        item.classList.add('selected');

                        // Atualiza o objeto de seleções na memória
                        selectedPredictions[jogoId] = { palpiteKey, originalUserId, palpiteText };
                        
                        // Atualiza os ícones visuais
                        updateUserSelectionIndicators(); 
                    });
                });
            } else {
                // Se for modo "só de leitura", podemos adicionar um estilo visual para deixar claro que não é clicável
                document.querySelectorAll('.prediction-item').forEach(item => {
                    item.style.cursor = 'default';
                });
            }
        }

        function showInfoMessage(message) {
            contentTitle.textContent = "Mods Play";
            modsplayContent.innerHTML = `<p class="info-message">${message}</p>`;
            timerContainer.style.display = 'none';
            loadingScreen.style.display = 'none';
            content.style.display = 'block';
        }
    </script>
    <script src="menu-component.js"></script> 
</body>
</html>
