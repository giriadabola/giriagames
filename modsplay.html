<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mods Play - Ggames</title>
    <link rel="icon" type="image/png" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTl6Ljabwgx-VXdZz8FcAoygQprujSsCoXc32Y_iU0FjYVPu1B6MffWwp8gcCVuV8TWn39FRk9OIe1nc-esubVJYmdLsTptAoR9GyqNuw4R5MBaeaoWXTc3JaqH2YVNtEmfReQqohvQKvHiI0XwE5na2ty2B9Bt4oELxYv2BaZ7R3UmeylpiVEIbiLnCB/s320/soccer-ball-png.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* Estilos básicos */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { min-height: 100vh; background-color: #f0f0f0; font-family: Arial, sans-serif; }
        .content { padding: 20px; margin-bottom: 80px; display: none; }
        h1 { color: #333; margin-bottom: 10px; text-align: center; }

        /* Tela de carregamento */
        #loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f0f0f0; display: flex; justify-content: center; align-items: center; z-index: 1001; }
        .loading-spinner { border: 16px solid #f3f3f3; border-top: 16px solid #3498db; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Estilos do contador */
        #timer-container { text-align: center; margin-bottom: 20px; font-size: 1.2em; color: #555; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .timer-unit { display: inline-block; padding: 5px 10px; margin: 0 4px; background-color: #e9ecef; border-radius: 4px; font-weight: bold; color: #333; }
        #timer-container.expired #countdown { color: #dc3545; font-weight: bold; }

        /* Estilos da lista de palpites (Acordeão) */
        #predictions-list { display: flex; flex-direction: column; gap: 15px; }
        .user-container { background: #fff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.08); overflow: hidden; }
        .user-header { display: flex; justify-content: space-between; align-items: center; padding: 15px; cursor: pointer; background: #f9f9f9; font-weight: bold; border-bottom: 1px solid #eee; }
        .user-header {
    /* ... (mantenha os outros estilos que já existem aqui) ... */
    transition: filter 0.2s ease, background-color 0.2s ease;
}
.user-header:hover { 
    filter: brightness(95%); /* Escurece ligeiramente qualquer cor de fundo */
}
.user-header.active .toggle-icon { transform: rotate(180deg); }
.toggle-icon { transition: transform 0.3s ease; }
        
        .games-list { max-height: 0; overflow: hidden; transition: max-height 0.5s ease-in-out; }
        .user-header.active + .games-list { max-height: 10000px; }

        .game-container { border-top: 1px solid #f0f0f0; }
        .game-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px 12px 30px; cursor: pointer; background: #fff; font-size: 0.9em; }
        .game-header:hover { background: #f9f9f9; }
        .game-header.active .toggle-icon { transform: rotate(180deg); }
        
        .predictions-sublist { list-style: none; max-height: 0; overflow: hidden; transition: max-height 0.4s ease-in-out; background: #fcfcfc; }
        .game-header.active + .predictions-sublist { max-height: 1000px; padding: 10px 15px 15px 45px; }

        .prediction-item { padding: 12px; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 8px; cursor: pointer; transition: all 0.2s ease; background: #fff; }
        .prediction-item:last-child { margin-bottom: 0; }
        .prediction-item:hover { border-color: #2176ff; background: #f0f7ff; }
        .prediction-item.selected { background-color: #28a745; color: white; border-color: #1e7e34; font-weight: bold; }
        
        /* Mensagem de fallback */
        .info-message { text-align: center; color: #666; font-size: 1.1em; background: white; padding: 20px; border-radius: 8px; margin-top: 15px; }

        /* Estilo para o botão de submissão */
        .submit-button { padding: 12px 25px; background-color: #28a745; color: white; border: none; border-radius: 8px; font-size: 1.1em; font-weight: bold; cursor: pointer; transition: background-color 0.3s ease; width: 100%; max-width: 400px; }
        .submit-button:hover:not(:disabled) { background-color: #218838; }
        .submit-button:disabled { background-color: #aaa; cursor: not-allowed; }
         .user-header .selection-indicator {
            color: #28a745; /* Cor verde de sucesso */
            margin-left: 8px;
            font-size: 0.9em;
            opacity: 0; /* Começa invisível */
            transition: opacity 0.3s ease;
        }

        .user-header.has-selection .selection-indicator {
            opacity: 1; /* Torna-se visível */
        }
        
        .submit-button.verify-step {
    background-color: #ffc107; /* Amarelo */
    color: #212529; /* Texto escuro para melhor contraste */
}
.submit-button.verify-step:hover:not(:disabled) {
    background-color: #e0a800; /* Amarelo mais escuro no hover */
}

    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-spinner"></div>
    </div>

    <div class="content">
        <h1></h1>
        <div id="timer-container"></div>
        <div id="modsplay-content"></div>
        <div id="submit-container" style="margin-top: 25px; text-align: center;"></div>
    </div>

    <script src="config.js"></script>
    <script type="module">



      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, collection, getDocs, query, where, orderBy, limit, writeBatch, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

// --- LOG INICIAL ---
console.log("--- SCRIPT INICIADO ---");
console.log("Firebase config a ser usada:", firebaseConfig); // LOG CRÍTICO: Mostra o projectId

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// --- LOG DE INICIALIZAÇÃO ---
console.log("Firebase App e Serviços inicializados com sucesso.");

const loadingScreen = document.getElementById('loading-screen');
const content = document.querySelector('.content');
const contentTitle = document.querySelector('h1');
const timerContainer = document.getElementById('timer-container');
const modsplayContent = document.getElementById('modsplay-content');

let countdownInterval = null;
let selectedPredictions = {};
let currentTemporada = null;

// --- INICIANDO O LISTENER DE AUTENTICAÇÃO ---
console.log("A aguardar estado de autenticação (onAuthStateChanged)...");

onAuthStateChanged(auth, async (user) => {
    console.log("onAuthStateChanged: O listener foi acionado.");

    if (!user) {
        console.error("onAuthStateChanged: NENHUM utilizador autenticado. A redirecionar para index.html.");
        window.location.href = 'index.html';
        return;
    }

    console.log("onAuthStateChanged: Utilizador DETETADO. UID:", user.uid);
    console.log("onAuthStateChanged: A verificar documento do utilizador na coleção 'users'...");

    try {
        const userInfoRef = doc(db, 'users', user.uid);
        const userInfo = await getDoc(userInfoRef);

        if (!userInfo.exists()) {
            console.error("onAuthStateChanged: ERRO - O documento do utilizador no Firestore NÃO EXISTE. A redirecionar para 404.html.");
            window.location.href = '404.html';
            return;
        }

        console.log("onAuthStateChanged: Documento do utilizador encontrado. A verificar campo 'aceite'.");
        const userData = userInfo.data();

        if (userData.aceite !== "Yes") {
            console.error(`onAuthStateChanged: ERRO - O campo 'aceite' não é 'Yes'. Valor atual: '${userData.aceite}'. A redirecionar para 404.html.`);
            window.location.href = '404.html';
            return;
        }

        console.log("onAuthStateChanged: SUCESSO - Utilizador autenticado e autorizado. A iniciar a página...");
        
        // Carregar configurações do menu (bloco opcional)
        try {
            console.log("onAuthStateChanged: A carregar configurações do menu...");
            const menuSettingsDoc = await getDoc(doc(db, 'paineis', 'paineis menu'));
            if (window.updateMenuVisibility) {
                window.updateMenuVisibility(menuSettingsDoc.exists() ? menuSettingsDoc.data() : {});
            }
            console.log("onAuthStateChanged: Configurações do menu carregadas.");
        } catch (error) {
            console.warn("onAuthStateChanged: Aviso - Erro ao carregar as configurações do menu:", error);
        }

        // Chamar a função principal
        await initializeModsPlay();

    } catch (error) {
        console.error("onAuthStateChanged: ERRO CRÍTICO durante a verificação do utilizador no Firestore:", error);
        showInfoMessage("Ocorreu um erro crítico ao verificar as suas permissões.");
        loadingScreen.style.display = 'none';
        content.style.display = 'block';
    }
});

async function initializeModsPlay() {
    console.log("--- initializeModsPlay: FUNÇÃO INICIADA ---");
    try {
        // ---- PASSO 1: LER A COLEÇÃO 'modsplay' ----
        console.log("initializeModsPlay (Passo 1/5): A tentar ler a coleção 'modsplay'...");
        const modsPlayQuery = await getDocs(collection(db, 'modsplay'));
        console.log("initializeModsPlay (Passo 1/5): SUCESSO. Leitura da coleção 'modsplay' concluída. Documentos encontrados:", modsPlayQuery.size);

        if (modsPlayQuery.empty) {
            showInfoMessage("Nenhum evento Mods Play ativo no momento.");
            return;
        }
        const modsPlayData = modsPlayQuery.docs[0].data();
        console.log("initializeModsPlay: Dados do evento Mods Play:", modsPlayData);

        // ---- PASSO 2: LER O DOCUMENTO DO MOD ----
        console.log(`initializeModsPlay (Passo 2/5): A tentar ler o documento do mod com ID: ${modsPlayData.modId}...`);
        const modDoc = await getDoc(doc(db, 'mods', modsPlayData.modId));
        console.log("initializeModsPlay (Passo 2/5): SUCESSO. Leitura do documento do mod concluída.");

        if (!modDoc.exists()) {
            showInfoMessage("Erro: O Mod associado ao evento não foi encontrado.");
            return;
        }
        const modData = modDoc.data();
        contentTitle.textContent = modData.nomeMod;

        startCountdown(modsPlayData.dataFim.toDate());
        
        if (modData.nomeMod === "CRUSH BONES") {
            await renderCrushBonesContent(modsPlayData);
        } else {
            showInfoMessage("Este Mod não tem uma funcionalidade especial ativa.");
        }

    } catch (error) {
        // ESTE É O LOG DE ERRO MAIS IMPORTANTE NESTA FASE
        console.error("--- ERRO EM initializeModsPlay ---");
        console.error("A inicialização da página falhou. O erro completo é:", error);
        showInfoMessage("Ocorreu um erro ao carregar o conteúdo da página.");
    } finally {
        console.log("initializeModsPlay: Bloco 'finally' executado. A esconder ecrã de carregamento.");
        loadingScreen.style.display = 'none';
        content.style.display = 'block';
    }
}

// (O resto das suas funções como startCountdown, renderCrushBonesContent, etc., podem permanecer iguais)
// ... cole aqui o resto das suas funções ...
// Para garantir, estou a incluir as outras funções também.

function startCountdown(endTime) {
    clearInterval(countdownInterval);
    const update = () => {
        const timeLeft = endTime.getTime() - new Date().getTime();
        if (timeLeft <= 0) {
            clearInterval(countdownInterval);
            timerContainer.innerHTML = `<span id="countdown">Tempo Esgotado!</span>`;
            timerContainer.classList.add('expired');
            const predictionsList = document.getElementById('predictions-list');
            if (predictionsList) predictionsList.style.pointerEvents = 'none';
            const submitButton = document.getElementById('submit-crushbones-btn');
            if (submitButton) submitButton.setAttribute('disabled', 'true');
            return;
        }
        const d = Math.floor(timeLeft / 86400000);
        const h = Math.floor((timeLeft % 86400000) / 3600000);
        const m = Math.floor((timeLeft % 3600000) / 60000);
        const s = Math.floor((timeLeft % 60000) / 1000);
        timerContainer.innerHTML = `Tempo Restante: ${d > 0 ? `<span class="timer-unit">${d}d</span>` : ''}<span class="timer-unit">${h}h</span><span class="timer-unit">${m}m</span><span class="timer-unit">${s}s</span>`;
    };
    update();
    countdownInterval = setInterval(update, 1000);
}

async function renderCrushBonesContent(modsPlayData) {
    console.log("--- renderCrushBonesContent: INICIADO (VERSÃO CORRIGIDA) ---");
    // ---- PASSO 3: LER A TEMPORADA MAIS RECENTE ----
    console.log("renderCrushBonesContent (Passo 3/5): A ler a coleção 'palpites' para encontrar a última temporada...");
    const latestSeasonQuery = query(collection(db, 'palpites'), orderBy('temporada', 'desc'), limit(1));
    const latestSeasonSnapshot = await getDocs(latestSeasonQuery);
    console.log("renderCrushBonesContent (Passo 3/5): SUCESSO. Leitura de palpites concluída.");

    if (latestSeasonSnapshot.empty) { showInfoMessage("Ainda não existem palpites para exibir."); return; }
    const latestSeason = latestSeasonSnapshot.docs[0].data().temporada;
    currentTemporada = latestSeason;
    console.log("renderCrushBonesContent: Temporada atual definida como:", currentTemporada);

    // ---- PASSO 4: VERIFICAR SE O UTILIZADOR JÁ JOGOU (MÉTODO CORRIGIDO) ----
    console.log(`renderCrushBonesContent (Passo 4/5): A verificar se o utilizador já jogou nesta ronda (${modsPlayData.ronda}) via getDoc...`);
    
    // Construir o ID do documento diretamente
    const temporadaSanitizada = String(currentTemporada).replace(/\//g, '-');
    const rondaSanitizada = String(modsPlayData.ronda).replace(/\//g, '-');
    const docId = `${auth.currentUser.uid}_${temporadaSanitizada}_${rondaSanitizada}`;
    
    console.log("renderCrushBonesContent (Passo 4/5): ID do documento a verificar:", docId);
    
    // Fazer uma leitura direta (get) em vez de uma query (list)
    const existingPickRef = doc(db, 'palpitesmods', docId);
    const existingPickSnap = await getDoc(existingPickRef);
    
    console.log("renderCrushBonesContent (Passo 4/5): SUCESSO. Verificação com getDoc concluída.");
    const hasAlreadyPlayed = existingPickSnap.exists(); // A verificação é muito mais simples!
    console.log("renderCrushBonesContent: O utilizador já jogou?", hasAlreadyPlayed);
    
    // ---- PASSO 5: OBTER TODOS OS PALPITES DA RONDA ----
    // (O resto da função continua igual)
    console.log("renderCrushBonesContent (Passo 5/5): A obter todos os palpites para a ronda e temporada atuais...");
    const palpitesQuery = query(collection(db, 'palpites'), where('ronda', '==', modsPlayData.ronda), where('temporada', '==', latestSeason));
    const palpitesSnapshot = await getDocs(palpitesQuery);
    console.log("renderCrushBonesContent (Passo 5/5): SUCESSO. Leitura de palpites concluída. Palpites encontrados:", palpitesSnapshot.size);

    if (palpitesSnapshot.empty) { showInfoMessage("Nenhum palpite encontrado para esta ronda."); return; }
    
    const groupedPalpites = {};
    palpitesSnapshot.forEach(doc => {
        const palpite = doc.data();
        if (!groupedPalpites[palpite.userId]) groupedPalpites[palpite.userId] = {};
        if (!groupedPalpites[palpite.userId][palpite.jogoId]) groupedPalpites[palpite.userId][palpite.jogoId] = [];
        groupedPalpites[palpite.userId][palpite.jogoId].push(palpite);
    });
    const userIds = Object.keys(groupedPalpites);
    const jogoIds = new Set(palpitesSnapshot.docs.map(doc => doc.data().jogoId));
    const [userNames, gameNames] = await Promise.all([
        fetchNames(userIds, 'users', 'nometabela'),
        fetchNames(Array.from(jogoIds), 'jogos', 'nomeJogo')
    ]);
    const sortedUsers = userIds.map(id => ({ id: id, name: userNames[id] || 'Utilizador Desconhecido' })).sort((a, b) => a.name.localeCompare(b.name));
    let html = '<div id="predictions-list">';
    for (const user of sortedUsers) {
        const userId = user.id;
        if (userId === auth.currentUser.uid) { continue; }
        const userColor = generatePastelColorFromId(userId);
        let gamesHtml = '';
        for (const jogoId in groupedPalpites[userId]) {
            const jogoNomeCompleto = gameNames[jogoId] || 'Jogo Desconhecido';
            const jogoNomeCurto = jogoNomeCompleto.split(' - ')[0];
            let predictionsHtml = '';
            const palpitesDoJogo = groupedPalpites[userId][jogoId][0];
            Object.keys(palpitesDoJogo).filter(key => key.startsWith('palpite') && !key.includes('Status')).sort().forEach(key => {
                const itemClass = hasAlreadyPlayed ? 'prediction-item readonly' : 'prediction-item';
                predictionsHtml += `<li class="${itemClass}" data-jogo-id="${jogoId}" data-palpite-key="${key}" data-original-user-id="${userId}">${palpitesDoJogo[key]}</li>`;
            });
            if (predictionsHtml) { gamesHtml += `<div class="game-container"><div class="game-header"><span>${jogoNomeCurto}</span><i class="fas fa-chevron-down toggle-icon"></i></div><ul class="predictions-sublist">${predictionsHtml}</ul></div>`; }
        }
        if (gamesHtml) { html += `<div class="user-container" data-user-id="${userId}"><div class="user-header" style="background-color: ${userColor};"><span>${user.name}<i class="fas fa-check-circle selection-indicator"></i></span><i class="fas fa-chevron-down toggle-icon"></i></div><div class="games-list">${gamesHtml}</div></div>`; }
    }
    html += '</div>';
    modsplayContent.innerHTML = html;
    if (!hasAlreadyPlayed) {
        const submitContainer = document.getElementById('submit-container');
        submitContainer.innerHTML = `<button id="submit-crushbones-btn" class="submit-button verify-step" data-step="verify">Confirmar Seleções</button>`;
        document.getElementById('submit-crushbones-btn').addEventListener('click', handleConfirmationClick);
    } else {
        modsplayContent.innerHTML += '<p class="info-message" style="margin-top: 25px;">As tuas seleções para esta ronda já foram registadas.</p>';
    }
    addAccordionListeners(hasAlreadyPlayed);
    console.log("--- renderCrushBonesContent: CONTEÚDO RENDERIZADO ---");
}

function handleConfirmationClick() {
    const button = document.getElementById('submit-crushbones-btn');
    const currentStep = button.dataset.step;
    if (currentStep === 'verify') {
        document.querySelectorAll('.user-header.active, .game-header.active').forEach(header => header.classList.remove('active'));
        button.classList.remove('verify-step');
        button.textContent = 'Verifiquei e confirmo';
        button.dataset.step = 'confirm';
    } else if (currentStep === 'confirm') {
        submitCrushBonesSelections();
    }
}

async function submitCrushBonesSelections() {
    // A função de submissão original com a depuração de erros
    const button = document.getElementById('submit-crushbones-btn');
    if (Object.keys(selectedPredictions).length === 0) {
        alert("Nenhum palpite selecionado!");
        return;
    }

    button.disabled = true;
    button.textContent = 'A processar...';

    console.log("--- SUBMISSÃO INICIADA ---");

    try {
        const modsPlayData = (await getDocs(collection(db, 'modsplay'))).docs[0].data();
        const ronda = modsPlayData.ronda;
        
        console.log("SUBMISSÃO: UID:", auth.currentUser.uid);
        console.log("SUBMISSÃO: Temporada:", currentTemporada);
        console.log("SUBMISSÃO: Ronda:", ronda);
        
        const temporadaSanitizada = String(currentTemporada).replace(/\//g, '-');
        const rondaSanitizada = String(ronda).replace(/\//g, '-');
        const docId = `${auth.currentUser.uid}_${temporadaSanitizada}_${rondaSanitizada}`;
        
        console.log("SUBMISSÃO: ID do Documento:", docId);

        const modId = modsPlayData.modId;
        const modDoc = await getDoc(doc(db, 'mods', modId));
        const nomeMod = modDoc.exists() ? modDoc.data().nomeMod : "Mod Desconhecido";
        
        const submissaoData = {
            userId: auth.currentUser.uid,
            temporada: currentTemporada,
            ronda: ronda,
            dataSubmissao: serverTimestamp(),
            nomeMod: nomeMod,
            modId: modId,
            selecoes: {}
        };
        
        for (const jogoId in selectedPredictions) {
            const selection = selectedPredictions[jogoId];
            submissaoData.selecoes[jogoId] = {
                palpiteSelecionado: selection.palpiteText,
                copiedFromUserId: selection.originalUserId
            };
        }

        console.log("SUBMISSÃO: Dados a serem enviados:", submissaoData);
        
        const batch = writeBatch(db);
        const palpitesModsRef = doc(db, 'palpitesmods', docId);
        const boxRef = doc(db, 'box', docId);

        batch.set(palpitesModsRef, submissaoData);
        batch.set(boxRef, submissaoData);
        
        console.log("SUBMISSÃO: A executar batch.commit()...");
        await batch.commit();
        console.log("--- SUBMISSÃO CONCLUÍDA COM SUCESSO ---");

        document.getElementById('predictions-list').style.pointerEvents = 'none';
        button.style.display = 'none';
        modsplayContent.innerHTML += `<p class="info-message">As tuas seleções foram registadas com sucesso!</p>`;

    } catch (error) {
        console.error("--- ERRO NA SUBMISSÃO ---");
        console.error("Nome do Erro:", error.name);
        console.error("Código do Erro:", error.code);
        console.error("Mensagem do Erro:", error.message);
        console.error("Objeto de erro completo:", error);
        alert("Ocorreu um erro ao confirmar as seleções. Verifique a consola para mais detalhes.");
        button.disabled = false;
        button.textContent = 'Confirmar Seleções';
    }
}

async function fetchNames(ids, collectionName, fieldName) {
    if (ids.length === 0) return {};
    const nameMap = {};
    const promises = ids.map(id => getDoc(doc(db, collectionName, id)));
    const results = await Promise.all(promises);
    results.forEach(docSnap => {
        if (docSnap.exists()) { nameMap[docSnap.id] = docSnap.data()[fieldName]; }
    });
    return nameMap;
}

function updateUserSelectionIndicators() {
    document.querySelectorAll('.user-header').forEach(header => {
        header.classList.remove('has-selection');
    });
    const selectedUserIds = new Set(Object.values(selectedPredictions).map(selection => selection.originalUserId));
    selectedUserIds.forEach(userId => {
        const userContainer = document.querySelector(`.user-container[data-user-id="${userId}"]`);
        if (userContainer) {
            userContainer.querySelector('.user-header').classList.add('has-selection');
        }
    });
}

function generatePastelColorFromId(id) {
    let hash = 0;
    for (let i = 0; i < id.length; i++) {
        hash = id.charCodeAt(i) + ((hash << 5) - hash);
    }
    const h = hash % 360;
    return `hsl(${h}, 80%, 92%)`;
}

function addAccordionListeners(isReadOnly = false) {
    document.querySelectorAll('.user-header, .game-header').forEach(header => {
        header.addEventListener('click', () => header.classList.toggle('active'));
    });

    if (!isReadOnly) {
        document.querySelectorAll('.prediction-item').forEach(item => {
            item.addEventListener('click', () => {
                const jogoId = item.dataset.jogoId;
                const palpiteKey = item.dataset.palpiteKey;
                const originalUserId = item.dataset.originalUserId;
                const palpiteText = item.innerText.trim();

                // --- INÍCIO DA NOVA LÓGICA ---

                // 1. Verificar se já existe uma seleção para este 'originalUserId' noutro jogo.
                let existingSelectionFromThisUser = null;
                for (const gameId in selectedPredictions) {
                    // Encontra uma seleção do mesmo utilizador, mas para um jogo DIFERENTE
                    if (selectedPredictions[gameId].originalUserId === originalUserId && gameId !== jogoId) {
                        existingSelectionFromThisUser = { gameId: gameId, ...selectedPredictions[gameId] };
                        break;
                    }
                }

                // 2. Se uma seleção de outro jogo para este utilizador já existir, desmarque-a primeiro.
                if (existingSelectionFromThisUser) {
                    // Remover a classe 'selected' do item HTML antigo
                    const oldItem = document.querySelector(`.prediction-item[data-jogo-id="${existingSelectionFromThisUser.gameId}"].selected`);
                    if (oldItem) {
                        oldItem.classList.remove('selected');
                    }
                    // Remover a seleção antiga do nosso objeto de estado
                    delete selectedPredictions[existingSelectionFromThisUser.gameId];
                }

                // --- FIM DA NOVA LÓGICA ---

                // 3. Desmarcar qualquer item previamente selecionado PARA ESTE JOGO (lógica original mantida)
                // Isto garante que, se mudar de palpite dentro do mesmo jogo, o antigo é desmarcado.
                document.querySelectorAll(`.prediction-item[data-jogo-id="${jogoId}"]`).forEach(el => el.classList.remove('selected'));

                // 4. Marcar o novo item e atualizar o estado
                item.classList.add('selected');
                selectedPredictions[jogoId] = { palpiteKey, originalUserId, palpiteText };
                
                // 5. Atualizar os indicadores visuais nos cabeçalhos dos utilizadores
                updateUserSelectionIndicators();
            });
        });
    } else {
        document.querySelectorAll('.prediction-item').forEach(item => {
            item.style.cursor = 'default';
        });
    }
}

function showInfoMessage(message) {
    contentTitle.textContent = "Mods Play";
    modsplayContent.innerHTML = `<p class="info-message">${message}</p>`;
    timerContainer.style.display = 'none';
    loadingScreen.style.display = 'none';
    content.style.display = 'block';
}
    </script>
    <script src="menu-component.js"></script> 
</body>
</html>
