<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palpite - GGAMES</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        .game-info {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            text-align: center;
            position: relative;
        }

        .game-info::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border: 2px dashed transparent;
            border-radius: 12px;
            background-image: linear-gradient(90deg, #2176ff, #21d4fd, #b721ff, #ffdd00, #2176ff);
            background-size: 400% 100%;
            animation: snake-border 8s linear infinite;
            -webkit-mask:
                linear-gradient(#fff 0 0) content-box,
                linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
            z-index: 1;
        }

        @keyframes snake-border {
            0% {
                background-position: 0% 0%;
            }
            100% {
                background-position: 400% 0%;
            }
        }

        .game-header {
            margin-bottom: 8px;
        }

        .competition-and-date {
            gap: 3px;
        }

        .countdown-timer {
            margin: 8px auto;
            padding: 6px 10px;
        }

        .teams-container {
            margin-bottom: 10px;
        }

        .team-image {
            width: 60px;
            height: 60px;
            margin-bottom: 5px;
        }

        .vs {
            margin: 0 10px;
        }

        .game-date {
            margin-bottom: 5px;
        }

        .competition-info {
            gap: 5px;
        }

        .bottom-menu {
            padding: 8px 0;
            gap: 20px;
        }

        .menu-item i {
            margin-bottom: 2px;
        }

        .content {
            padding: 10px;
            margin-bottom: 120px;
        }

        .prediction-container {
            margin-top: 10px;
            gap: 3px;
        }

        .prediction-input {
            padding: 8px;
        }

        .prediction-label {
            margin-bottom: 3px;
        }

        .submit-button {
            margin-top: 10px;
            padding: 10px;
        }

        .popup {
            padding: 15px;
        }

        .popup-content {
            padding-right: 15px;
        }

        .popup-message {
            margin-top: 8px;
        }

        .game-header {
            margin-bottom: 15px; /* Spacing below header section */
            /* text-align: center; - No need to center text here, centered by game-info */
        }

        .competition-and-date {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            color: #444;
            font-size: 1.1em;
            font-weight: bold;
        }


        .countdown-timer {
            text-align: center;
            margin: 15px auto;
            padding: 10px 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
            color: #555;
            font-weight: 500;
            font-size: 0.95em;
            box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
            border: 1px solid #eee;
            display: block;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }


        .countdown-label {
            color: #777;
            font-size: 0.65em;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            font-weight: 600;
            margin-right: 6px;
        }

        .countdown-timer span {
            display: inline-block;
            margin: 0 3px;
            padding: 4px 6px;
            color: #444;
            border-radius: 5px;
            min-width: 25px;
            font-size: 0.85em;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            background-color: transparent;
            box-shadow: none;
            border: 1px solid #ddd;
            text-align: center;
        }

        .countdown-timer span:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
            background-color: #f0f0f0;
        }

        .timer-unit {
            display: inline-block;
            padding: 4px 8px;
            margin: 0 4px;
            background-color: #f0f0f0;
            border-radius: 4px;
            font-weight: bold;
            color: #333;
            min-width: 40px;
            text-align: center;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .timer-unit:hover {
            background-color: #e0e0e0;
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
        }

        .teams-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .team {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }

        .team-image {
            width: 80px;
            height: 80px;
            margin-bottom: 10px;
        }

        .team-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .team-name {
            font-weight: bold;
            text-align: center;
        }

        .vs {
            font-size: 24px;
            font-weight: bold;
            margin: 0 20px;
        }

        .game-details {
            text-align: center;
        }

        .game-date {
            font-size: 18px;
            margin-bottom: 10px;
        }

        .competition-info {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .competition-image {
            width: 30px;
            height: 30px;
        }

        .competition-image img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        body {
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            /* overflow: hidden; REMOVED overflow: hidden; from body style */
        }

        .bottom-menu {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            padding: 12px 0;
            display: flex;
            justify-content: center;
            gap: 32px;
            align-items: center;
            z-index: 1000;
        }

        .menu-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            color: #666;
            transition: color 0.3s ease;
        }

        .menu-item:hover, .menu-item.active {
            color: #333;
        }

        .menu-item i {
            font-size: 24px;
            margin-bottom: 4px;
        }

        .empire-icon {
            font-size: 42px;
            color: #2176ff;
            transform: translateY(-3px);
            filter: drop-shadow(0 0 8px rgba(33, 118, 255, 0.4));
            transition: all 0.3s ease;
        }

        .empire-icon:hover, .menu-item.active .empire-icon {
            color: #0056d6;
            transform: translateY(-8px);
            filter: drop-shadow(0 0 12px rgba(33, 118, 255, 0.6));
        }

        .content {
            padding: 20px;
            margin-bottom: 160px;
            display: none; /* Hide content initially */
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .error {
            color: #dc3545;
            background: #f8d7da;
        }

        .prediction-container {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            position: relative; /* Add position relative for dropdown positioning */
        }

        .prediction-input {
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            width: 100%;
            transition: border-color 0.3s ease;
            cursor: pointer; /* Indicate input is clickable */
        }

        .prediction-input:focus {
            border-color: #2176ff;
            outline: none;
        }

        .prediction-label {
            font-weight: bold;
            color: #333;
            margin-bottom: 5px;
        }

        .submit-button {
            margin-top: 20px;
            padding: 15px;
            background: #2176ff;
            color: white;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: background-color 0.3s ease;
        }

        .submit-button:hover {
            background: #0056d6;
        }

        /* Custom Popup Styles */
        .popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1002;
            min-width: 300px;
        }

        .popup-content {
            position: relative;
            padding-right: 20px;
        }

        .close-popup {
            position: absolute;
            top: 0;
            right: 0;
            cursor: pointer;
            font-size: 20px;
            color: #666;
        }

        .close-popup:hover {
            color: #333;
        }

        .popup-message {
            margin-top: 10px;
            color: #dc3545;
            text-align: center;
        }

        /* Loading Screen Styles */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1001;
        }

        .loading-spinner {
            border: 16px solid #f3f3f3;
            border-top: 16px solid #3498db;
            border-radius: 50%;
            width: 120px;
            height: 120px;
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* DROPDOWN MENU STYLES */
        .category-dropdown, .subcategory-dropdown, .third-category-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            z-index: 1003;
            display: none;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border: 1px solid #e0e0e0;
            width: 100%; /* Match parent width */
            max-height: 300px;
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        .category-dropdown ul, .subcategory-dropdown ul, .third-category-dropdown ul {
            list-style: none;
            padding: 8px 0;
            margin: 0;
        }

        .category-dropdown li, .subcategory-dropdown li, .third-category-dropdown li {
            padding: 10px 16px;
            cursor: pointer;
            color: #333;
            font-size: 14px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .category-dropdown li:hover, .subcategory-dropdown li:hover, .third-category-dropdown li:hover {
            background-color: #f5f7fa;
            color: #2176ff;
        }

        .category-dropdown li:active, .subcategory-dropdown li:active, .third-category-dropdown li:active {
            background-color: #e8f0fe;
        }

        .subcategory-dropdown {
            margin-left: 4px;
            border-left: 3px solid #2176ff;
        }

        .third-category-dropdown {
            margin-left: 8px;
            border-left: 3px solid #2176ff;
        }

        .category-dropdown li.free-prediction {
            color: #2176ff;
            font-weight: 500;
            border-top: 1px solid #e0e0e0;
            margin-top: 8px;
            padding-top: 12px;
        }

        .category-dropdown li.free-prediction:hover {
            background-color: #e8f0fe;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-spinner"></div>
    </div>

    <!-- Add Error Popup -->
    <div id="error-popup" class="popup">
        <div class="popup-content">
            <span class="close-popup">×</span>
            <div class="popup-message"></div>
        </div>
    </div>

    <!-- Add Confirmation Popup -->
    <div id="confirmation-popup" class="popup">
        <div class="popup-content">
            <span class="close-popup">×</span>
            <h3 style="margin-bottom: 15px;">Confirmar Palpites</h3>
            <div id="confirmation-predictions" style="margin-bottom: 20px;"></div>
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button onclick="confirmPredictions()" style="background: #2176ff; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Confirmar</button>
                <button onclick="closeConfirmationPopup()" style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer;">Cancelar</button>
            </div>
        </div>
    </div>

    <div class="content">
        <h1></h1>
        <div id="game-container">
            <!-- Game information will be loaded here dynamically -->
        </div>
    </div>

    <nav class="bottom-menu">
        <a href="1x.html" class="menu-item">
            <i class="fas fa-home"></i>
        </a>
        <a href="market.html" class="menu-item">
            <i class="fas fa-shopping-cart"></i>
        </a>
        <a href="team.html" class="menu-item">
            <i class="fas fa-users"></i>
        </a>
        <a href="empire.html" class="menu-item">
            <i class="fas fa-landmark empire-icon"></i>
        </a>
        <a href="rankings.html" class="menu-item">
            <i class="fas fa-list"></i>
        </a>
        <a href="profile.html" class="menu-item">
            <i class="fas fa-user"></i>
        </a>
    </nav>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, doc, getDoc, addDoc, collection, serverTimestamp, getDocs, query, where, orderBy } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

const firebaseConfig = {
    apiKey: "AIzaSyD8WcFD7jC55feYYqdY7aJSgxXyXkEjTX0", // Atenção: Considere proteger esta chave
    authDomain: "g-games-8a8fc.firebaseapp.com",
    projectId: "g-games-8a8fc",
    storageBucket: "g-games-8a8fc.firebasestorage.app",
    messagingSenderId: "689897349449",
    appId: "1:689897349449:web:536599794579901beb7a98",
    measurementId: "G-GTTPJ6G5MD"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// Grupo 2: Declara as variáveis que a sua página vai usar
let countdownInterval;
const loadingScreen = document.getElementById('loading-screen');
const content = document.querySelector('.content');
let currentUserStatus = null;
let currentPredictionInput = null;
let categoryDropdown = null;
let currentGame = null;

// --- Helper Functions ---

async function getUserStatus(userId) {
    try {
        const userDoc = doc(db, 'users', userId);
        const docSnap = await getDoc(userDoc);
        if (docSnap.exists()) {
            return docSnap.data().estatuto;
        } else {
            console.warn("User document not found for status:", userId);
            return null;
        }
    } catch (error) {
        console.error("Error getting user status:", error);
        return null;
    }
}

function showErrorPopup(message) {
    const popup = document.getElementById('error-popup');
    if (!popup) { console.error("Error popup element not found!"); return; }
    const popupMessage = popup.querySelector('.popup-message');
    if (!popupMessage) { console.error("Error popup message element not found!"); return; }
    popupMessage.textContent = message;
    popup.style.display = 'block';
}

// Example success popup (can be styled better)
function showSuccessPopup(message) {
    // You can replace this with a more styled popup later
    alert(message);
}

// Function to show confirmation popup
function showConfirmationPopup(predictions) {
    const confirmationPopup = document.getElementById('confirmation-popup');
    const confirmationPredictions = document.getElementById('confirmation-predictions');
    if (!confirmationPopup || !confirmationPredictions) {
        console.error("Confirmation popup elements not found!");
        showErrorPopup("Erro ao mostrar confirmação.");
        return;
    }
    let predictionsHtml = '<div style="text-align: center;">';
    predictions.forEach((prediction, index) => {
        predictionsHtml += `<p style="margin: 5px 0;">Palpite ${index + 1}: <strong>${prediction}</strong></p>`;
    });
    predictionsHtml += '</div>';
    confirmationPredictions.innerHTML = predictionsHtml;
    confirmationPopup.style.display = 'block';
}

// Function to close confirmation popup
window.closeConfirmationPopup = function() {
    const confirmationPopup = document.getElementById('confirmation-popup');
    if (confirmationPopup) {
        confirmationPopup.style.display = 'none';
    }
}

// Close error popup
const errorPopupCloseButton = document.querySelector('#error-popup .close-popup');
if (errorPopupCloseButton) {
    errorPopupCloseButton.addEventListener('click', function() {
        const errorPopup = document.getElementById('error-popup');
        if (errorPopup) errorPopup.style.display = 'none';
    });
} else {
    console.warn("Error popup close button not found");
}

// Close confirmation popup (using the X button)
const confirmationPopupCloseButton = document.querySelector('#confirmation-popup .close-popup');
if (confirmationPopupCloseButton) {
    confirmationPopupCloseButton.addEventListener('click', closeConfirmationPopup);
} else {
    console.warn("Confirmation popup close button not found");
}


// --- Firestore Data Fetching ---

async function fetchCategories() {
    try {
        const categoriesRef = collection(db, 'oddcategorias');
        const q = query(categoriesRef, where('categoria_subcategoria_3cat', '==', 'categoria'), orderBy('ordem'));
        const querySnapshot = await getDocs(q);
        const categories = [];
        querySnapshot.forEach(doc => {
            categories.push({
                id: doc.id,
                nomecategoria: doc.data().nomecategoria,
                indiceIngles: doc.data().indiceIngles || null,
                ordem: doc.data().ordem,
                icon: doc.data().icon || '⭐' // Busca o emoji do Firebase, usa ⭐ como fallback
            });
        });
        return categories;
    } catch (error) {
        console.error('Error fetching categories:', error);
        showErrorPopup('Erro ao carregar categorias de palpites.');
        return [];
    }
}

async function fetchSubcategories(parentCategoryId) {
    console.log("Fetching subcategories for category ID:", parentCategoryId);
    try {
        const subcategoriesRef = collection(db, 'oddcategorias');
        const q = query(subcategoriesRef,
            where('categoriapai', '==', parentCategoryId),
            where('categoria_subcategoria_3cat', '==', 'subcategoria'),
            orderBy('ordem')
        );
        const querySnapshot = await getDocs(q);
        const subcategories = [];
        querySnapshot.forEach(doc => {
            subcategories.push({
                id: doc.id,
                nomesubcategoria: doc.data().nomesubcategoria,
                indiceIngles: doc.data().indiceIngles || null, // Fetch indiceIngles here
                ordem: doc.data().ordem
            });
        });

        const subcategoriesWithBackButton = [
            { id: 'go-back-category', nomesubcategoria: '<--Voltar Atrás', indiceIngles: null }, // Add Go Back
            ...subcategories
        ];
        console.log("Subcategories fetched:", subcategoriesWithBackButton);
        return subcategoriesWithBackButton;
    } catch (error) {
        console.error('Error fetching subcategories:', error);
        showErrorPopup('Erro ao carregar subcategorias de palpites.');
        return [{ id: 'go-back-category', nomesubcategoria: '<--Voltar Atrás', indiceIngles: null }]; // Return at least Go Back on error
    }
}

async function fetchThirdLevelCategories(parentCategoryId, parentSubcategoryId) {
    console.log("Fetching third-level categories for parent Category ID:", parentCategoryId, "and parent Subcategory ID:", parentSubcategoryId);
    try {
        const thirdLevelCategoriesRef = collection(db, 'oddcategorias');
        const q = query(thirdLevelCategoriesRef,
            where('subcategoriapai', '==', parentSubcategoryId),
            where('categoriapai', '==', parentCategoryId),
            where('categoria_subcategoria_3cat', '==', '3cat'),
            orderBy('ordem')
        );
        const querySnapshot = await getDocs(q);
        const thirdLevelCategories = [];
        querySnapshot.forEach(doc => {
            thirdLevelCategories.push({
                id: doc.id,
                nome3categoria: doc.data().nome3categoria,
                indiceIngles: doc.data().indiceIngles || null, // Fetch indiceIngles here
                ordem: doc.data().ordem
            });
        });

        const thirdLevelCategoriesWithBackButton = [
            { id: 'go-back-subcategory', nome3categoria: '<--Voltar Atrás', indiceIngles: null }, // Add Go Back
            ...thirdLevelCategories
        ];

        console.log("Third-level categories fetched:", thirdLevelCategoriesWithBackButton);
        return thirdLevelCategoriesWithBackButton;

    } catch (error) {
        console.error('Error fetching third-level categories:', error);
        showErrorPopup('Erro ao carregar opções de palpites de terceiro nível.');
         return [{ id: 'go-back-subcategory', nome3categoria: '<--Voltar Atrás', indiceIngles: null }]; // Return at least Go Back on error
    }
}

async function loadGameData(gameId) {
    try {
        const gameDoc = await getDoc(doc(db, 'jogos', gameId));
        if (!gameDoc.exists()) {
            throw new Error('Jogo não encontrado');
        }

        const game = { id: gameDoc.id, ...gameDoc.data() }; // Include ID

        // Ensure essential fields exist
        game.equipaCasaId = game.equipaCasaId || null;
        game.equipaForaId = game.equipaForaId || null;
        game.numeroPalpites = game.numeroPalpites || 1; // Default to 1 if missing

        // Fetch team names if IDs exist
        let equipaCasaNome = 'Equipa Desconhecida';
        let equipaForaNome = 'Equipa Desconhecida';

        if (game.equipaCasaId) {
            const equipaCasaDoc = await getDoc(doc(db, 'clubes', game.equipaCasaId));
            equipaCasaNome = equipaCasaDoc.exists() ? equipaCasaDoc.data().nome : equipaCasaNome;
        }
        if (game.equipaForaId) {
            const equipaForaDoc = await getDoc(doc(db, 'clubes', game.equipaForaId));
            equipaForaNome = equipaForaDoc.exists() ? equipaForaDoc.data().nome : equipaForaNome;
        }

        game.equipaCasa = equipaCasaNome;
        game.equipaFora = equipaForaNome;

        // Ensure timestamp fields are valid Firebase Timestamps
        if (game.dataJogo && typeof game.dataJogo.toDate !== 'function') {
            console.warn("dataJogo is not a Firestore Timestamp, attempting conversion if possible.");
            // Handle potential non-timestamp data if necessary, otherwise expect errors later
        }
        if (game.fimIntervalo && typeof game.fimIntervalo.toDate !== 'function') {
             console.warn("fimIntervalo is not a Firestore Timestamp.");
             game.fimIntervalo = null; // Set to null if invalid to prevent errors
        }


        currentGame = game; // Store globally
        return game;
    } catch (error) {
        console.error('Error loading game data:', error);
        showErrorPopup(`Erro ao carregar dados do jogo: ${error.message}`);
        return null;
    }
}

async function checkExistingPredictions(gameId) {
    try {
        if (!auth.currentUser) return null;

        const userPalpitesRef = collection(doc(db, 'users', auth.currentUser.uid), 'palpites');
        // Query specifically for the gameId to be more efficient
        const q = query(userPalpitesRef, where('jogoId', '==', gameId));
        const querySnapshot = await getDocs(q);

        if (!querySnapshot.empty) {
            // Assuming only one prediction per user per game
            const palpiteData = querySnapshot.docs[0].data();
            console.log('Found existing prediction:', palpiteData);
            return palpiteData;
        }
        console.log('No existing predictions found for game:', gameId);
        return null;
    } catch (error) {
        console.error('Error checking existing predictions:', error);
        // Don't show popup here, just return null
        return null;
    }
}


// --- Prediction Submission Logic ---

// Function triggered by the "Enviar Palpites" button (shows confirmation)
window.submitPredictions = function() {
    if (!currentGame) {
        showErrorPopup("Dados do jogo não carregados. Tente recarregar a página.");
        return;
    }
    const predictions = [];
    let allFilled = true;
    for (let i = 0; i < currentGame.numeroPalpites; i++) {
        const input = document.getElementById(`prediction${i + 1}`);
        if (!input || !input.value.trim()) {
            showErrorPopup(`Ainda não fez todos os palpites possíveis (falta o Palpite ${i + 1})`);
            allFilled = false;
            break;
        }
        predictions.push(input.value.trim());
    }

    if (allFilled) {
        showConfirmationPopup(predictions);
    }
}

// Function triggered by the "Confirmar" button inside the popup (saves to DB)
window.confirmPredictions = async function() {
    try {
        if (!currentGame || !auth.currentUser) {
            throw new Error('Dados do jogo ou utilizador não disponíveis.');
        }

        // Check if prediction deadline has passed
        const now = new Date();
        if (!currentGame.fimIntervalo) {
            showErrorPopup('Informação de data indisponível (fimIntervalo). Não é possível palpitar.');
            closeConfirmationPopup();
            setTimeout(() => { window.location.href = '1x.html'; }, 4000);
            return;
        }

        const fimIntervalo = currentGame.fimIntervalo.toDate();
        if (now > fimIntervalo) {
            showErrorPopup('Tempo esgotado, impossível palpitar.');
            closeConfirmationPopup();
            setTimeout(() => { window.location.href = '1x.html'; }, 4000);
            return;
        }

        const predictionsData = []; // Array to hold { value, indiceMap } for each prediction
        let inputsAreValid = true;

        // --- Loop to gather data from inputs ---
        for (let i = 0; i < currentGame.numeroPalpites; i++) {
            const predictionNumber = i + 1;
            const input = document.getElementById(`prediction${predictionNumber}`);

            if (!input || !input.value.trim()) {
                showErrorPopup(`Palpite ${predictionNumber} está vazio.`);
                inputsAreValid = false;
                break;
            }

            const predictionValue = input.value.trim();
            const isFreePrediction = input.dataset.isFree === "true";

            // Read indices directly from data attributes
            const catIndice = input.dataset.catIndice || null;
            const subcatIndice = input.dataset.subcatIndice || null;
            const cat3Indice = input.dataset.cat3Indice || null;

            let indiceMap = null;
            if (!isFreePrediction) {
                // Only create map if it's not a free prediction
                indiceMap = {
                    PalpiteCategoria: catIndice,
                    PalpiteSubCategoria: subcatIndice,
                    PalpiteCategoria3: cat3Indice
                };

                 // Basic validation: Ensure indices are present if not free prediction
                 if(catIndice === null) { // At least category should exist if not free
                    console.warn(`Palpite ${predictionNumber} marcado como não-livre mas sem índice de categoria.`);
                    // You might want to show an error here depending on strictness
                 }

            }

            predictionsData.push({
                value: predictionValue,
                indiceMap: indiceMap
            });
        } // --- End of loop ---

        if (!inputsAreValid) {
            closeConfirmationPopup(); // Close confirmation if validation failed
            return;
        }

        // Get user data
        const userDoc = await getDoc(doc(db, 'users', auth.currentUser.uid));
        if (!userDoc.exists()) {
            throw new Error('User data not found');
        }
        const userData = userDoc.data();
        const userNomeDeUsuario = userData.nomeDeUsuario || 'Utilizador Anónimo'; // Fallback

        // Build the final object for Firestore
        const palpiteData = {
            userId: auth.currentUser.uid,
            nomeDeUsuario: userNomeDeUsuario,
            jogoId: currentGame.id,
            nomeJogo: currentGame.nomeJogo || 'Jogo Sem Nome', // Fallback
            equipaCasaId: currentGame.equipaCasaId,
            equipaCasa: currentGame.equipaCasa,
            equipaForaId: currentGame.equipaForaId,
            equipaFora: currentGame.equipaFora,
            dataJogo: currentGame.dataJogo, // Should be a Timestamp
            competicaoId: currentGame.competicaoId || null,
            competicao: currentGame.competicao || 'Competição Desconhecida', // Fallback
            ronda: currentGame.ronda || null,
            modId: currentGame.modId || null,
            temporada: currentGame.temporada || null,
            dataPalpite: serverTimestamp(),
            PontosPossiveis: 0, // Initialize scoring fields
            PontosGanhos: 0,
            GCoinsGanhos: 0.0,
            Analisado: "Não",
        };

        // Add individual predictions and their index maps
        predictionsData.forEach((pData, index) => {
            const predictionNumber = index + 1;
            palpiteData[`palpite${predictionNumber}`] = pData.value;
            palpiteData[`Palpite${predictionNumber}PontosGanhos`] = 0;
            palpiteData[`Palpite${predictionNumber}PontosQuanto`] = 0; // Assuming this is the potential points

            // Add the index map if it exists (i.e., not a free prediction)
            // Store null explicitly if it's free or map is missing
            palpiteData[`Palpite${predictionNumber}IndiceIngles`] = pData.indiceMap;

        });

        console.log("Final palpiteData to be saved:", JSON.stringify(palpiteData, null, 2)); // Log for verification

        // Save to both collections
        const userPalpitesCollection = collection(doc(db, 'users', auth.currentUser.uid), 'palpites');
        const globalPalpitesCollection = collection(db, 'palpites');

        await Promise.all([
            addDoc(globalPalpitesCollection, palpiteData),
            addDoc(userPalpitesCollection, palpiteData)
        ]);

        closeConfirmationPopup();
        showSuccessPopup("Palpites enviados com sucesso!");

        // Redirect or reload after success
        setTimeout(() => {
            window.location.reload(); // Reload to show read-only inputs
            // Or redirect: window.location.href = '1x.html';
        }, 1500); // Short delay

    } catch (error) {
        console.error('Error submitting predictions:', error);
        showErrorPopup(`Erro ao enviar palpites: ${error.message}`);
        closeConfirmationPopup(); // Close confirmation on error
    }
};


// --- Main Function to Load Game Details and Setup UI ---

async function loadGameDetails() {
    const gameContainer = document.getElementById('game-container');
    if (!gameContainer) {
        console.error("Element 'game-container' not found!");
        showErrorPopup("Erro interno: Elemento da página não encontrado.");
        loadingScreen.style.display = 'none'; // Hide loading anyway
        return;
    }

    try {
        loadingScreen.style.display = 'flex'; // Show loading

        const urlParams = new URLSearchParams(window.location.search);
        const gameId = urlParams.get('id');

        if (!gameId) {
            showErrorPopup('Nenhum jogo selecionado. Redirecionando...');
            setTimeout(() => { window.location.href = '1x.html'; }, 3000);
            return; // Stop execution here
        }

        // Load game data (includes team names)
        const game = await loadGameData(gameId);
        if (!game) {
            // Error already shown in loadGameData
            setTimeout(() => { window.location.href = '1x.html'; }, 3000);
            return; // Stop execution
        }

        // Check for existing predictions for this user and game
        const existingPredictions = await checkExistingPredictions(game.id);

        // Fetch competition data (if ID exists)
        let competicaoData = {};
        if (game.competicaoId) {
            try {
                const competicaoDoc = await getDoc(doc(db, 'competicoes', game.competicaoId));
                if (competicaoDoc.exists()) {
                    competicaoData = competicaoDoc.data();
                } else {
                     console.warn(`Competition document not found for ID: ${game.competicaoId}`);
                }
            } catch(err) {
                 console.error(`Error fetching competition data for ID ${game.competicaoId}:`, err);
            }
        }

        // Fetch team images (if IDs exist) - assuming 'imagem' field in clube docs
        let equipaCasaImagem = 'https://via.placeholder.com/80?text=Casa'; // Default
        let equipaForaImagem = 'https://via.placeholder.com/80?text=Fora'; // Default
        try {
             if (game.equipaCasaId) {
                 const casaDoc = await getDoc(doc(db, 'clubes', game.equipaCasaId));
                 if (casaDoc.exists() && casaDoc.data().imagem) equipaCasaImagem = casaDoc.data().imagem;
             }
             if (game.equipaForaId) {
                 const foraDoc = await getDoc(doc(db, 'clubes', game.equipaForaId));
                 if (foraDoc.exists() && foraDoc.data().imagem) equipaForaImagem = foraDoc.data().imagem;
             }
        } catch (err) {
             console.error("Error fetching team images:", err);
        }


        // Format date and time
        let formattedDate = 'Data Indisponível';
        let formattedTime = '';
        if (game.dataJogo && typeof game.dataJogo.toDate === 'function') {
            const gameDate = game.dataJogo.toDate();
            formattedDate = gameDate.toLocaleDateString('pt-PT', { day: '2-digit', month: '2-digit', year: 'numeric' });
            formattedTime = gameDate.toLocaleTimeString('pt-PT', { hour: '2-digit', minute: '2-digit' });
        } else {
            console.warn("Game date (dataJogo) is invalid or missing.");
        }


        // --- Generate HTML ---

        // Fetch main categories for dropdowns
        const categories = await fetchCategories();

        let predictionsHtml = '';
        for (let i = 0; i < game.numeroPalpites; i++) {
            const predictionNumber = i + 1;
            const existingValue = existingPredictions ? existingPredictions[`palpite${predictionNumber}`] : '';
            const isReadOnly = existingPredictions ? 'readonly' : '';
            const placeholderText = isReadOnly ? '' : `Escolhe o teu palpite ${predictionNumber}`;

            // Generate category list items
            const categoryListItems = categories.map(category => {
                return `<li data-category-id="${category.id}" data-category-name="${category.nomecategoria}">
                            <span style="margin-right: 8px;">${category.icon}</span>${category.nomecategoria}
                        </li>`;
            }).join('');

            predictionsHtml += `
                <div class="prediction-container">
                    <label class="prediction-label" for="prediction${predictionNumber}">Palpite ${predictionNumber}</label>
                    <input type="text"
                        id="prediction${predictionNumber}"
                        class="prediction-input"
                        value="${existingValue}"
                        ${isReadOnly}
                        placeholder="${placeholderText}">
                    ${!isReadOnly ? `
                    <div id="categoryDropdown${predictionNumber}" class="category-dropdown">
                        <ul>
                            ${categoryListItems}
                            <li data-category-name="Palpite Livre" class="free-prediction"><i class="fas fa-edit"></i> Palpite Livre</li>
                        </ul>
                    </div>
                    <!-- Subcategory dropdown placeholder (created dynamically) -->
                    <!-- Third-level dropdown placeholder (created dynamically) -->
                    ` : ''}
                </div>
            `;
        }

        // Assemble the main game info HTML
        gameContainer.innerHTML = `
            <div class="game-info">
                <div class="game-header" style="text-align: center; margin-bottom: 15px;">
                    <div class="competition-and-date" style="display: flex; align-items: center; justify-content: center; gap: 5px; color: #444; font-size: 1.0em; font-weight: 500; flex-wrap: wrap;">
                        <div class="competition-image" style="height: 20px; display: inline-flex; align-items: center;">
                            <img src="${competicaoData?.imagem || 'https://via.placeholder.com/20?text=C'}" alt="${game.competicao}" style="max-height: 100%; width: auto; vertical-align: middle;">
                        </div>
                        <span style="font-weight: bold;">${game.competicao}</span>
                        ${game.ronda ? `<span style="color: #666;">(${game.ronda})</span>`: ''}
                        <span style="margin: 0 5px; color: #ccc;">|</span>
                        <span>${formattedDate}</span>
                        ${formattedTime ? `<span>${formattedTime}</span>` : ''}
                    </div>
                </div>

                <div class="teams-container">
                    <div class="team">
                        <div class="team-image">
                            <img src="${equipaCasaImagem}" alt="${game.equipaCasa}">
                        </div>
                        <div class="team-name">${game.equipaCasa}</div>
                    </div>
                    <div class="vs">VS</div>
                    <div class="team">
                        <div class="team-image">
                            <img src="${equipaForaImagem}" alt="${game.equipaFora}">
                        </div>
                        <div class="team-name">${game.equipaFora}</div>
                    </div>
                </div>

                ${!existingPredictions ? `
                <div class="countdown-timer">
                    <span class="countdown-label">Tempo restante para palpitar:</span>
                    <span id="countdown" style="display: inline-block; font-weight: bold;">Calculando...</span>
                </div>
                `: `<div style="text-align: center; margin-top: 15px; padding: 10px; background-color: #e9f5ff; border: 1px solid #b3d7ff; border-radius: 8px; color: #004085;"><strong>Já efetuou o seu palpite para este jogo.</strong></div>`}
            </div>
            <div class="prediction-inputs-container" style="margin-top: 20px;">
                ${predictionsHtml}
                ${!existingPredictions ? `<button class="submit-button" onclick="submitPredictions()">Enviar Palpites</button>` : ''}
            </div>
        `;

        // --- Start Countdown Timer (only if predictions not submitted) ---
        if (!existingPredictions && game.fimIntervalo) {
            const countdownElement = document.getElementById('countdown');
             if (countdownElement) {
                 clearInterval(countdownInterval); // Clear any previous interval

                 const updateCountdown = () => {
                    const now = new Date().getTime();
                    const endTime = game.fimIntervalo.toDate().getTime();
                    const timeLeft = endTime - now;

                    if (timeLeft <= 0) {
                        countdownElement.innerHTML = '<span style="color: red; font-weight: bold;">Tempo esgotado!</span>';
                        clearInterval(countdownInterval);
                        // Optionally disable inputs/button if timer expires dynamically
                        const submitBtn = gameContainer.querySelector('.submit-button');
                        if(submitBtn) submitBtn.disabled = true;
                        const inputs = gameContainer.querySelectorAll('.prediction-input');
                        inputs.forEach(inp => inp.readOnly = true);
                        return;
                    }

                    const days = Math.floor(timeLeft / (1000 * 60 * 60 * 24));
                    const hours = Math.floor((timeLeft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                    const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

                    countdownElement.innerHTML = `
                        ${days > 0 ? `<span class="timer-unit">${days}d</span>` : ''}
                        <span class="timer-unit">${hours}h</span>
                        <span class="timer-unit">${minutes}m</span>
                        <span class="timer-unit">${seconds}s</span>
                    `;
                 };

                 updateCountdown(); // Initial call
                 countdownInterval = setInterval(updateCountdown, 1000);

             } else {
                 console.error("Countdown element not found");
             }
        } else if (!existingPredictions && !game.fimIntervalo) {
             const countdownElement = document.getElementById('countdown');
             if(countdownElement) countdownElement.innerHTML = '<span style="color: orange;">Data limite indisponível</span>';
        }


        // --- Add Event Listeners for Dropdowns (only if not readonly) ---
        if (!existingPredictions) {
            setupDropdownEventListeners(game);
        }

        // Hide loading screen, show content
        loadingScreen.style.display = 'none';
        content.style.display = 'block';


    } catch (error) {
        console.error('Error in loadGameDetails:', error);
        if (gameContainer) {
             gameContainer.innerHTML = `<p style="color: red; text-align: center;">Erro fatal ao carregar detalhes do jogo: ${error.message}</p>`;
        } else {
             showErrorPopup(`Erro fatal ao carregar detalhes do jogo: ${error.message}`);
        }
        loadingScreen.style.display = 'none'; // Hide loading on error
        content.style.display = 'block'; // Show content to display error
         setTimeout(() => { window.location.href = '1x.html'; }, 5000); // Redirect after showing error
    }
}

// --- Function to Setup Dropdown Listeners ---
function setupDropdownEventListeners(game) {
    for (let i = 0; i < game.numeroPalpites; i++) {
        const predictionNumber = i + 1;
        const input = document.getElementById(`prediction${predictionNumber}`);
        const dropdown = document.getElementById(`categoryDropdown${predictionNumber}`);

        if (!input || !dropdown) {
             console.warn(`Input or dropdown not found for prediction ${predictionNumber}`);
             continue; // Skip if elements are missing
        }


        input.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent click from immediately closing dropdown via global listener
            event.preventDefault(); // Prevent keyboard on mobile

            // Close any other open dropdowns before opening this one
             closeAllDropdowns(predictionNumber);


            if (currentPredictionInput && currentPredictionInput !== input) {
                // Logic to close previously active dropdowns if any (handled by closeAllDropdowns now)
            }

            // Clear previous selection data when input is clicked
            input.removeAttribute('data-cat-id');
            input.removeAttribute('data-subcat-id');
            input.removeAttribute('data-cat3-id');
            input.removeAttribute('data-cat-indice');
            input.removeAttribute('data-subcat-indice');
            input.removeAttribute('data-cat3-indice');
            input.removeAttribute('data-is-free'); // Clear free flag too

            currentPredictionInput = input; // Set the currently active input
            categoryDropdown = dropdown; // Set the currently active category dropdown
            dropdown.style.display = 'block';
        });

        const categoryItems = dropdown.querySelectorAll('li');
        categoryItems.forEach(item => {
            item.addEventListener('click', async (event) => {
                event.stopPropagation(); // Prevent click from bubbling to global listener
                if (!currentPredictionInput) return; // Should not happen if input was clicked first

                const selectedCategoryName = item.dataset.categoryName;
                const selectedCategoryId = item.dataset.categoryId; // Might be undefined for "Free"

                // Clear lower-level data
                currentPredictionInput.removeAttribute('data-subcat-id');
                currentPredictionInput.removeAttribute('data-cat3-id');
                currentPredictionInput.removeAttribute('data-subcat-indice');
                currentPredictionInput.removeAttribute('data-cat3-indice');


                if (item.classList.contains('free-prediction')) {
                    currentPredictionInput.value = '';
                    currentPredictionInput.readOnly = false; // Allow typing
                    currentPredictionInput.placeholder = 'Digite o seu palpite livre...';
                    currentPredictionInput.focus();
                    currentPredictionInput.dataset.isFree = "true"; // Mark as free
                    currentPredictionInput.removeAttribute('data-cat-id'); // Ensure no category ID
                     currentPredictionInput.removeAttribute('data-cat-indice');


                    dropdown.style.display = 'none';
                    // Don't reset currentPredictionInput here, let focus handle it
                    categoryDropdown = null;
                    return;
                }

                // --- Handle Regular Category Selection ---
                currentPredictionInput.dataset.isFree = "false";
                currentPredictionInput.dataset.catId = selectedCategoryId;
                currentPredictionInput.readOnly = true; // Make readonly after selection
                currentPredictionInput.placeholder = 'Palpite selecionado'; // Change placeholder


                // Fetch and store category indiceIngles
                try {
                    const catDoc = await getDoc(doc(db, 'oddcategorias', selectedCategoryId));
                    if (catDoc.exists() && catDoc.data().indiceIngles) {
                        currentPredictionInput.dataset.catIndice = catDoc.data().indiceIngles;
                    } else {
                        currentPredictionInput.removeAttribute('data-cat-indice'); // Remove if not found
                    }
                } catch (e) {
                    console.error("Error fetching cat indice", e);
                    currentPredictionInput.removeAttribute('data-cat-indice');
                }

                dropdown.style.display = 'none'; // Hide category dropdown

                const subcategories = await fetchSubcategories(selectedCategoryId);

                if (subcategories.length > 1) { // More than just "Go Back"
                    displaySubcategoryDropdown(subcategories, predictionNumber, selectedCategoryName);
                } else {
                    // Stop at category level
                    currentPredictionInput.value = selectedCategoryName; // Set value
                    // Reset input tracking after final selection
                    // currentPredictionInput = null; // DEFERRED: Reset only when clicking outside or finishing
                    categoryDropdown = null;
                }
            });
        });
    } // End FOR loop iterating through inputs
}

// --- Function to Display Subcategory Dropdown ---
function displaySubcategoryDropdown(subcategories, predictionNumber, parentCategoryName) {
    const input = document.getElementById(`prediction${predictionNumber}`);
    if (!input) return;

    let subcategoryDropdown = document.getElementById(`subcategoryDropdown${predictionNumber}`);
    if (!subcategoryDropdown) {
        subcategoryDropdown = document.createElement('div');
        subcategoryDropdown.className = 'category-dropdown subcategory-dropdown'; // Use specific class
        subcategoryDropdown.id = `subcategoryDropdown${predictionNumber}`;
        subcategoryDropdown.innerHTML = '<ul></ul>';
        input.parentNode.appendChild(subcategoryDropdown); // Append within the container
    }

    const subcategoryList = subcategoryDropdown.querySelector('ul');
    subcategoryList.innerHTML = ''; // Clear previous items

    subcategories.forEach(subcategory => {
        const subcategoryItem = document.createElement('li');
        subcategoryItem.dataset.subcategoryName = subcategory.nomesubcategoria;
        subcategoryItem.dataset.subcategoryId = subcategory.id;
        subcategoryItem.textContent = subcategory.nomesubcategoria;

        subcategoryItem.addEventListener('click', async (event) => {
             event.stopPropagation(); // Prevent global close
            if (!currentPredictionInput) return; // Safety check

            const selectedSubcategoryName = subcategory.nomesubcategoria;
            const selectedSubcategoryId = subcategory.id;

            // Clear lower-level data
            currentPredictionInput.removeAttribute('data-cat3-id');
            currentPredictionInput.removeAttribute('data-cat3-indice');

            if (selectedSubcategoryId === 'go-back-category') {
                subcategoryDropdown.style.display = 'none';
                // Clear subcat data
                currentPredictionInput.removeAttribute('data-subcat-id');
                currentPredictionInput.removeAttribute('data-subcat-indice');
                // Re-show category dropdown
                const catD = document.getElementById(`categoryDropdown${predictionNumber}`);
                if(catD) catD.style.display = 'block';
                categoryDropdown = catD; // Update global ref
                return;
            }

            // Store subcategory ID and Index
            currentPredictionInput.dataset.subcatId = selectedSubcategoryId;
             if (subcategory.indiceIngles) {
                currentPredictionInput.dataset.subcatIndice = subcategory.indiceIngles;
            } else {
                 currentPredictionInput.removeAttribute('data-subcat-indice');
            }

            subcategoryDropdown.style.display = 'none'; // Hide subcategory dropdown

            const categoryId = currentPredictionInput.dataset.catId; // Get parent category ID
            if (!categoryId) {
                console.error("Parent category ID missing when fetching third level");
                return;
            }

            const thirdLevelCategories = await fetchThirdLevelCategories(categoryId, selectedSubcategoryId);

            if (thirdLevelCategories.length > 1) { // More than just "Go Back"
                displayThirdLevelDropdown(thirdLevelCategories, predictionNumber, parentCategoryName, selectedSubcategoryName);
            } else {
                // Stop at subcategory level
                currentPredictionInput.value = `${parentCategoryName} - ${selectedSubcategoryName}`; // Set value
                 // currentPredictionInput = null; // DEFERRED
                 categoryDropdown = null;
            }
        });
        subcategoryList.appendChild(subcategoryItem);
    });

    // Position and display
    positionDropdown(subcategoryDropdown, input);
    subcategoryDropdown.style.display = 'block';
}


// --- Function to Display Third Level Dropdown ---
function displayThirdLevelDropdown(thirdLevelCategories, predictionNumber, parentCategoryName, parentSubcategoryName) {
     const input = document.getElementById(`prediction${predictionNumber}`);
     if (!input || !currentGame) return; // Need currentGame for team names

    let thirdLevelDropdown = document.getElementById(`thirdLevelDropdown${predictionNumber}`);
    if (!thirdLevelDropdown) {
        thirdLevelDropdown = document.createElement('div');
        // Use distinct class if needed, or reuse subcategory style
        thirdLevelDropdown.className = 'category-dropdown third-category-dropdown';
        thirdLevelDropdown.id = `thirdLevelDropdown${predictionNumber}`;
        thirdLevelDropdown.innerHTML = '<ul></ul>';
        input.parentNode.appendChild(thirdLevelDropdown);
    }

    const thirdLevelList = thirdLevelDropdown.querySelector('ul');
    thirdLevelList.innerHTML = ''; // Clear previous items

    thirdLevelCategories.forEach(thirdLevelCategory => {
        const thirdLevelItem = document.createElement('li');
        thirdLevelItem.dataset.cat3Id = thirdLevelCategory.id;

        // Replace team placeholders
        let displayName = thirdLevelCategory.nome3categoria;
        if (displayName) { // Check if displayName is defined
             if (displayName.includes('Equipa A') && currentGame.equipaCasa) {
                 displayName = displayName.replace('Equipa A', currentGame.equipaCasa);
             }
             if (displayName.includes('Equipa B') && currentGame.equipaFora) {
                 displayName = displayName.replace('Equipa B', currentGame.equipaFora);
             }
        } else {
             displayName = "Opção Inválida"; // Fallback
             console.warn("Missing nome3categoria for ID:", thirdLevelCategory.id);
        }


        thirdLevelItem.textContent = displayName;

        thirdLevelItem.addEventListener('click', (event) => {
             event.stopPropagation(); // Prevent global close
             if (!currentPredictionInput) return;

            const selectedCat3Id = thirdLevelCategory.id;

             if (selectedCat3Id === 'go-back-subcategory') {
                thirdLevelDropdown.style.display = 'none';
                 // Clear cat3 data
                 currentPredictionInput.removeAttribute('data-cat3-id');
                 currentPredictionInput.removeAttribute('data-cat3-indice');
                 // Re-show subcategory dropdown
                 const subD = document.getElementById(`subcategoryDropdown${predictionNumber}`);
                 if(subD) subD.style.display = 'block';
                 return;
            }

            // Store 3rd level ID and Index
            currentPredictionInput.dataset.cat3Id = selectedCat3Id;
             if (thirdLevelCategory.indiceIngles) {
                currentPredictionInput.dataset.cat3Indice = thirdLevelCategory.indiceIngles;
            } else {
                currentPredictionInput.removeAttribute('data-cat3-indice');
            }


            // Set final input value with full path
            const finalValue = `${parentCategoryName} - ${parentSubcategoryName} - ${displayName}`;
            currentPredictionInput.value = finalValue;

            thirdLevelDropdown.style.display = 'none'; // Hide this dropdown

            // Reset tracking variables as selection is complete for this input
            // currentPredictionInput = null; // DEFERRED
            categoryDropdown = null;

        });
        thirdLevelList.appendChild(thirdLevelItem);
    });

    // Position and display
    positionDropdown(thirdLevelDropdown, input);
    thirdLevelDropdown.style.display = 'block';
}


// --- Utility functions for dropdowns ---
function positionDropdown(dropdownElement, inputElement) {
    if (!dropdownElement || !inputElement) return;
    // Basic positioning below the input
    dropdownElement.style.top = `${inputElement.offsetTop + inputElement.offsetHeight + 2}px`; // Add small gap
    dropdownElement.style.left = `${inputElement.offsetLeft}px`;
    dropdownElement.style.width = `${inputElement.offsetWidth}px`; // Match input width
}

function closeAllDropdowns(excludePredictionNumber = null) {
    const allDropdowns = document.querySelectorAll('.category-dropdown, .subcategory-dropdown, .third-category-dropdown');
    allDropdowns.forEach(dropdown => {
        // Extract number from dropdown ID if possible
        const match = dropdown.id.match(/\d+$/);
        const dropdownNumber = match ? parseInt(match[0], 10) : null;

        // Hide if it's not associated with the prediction number to exclude
        if (excludePredictionNumber === null || dropdownNumber !== excludePredictionNumber) {
             dropdown.style.display = 'none';
        }
    });
     // If we are closing dropdowns NOT related to the current input, reset the global refs
     if (excludePredictionNumber !== null && currentPredictionInput && currentPredictionInput.id !== `prediction${excludePredictionNumber}`) {
         // currentPredictionInput = null; // Don't reset if just switching between inputs
         categoryDropdown = null;
     } else if (excludePredictionNumber === null) { // Closing all unconditionally
         currentPredictionInput = null;
         categoryDropdown = null;
     }

}


// --- Global Click Listener to Close Dropdowns ---
document.addEventListener('click', function(event) {
    const clickedElement = event.target;

    // Check if the click is inside *any* prediction input or *any* visible dropdown
    const isInsideInput = clickedElement.closest('.prediction-input');
    const isInsideVisibleDropdown = clickedElement.closest('.category-dropdown[style*="display: block"], .subcategory-dropdown[style*="display: block"], .third-category-dropdown[style*="display: block"]');

    if (!isInsideInput && !isInsideVisibleDropdown) {
        // Clicked outside all relevant elements, close everything
        closeAllDropdowns(); // Pass null to close all
    }
});


// --- Authentication State Change Listener ---
onAuthStateChanged(auth, async (user) => {
    if (user) {
        console.log(`User ${user.uid} is logged in on palpite.html.`);
        currentUserStatus = await getUserStatus(user.uid);
        console.log(`User status: ${currentUserStatus}`);
        await loadGameDetails(); // Load game details after user is confirmed
        // Loading screen hidden inside loadGameDetails success/error
    } else {
        console.log('No user is logged in on palpite.html. Redirecting to index.');
        // Clear potential sensitive data if needed
        currentGame = null;
        clearInterval(countdownInterval);
        loadingScreen.style.display = 'none'; // Ensure loading is hidden
        window.location.href = 'index.html';
    }
});

// --- Cleanup on page unload ---
window.addEventListener('beforeunload', () => {
    clearInterval(countdownInterval);
});
    </script>
</body>
</html>

