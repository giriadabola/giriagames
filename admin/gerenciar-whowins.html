<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gerenciar WhoWins - G EMPIRE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    
    <script type="module" src="js/auth-guard.js"></script>

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { min-height: 100vh; background-color: #f0f0f0; font-family: Arial, sans-serif; }
        .top-menu { position: fixed; top: 0; left: 0; width: 100%; background-color: #ffffff; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); padding: 12px 0; display: flex; justify-content: center; gap: 24px; align-items: center; z-index: 1000; }
        .menu-item { text-decoration: none; color: #666; transition: color 0.3s ease; font-weight: 500; padding: 8px 16px; border-radius: 4px; font-size: 14px; line-height: 1.4; display: flex; align-items: center; gap: 8px; }
        .menu-item:hover, .menu-item.active { color: #2176ff; background-color: rgba(33, 118, 255, 0.1); }
        .content { max-width: 1200px; margin: 80px auto 20px; padding: 20px; }
        h1 { color: #1a1a1a; text-align: center; margin-bottom: 30px; }
        .filters-container { background-color: #ffffff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px; display: flex; gap: 20px; align-items: flex-end; }
        .filter-group { display: flex; flex-direction: column; }
        .filter-group label { font-weight: bold; color: #333; margin-bottom: 5px; }
        .filter-group select { padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; font-size: 16px; }
        #launch-results-btn { background-color: #28a745; color: white; border: none; padding: 10px 20px; border-radius: 4px; font-size: 16px; font-weight: bold; cursor: pointer; margin-left: auto; transition: background-color 0.2s; }
        #launch-results-btn:hover { background-color: #218838; }
        #launch-results-btn:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        #feedback-message { text-align: center; padding: 12px; margin-bottom: 15px; border-radius: 5px; font-weight: bold; display: none; transition: opacity 0.5s ease; }
        #feedback-message.success { background-color: #d4edda; color: #155724; }
        #feedback-message.error { background-color: #f8d7da; color: #721c24; }
        #feedback-message.info { background-color: #d1ecf1; color: #0c5460; }
        .game-list { list-style: none; padding: 0; display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px; }
        .game-item { background: linear-gradient(135deg, #4a4a4a 0%, #2c2c2c 100%); color: #ffffff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); padding: 15px; display: flex; flex-direction: column; align-items: center; text-align: center; font-family: 'Roboto Condensed', sans-serif; transition: transform 0.2s ease; }
        .teams-container { display: flex; align-items: center; justify-content: space-around; width: 100%; }
        .team-info, .versus { cursor: pointer; padding: 10px; border-radius: 12px; transition: all 0.3s ease; }
        .team-info { display: flex; flex-direction: column; align-items: center; flex: 1; }
        .versus { margin: 0 15px; font-weight: 700; display: flex; flex-direction: column; align-items: center; }
        .team-info:hover, .versus:hover { background: rgba(255, 255, 255, 0.1); }
        .team-info.selected, .versus.selected { background: #2176ff; transform: scale(1.05); }
        .game-date-time { font-size: 0.8em; opacity: 0.8; margin-top: 5px; }
        .team-logo { max-width: 50px; max-height: 50px; margin-bottom: 5px; }
        .no-result-btn { background-color: #6c757d; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-top: 15px; transition: background-color 0.2s; }
        .no-result-btn:hover { background-color: #5a6268; }
        .no-result-btn:disabled { background-color: #a0a0a0; cursor: not-allowed; }
        .placeholder { text-align: center; color: #666; padding: 40px; font-size: 1.2em; }
    </style>
</head>
<body style="display: none;">

    <nav class="top-menu">
        <a href="javascript:history.back()" class="menu-item"><i class="fas fa-arrow-left"></i></a>
        <a href="engrenagem.html" class="menu-item"><i class="fas fa-home"></i></a>
        <a href="criar-gplayer.html" class="menu-item"><i class="fas fa-user"></i>CRIAR GPLAYER</a>
        <a href="criar-jogo.html" class="menu-item"><i class="fas fa-gamepad"></i>CRIAR JOGO</a>
        <a href="criar-jogadores.html" class="menu-item"><i class="fas fa-users"></i>CRIAR JOGADORES</a>
        <a href="criar-clubes.html" class="menu-item"><i class="fas fa-shield-alt"></i>CRIAR CLUBES</a>
        <a href="criar-competicoes.html" class="menu-item"><i class="fas fa-trophy"></i>CRIAR COMPETIÇÕES</a>
        <a href="criar-pais.html" class="menu-item"><i class="fas fa-globe"></i>CRIAR PAIS</a>
        <a href="criar-mods.html" class="menu-item"><i class="fas fa-puzzle-piece"></i>CRIAR MODS</a>
        <a href="criar-odds.html" class="menu-item"><i class="fas fa-percentage"></i>CRIAR ODDS</a>
    </nav>
    
    <div class="content">
        <h1>Gerenciar Resultados WhoWins</h1>
        
        <div class="filters-container">
            <div class="filter-group">
                <label for="temporada-select">Temporada</label>
                <select id="temporada-select"><option>A carregar...</option></select>
            </div>
            <div class="filter-group">
                <label for="ronda-select">Ronda</label>
                <select id="ronda-select"><option>A carregar...</option></select>
            </div>
            <button id="launch-results-btn">Lançar Resultados</button>
        </div>
        
        <div id="feedback-message"></div>

        <div id="games-list-container">
            <ul class="game-list" id="games-list"></ul>
            <div class="placeholder" id="placeholder-message">
                Selecione uma temporada e ronda para ver os jogos.
            </div>
        </div>
    </div>

    <script type="module">
        import { db, auth } from './js/auth-guard.js';
        import { collection, query, getDocs, doc, getDoc, updateDoc, Timestamp, where, writeBatch, setDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
        import { onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

        document.addEventListener('DOMContentLoaded', () => {
            const temporadaSelect = document.getElementById('temporada-select');
            const rondaSelect = document.getElementById('ronda-select');
            const launchBtn = document.getElementById('launch-results-btn');
            const gamesList = document.getElementById('games-list');
            const placeholder = document.getElementById('placeholder-message');
            const feedbackMessage = document.getElementById('feedback-message');
            
            let currentAdminId = "ADMIN_USER_ID";
            onAuthStateChanged(auth, (user) => { if (user) currentAdminId = user.uid; });

            let allGamesData = [];
            let currentlyDisplayedGames = [];
            const clubCache = new Map();
            let feedbackTimeout;

            function showFeedback(message, type = 'success', duration = 5000) {
                clearTimeout(feedbackTimeout);
                feedbackMessage.textContent = message;
                feedbackMessage.className = type;
                feedbackMessage.style.display = 'block';
                feedbackTimeout = setTimeout(() => { feedbackMessage.style.display = 'none'; }, duration);
            }

            async function getClubData(clubId) {
                if (clubCache.has(clubId)) return clubCache.get(clubId);
                const clubRef = doc(db, 'clubes', clubId);
                const clubSnap = await getDoc(clubRef);
                const clubData = clubSnap.exists() ? clubSnap.data() : { imagem: '', nome: 'Clube Desconhecido' };
                clubCache.set(clubId, clubData);
                return clubData;
            }
            
            async function recalculateUserTotalsForSeason(userIds, season) {
                if (userIds.size === 0) return 0;

                try {
                    const movementsQuery = query(collection(db, 'movimentos'),
                        where("estado", "==", "WhoWins Paid"),
                        where("temporada", "==", season)
                    );
                    const movementsSnapshot = await getDocs(movementsQuery);

                    const userTotals = {};
                    userIds.forEach(id => { userTotals[id] = 0; });

                    movementsSnapshot.forEach(movDoc => {
                        const movimento = movDoc.data();
                        if (userTotals.hasOwnProperty(movimento.userId)) {
                            userTotals[movimento.userId] += movimento.valorreal || 0;
                        }
                    });

                    const userUpdateBatch = writeBatch(db);
                    for (const userId of userIds) {
                        const userRef = doc(db, 'users', userId);
                        userUpdateBatch.update(userRef, { whowinsgCoins: userTotals[userId] });
                    }

                    await userUpdateBatch.commit();
                    return userIds.size;

                } catch (error) {
                    console.error("Erro ao recalcular totais dos utilizadores:", error);
                    throw new Error("Falha ao atualizar saldos dos utilizadores.");
                }
            }

            async function initializeFilters() {
                placeholder.innerHTML = '<i class="fas fa-spinner fa-spin"></i> A carregar dados...';
                try {
                    const gamesQuery = query(collection(db, 'whowinsJogos'));
                    const snapshot = await getDocs(gamesQuery);
                    allGamesData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    if (allGamesData.length === 0) {
                        placeholder.textContent = 'Nenhum jogo "WhoWins" encontrado.';
                        temporadaSelect.innerHTML = '<option>N/A</option>';
                        rondaSelect.innerHTML = '<option>N/A</option>';
                        return;
                    }
                    const temporadas = [...new Set(allGamesData.map(g => g.temporada))].sort().reverse();
                    temporadaSelect.innerHTML = temporadas.map(t => `<option value="${t}">${t}</option>`).join('');
                    temporadaSelect.addEventListener('change', updateRondaOptions);
                    rondaSelect.addEventListener('change', displayFilteredGames);
                    launchBtn.addEventListener('click', handleLaunchResults);
                    updateRondaOptions();
                } catch (error) { console.error("Erro ao inicializar filtros:", error); placeholder.textContent = 'Erro ao carregar dados.'; }
            }

            function updateRondaOptions() {
                const selectedTemporada = temporadaSelect.value;
                const rondas = [...new Set(allGamesData.filter(g => g.temporada === selectedTemporada).map(g => g.ronda))].sort((a, b) => b - a);
                rondaSelect.innerHTML = rondas.map(r => `<option value="${r}">${r}</option>`).join('');
                displayFilteredGames();
            }

            async function displayFilteredGames() {
                currentlyDisplayedGames = allGamesData.filter(g => g.temporada === temporadaSelect.value && g.ronda === parseInt(rondaSelect.value, 10));
                gamesList.innerHTML = '';
                if (currentlyDisplayedGames.length === 0) { placeholder.style.display = 'block'; placeholder.textContent = 'Nenhum jogo encontrado para esta seleção.'; return; }
                placeholder.style.display = 'none';
                for (const game of currentlyDisplayedGames) {
                    const [homeTeamData, awayTeamData] = await Promise.all([ getClubData(game.equipaCasaId), getClubData(game.equipaForaId) ]);
                    let formattedDateTime = 'N/A';
                    if (game.dataJogo instanceof Timestamp) { const d = game.dataJogo.toDate(); formattedDateTime = `${String(d.getDate()).padStart(2,'0')}/${String(d.getMonth()+1).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}h${String(d.getMinutes()).padStart(2,'0')}`; }
                    const homeSelected = game.resultado === game.equipaCasaId ? 'selected' : '';
                    const drawSelected = game.resultado === 'draw' ? 'selected' : '';
                    const awaySelected = game.resultado === game.equipaForaId ? 'selected' : '';
                    const li = document.createElement('li');
                    li.className = 'game-item';
                    li.dataset.gameId = game.id;
                    li.innerHTML = `<div class="teams-container"><div class="team-info ${homeSelected}" data-result-id="${game.equipaCasaId}"><img src="${homeTeamData.imagem}" alt="${homeTeamData.nome}" class="team-logo"><span>${game.equipaCasa}</span></div><span class="versus ${drawSelected}" data-result-id="draw">EMPATE<div class="game-date-time">${formattedDateTime}</div></span><div class="team-info ${awaySelected}" data-result-id="${game.equipaForaId}"><img src="${awayTeamData.imagem}" alt="${awayTeamData.nome}" class="team-logo"><span>${game.equipaFora}</span></div></div><button class="no-result-btn">Sem Resultado</button>`;
                    gamesList.appendChild(li);
                }
                document.querySelectorAll('.game-item .team-info, .game-item .versus').forEach(el => el.addEventListener('click', handleResultClick));
                document.querySelectorAll('.game-item .no-result-btn').forEach(btn => btn.addEventListener('click', handleNoResultClick));
            }
            
            async function handleResultClick(event) {
                const clickedElement = event.currentTarget;
                const gameItem = clickedElement.closest('.game-item');
                const gameId = gameItem.dataset.gameId;
                const resultId = clickedElement.dataset.resultId;
                try {
                    const gameRef = doc(db, 'whowinsJogos', gameId);
                    await updateDoc(gameRef, { resultado: resultId });
                    gameItem.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                    clickedElement.classList.add('selected');
                    const gameIndex = allGamesData.findIndex(g => g.id === gameId);
                    if (gameIndex > -1) allGamesData[gameIndex].resultado = resultId;
                } catch (error) {
                    console.error("Erro ao definir resultado:", error);
                    showFeedback("Ocorreu um erro ao salvar o resultado.", 'error');
                }
            }
            
            async function handleNoResultClick(event) {
                const clickedButton = event.currentTarget;
                const gameItem = clickedButton.closest('.game-item');
                const gameId = gameItem.dataset.gameId;

                clickedButton.disabled = true;
                clickedButton.textContent = 'A limpar...';
                
                const affectedUserIds = new Set();
                const currentSeason = temporadaSelect.value;

                try {
                    const batch = writeBatch(db);
                    const gameRef = doc(db, 'whowinsJogos', gameId);
                    batch.update(gameRef, { resultado: null });
                    const predictionsQuery = query(collection(db, 'palpiteswhowins'), where("nomeJogo", "==", gameId));
                    const predictionsSnapshot = await getDocs(predictionsQuery);

                    predictionsSnapshot.forEach(predictionDoc => {
                        const userId = predictionDoc.data().userId;
                        affectedUserIds.add(userId);
                        batch.update(predictionDoc.ref, { resultado: null, acertou: null, valorreal: null });
                        const movimentoId = `whowins_${userId}_${gameId}`;
                        const movimentoRef = doc(db, 'movimentos', movimentoId);
                        batch.update(movimentoRef, { valorreal: 0, movimentoData: Timestamp.now() });
                    });

                    await batch.commit();
                    
                    const updatedUsersCount = await recalculateUserTotalsForSeason(affectedUserIds, currentSeason);

                    gameItem.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                    const gameIndex = allGamesData.findIndex(g => g.id === gameId);
                    if (gameIndex > -1) allGamesData[gameIndex].resultado = null;
                    
                    showFeedback(`Resultado e ${predictionsSnapshot.size} palpites limpos. ${updatedUsersCount} saldos de utilizadores recalculados.`, 'info');
                } catch (error) {
                    console.error("Erro ao remover resultado:", error);
                    showFeedback(error.message || "Ocorreu um erro ao remover o resultado.", 'error');
                } finally {
                    clickedButton.disabled = false;
                    clickedButton.textContent = 'Sem Resultado';
                }
            }

            async function handleLaunchResults() {
                launchBtn.disabled = true;
                launchBtn.textContent = 'A processar...';
                
                const affectedUserIds = new Set();
                const currentSeason = temporadaSelect.value;
                let arenaPrizesCache = null;

                try {
                    if (!arenaPrizesCache) {
                        const arenaDocRef = doc(db, 'paineis', 'paineis arena');
                        const arenaDocSnap = await getDoc(arenaDocRef);
                        arenaPrizesCache = arenaDocSnap.exists() ? arenaDocSnap.data() : {};
                    }
                    const batch = writeBatch(db);
                    let processedPredictionsCount = 0;

                    for (const game of currentlyDisplayedGames) {
                        if (!game.resultado) continue;
                        
                        const gameResult = game.resultado;
                        const prizeValue = arenaPrizesCache[game.arena]?.ganhos || 0;
                        const predictionsQuery = query(collection(db, 'palpiteswhowins'), where("nomeJogo", "==", game.id));
                        const predictionsSnapshot = await getDocs(predictionsQuery);

                        predictionsSnapshot.forEach(predictionDoc => {
                            const predictionData = predictionDoc.data();
                            affectedUserIds.add(predictionData.userId);
                            
                            const userGuessedCorrectly = (predictionData.winsId === gameResult);
                            const finalPrize = userGuessedCorrectly ? prizeValue : 0;
                            
                            batch.update(predictionDoc.ref, { resultado: gameResult, acertou: userGuessedCorrectly ? "sim" : "nao", valorreal: finalPrize });
                            
                            const movimentoId = `whowins_${predictionData.userId}_${game.id}`;
                            const movimentoRef = doc(db, 'movimentos', movimentoId);
                            batch.set(movimentoRef, { de: currentAdminId, estado: "WhoWins Paid", movimentoData: Timestamp.now(), nomeJogo: game.nomeJogo, para: predictionData.userId, temporada: game.temporada, userId: predictionData.userId, valorreal: finalPrize }, { merge: true });
                            
                            processedPredictionsCount++;
                        });
                    }
                    
                    await batch.commit();
                    
                    const updatedUsersCount = await recalculateUserTotalsForSeason(affectedUserIds, currentSeason);
                    
                    showFeedback(`Resultados lançados! ${processedPredictionsCount} palpites atualizados e ${updatedUsersCount} saldos de utilizadores recalculados.`, 'success');
                } catch (error) {
                    console.error("Erro ao lançar resultados:", error);
                    showFeedback(error.message || 'Ocorreu um erro ao processar os resultados.', 'error');
                } finally {
                    launchBtn.disabled = false;
                    launchBtn.textContent = 'Lançar Resultados';
                }
            }

            initializeFilters();
        });
    </script>
</body>
</html>
