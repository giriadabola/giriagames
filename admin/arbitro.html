<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√Årbitro - G EMPIRE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .top-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 12px 0;
            display: flex;
            justify-content: center;
            gap: 24px;
            align-items: center;
            z-index: 1000; /* Existing z-index */
        }

        .menu-item {
            text-decoration: none;
            color: #666;
            transition: color 0.3s ease;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        .menu-item:hover, .menu-item.active {
            color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }

        .menu-item i {
            font-size: 16px;
        }

        .content {
            padding: 80px 20px 20px; /* Adjusted top padding accounts for menu */
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }

        .predictions-list {
            display: grid;
            gap: 20px;
            margin-top: 20px;
        }

        .prediction-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .prediction-teams {
            font-weight: bold;
            color: #333;
        }

        .prediction-date {
            color: #666;
            font-size: 0.9em;
        }

        .prediction-values {
            display: grid;
            gap: 10px;
            margin-top: 10px;
        }

        .prediction-value {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .prediction-points {
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 7px;
        }

        .points-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            text-align: center;
            margin-right: 8px;
        }

        .points-input:focus {
            border-color: #28a745;
            outline: none;
        }

        .status-select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .status-select option {
            padding: 4px 8px;
        }

        .status-select.neutro {
            color: #666;
            border-color: #ddd;
        }

        .status-select.acerto {
            color: #28a745;
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }

        .status-select.falha {
            color: #dc3545;
            border-color: #dc3545;
            background-color: rgba(220, 53, 69, 0.1);
        }

        .prediction-label {
            color: #666;
        }

        .prediction-number {
            font-weight: bold;
        }

        .prediction-number.neutro {
            color: #333;
            }

        .prediction-number.acerto {
            color: #28a745;
        }

        .prediction-number.falha {
            color: #dc3545;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        /* Filters for the main page content */
        .filter-container {
            display: flex;
            justify-content: center; /* Centered for main filters */
            gap: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .round-filter, .gplayer-filter { /* Shared styles for main filters */
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
            color: #333;
            background-color: white;
            cursor: pointer;
            outline: none;
        }

        .round-filter:hover, .gplayer-filter:hover {
            border-color: #28a745;
        }

        .launch-button {
            padding: 8px 16px;
            border: 1px solid #28a745;
            border-radius: 4px;
            font-size: 1em;
            color: white;
            background-color: #28a745;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .launch-button:hover {
            background-color: #218838;
            border-color: #1e7e34;
        }

        #launch-status-icons {
            margin-left: 8px; /* Adjust spacing as needed */
            display: inline-flex; /* Align icons nicely with the button */
            align-items: center;
        }

        #launch-status-icons i {
            margin-right: 4px; /* Spacing between icons if needed */
        }

        .loading-icon {
            display: none; /* Initially hidden */
            color: #007bff; /* Example loading icon color */
            animation: spin 1s linear infinite; /* Optional spinning animation */
        }

        .success-icon {
            display: none; /* Initially hidden */
            color: #28a745; /* Success icon color (green) */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- CSS FOR GEAR ICON AND POPUP --- */
        #settings-icon-container {
            position: fixed;
            top: 85px;
            right: 25px;
            z-index: 999;
            cursor: pointer;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        #settings-icon-container i {
            font-size: 22px;
            color: #555;
            display: block;
            transition: color 0.3s ease;
        }

        #settings-icon-container:hover i {
            color: #28a745;
        }
         #settings-icon-container:hover {
            background-color: rgba(255, 255, 255, 0.8);
        }


        #settings-popup {
            display: none;
            position: absolute; /* Changed from fixed for proper dragging */
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%); /* Initial centering */
            width: 90%;
            max-width: 600px;
            min-height: 200px;
            max-height: 80vh;
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            overflow-y: auto;
            cursor: grab; /* Cursor for dragging */
            /* Removed resize: both; as absolute positioning makes it complex */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #settings-popup:active {
            cursor: grabbing; /* Cursor while dragging */
        }

        #settings-popup h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
            font-size: 1.2em;
        }

        #popup-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
            transition: color 0.3s ease;
            z-index: 1002;
        }

        #popup-close:hover {
            color: #333;
        }

        #popup-close-scrollable {
            position: fixed;
            bottom: 20px;
            right: 35px;
            font-size: 24px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
            transition: color 0.3s ease;
            z-index: 1002;
            background-color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            text-align: center;
            padding: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #popup-close-scrollable:hover {
            color: #333;
        }

        #popup-close, #popup-close-scrollable {
            cursor: pointer;
        }

        /* --- CSS FOR THE CONVERTER INSIDE THE POPUP --- */
        #settings-popup table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
        }
        #settings-popup th, #settings-popup td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        #settings-popup th {
            background-color: #f2f2f2;
            text-align: center;
        }
        #settings-popup td:nth-child(2),
        #settings-popup td:nth-child(3) {
            text-align: right;
        }

        #settings-popup #inputTextArea {
            width: 100%;
            box-sizing: border-box;
            max-height: 150px;
            margin-bottom: 15px; /* Added margin below textarea */
        }

        /* --- NEW CONTAINER FOR BUTTON AND FILTER --- */
        #settings-popup .popup-controls-container {
            display: flex;              /* Use Flexbox */
            justify-content: space-between; /* Space out button and filter */
            align-items: center;        /* Vertically align them */
            margin-bottom: 20px;        /* Space below this line */
            gap: 15px;                  /* Space between button and filter */
        }

        /* --- Style the button within the container --- */
        #settings-popup .popup-controls-container button {
             padding: 8px 16px;
             border: 1px solid #28a745;
             border-radius: 4px;
             font-size: 1em; /* Match filter font size if desired */
             color: white;
             background-color: #28a745;
             cursor: pointer;
             outline: none;
             transition: all 0.3s ease;
             /* Removed margin-bottom */
        }
        #settings-popup .popup-controls-container button:hover {
             background-color: #218838;
             border-color: #1e7e34;
        }

        /* --- Style the filter container within the new parent --- */
        #settings-popup .converter-filter-container {
            display: flex;
            align-items: center; /* Vertically align label and select */
            /* justify-content: flex-end; /* Kept original alignment within its space */
            /* Removed margin-bottom */
        }

        #settings-popup .converter-filter-container label {
            margin-right: 5px; /* Space between label and dropdown */
            font-size: 0.9em;
            color: #333;
        }

        #settings-popup #categoryFilter {
            width: auto; /* Adjust width automatically */
            max-width: 100%;
            box-sizing: border-box;
            padding: 8px 12px; /* Slightly adjusted padding for consistency */
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em; /* Adjusted font size slightly */
            background-color: white;
            cursor: pointer;
            outline: none;
        }
        #settings-popup #categoryFilter:hover {
             border-color: #28a745;
        }
        /* --- END OF CONVERTER CSS --- */

        /* --- Search Bar Styling (can keep as is or refine) --- */
        #settings-popup .search-container {
            margin-bottom: 15px;
        }
        #settings-popup #searchSubcategoryInput {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em; /* Match filter font size */
        }
        #settings-popup #searchSubcategoryInput:focus {
            border-color: #28a745;
            outline: none;
        }


    </style>
</head>
<body>
    <nav class="top-menu">
        <a href="engrenagem.html" class="menu-item"><i class="fas fa-home"></i></a>
        <a href="criar-gplayer.html" class="menu-item"><i class="fas fa-plus"></i> CRIAR</a>
        <a href="editar-gplayer.html" class="menu-item"><i class="fas fa-edit"></i> EDITAR</a>
        <a href="gerenciar-jogadores.html" class="menu-item"><i class="fas fa-users"></i> JOGADORES LIVE</a>
    </nav>

    <!-- Gear Icon -->
    <div id="settings-icon-container" title="Configura√ß√µes">
        <i class="fas fa-cog"></i>
    </div>

    <!-- Popup (Initially Hidden) -->
    <div id="settings-popup">
        <span id="popup-close" title="Fechar">√ó</span>
        <span id="popup-close-scrollable" title="Fechar"><i class="fas fa-times"></i></span>

        <!-- == CONVERTER HTML START == -->
        <h2>Colar Bets</h2>

        <textarea id="inputTextArea" rows="10" cols="60" placeholder="Cole aqui o texto das bets (Nome subcategoria seguido das linhas de Op√ß√£o e Odd)" onpaste="handlePaste(event)"></textarea>
        <!-- Removed <br><br> -->

        <!-- New container for button and filter -->
        <div class="popup-controls-container">
            <button onclick="window.convertToTable()">Criar Tabela</button>

            <div class="converter-filter-container">
              <select id="categoryFilter" onchange="window.filterTables()">
                 <option value="all">Todas as Categorias</option>
                 <option value="Resultado Final">1. Resultado Final</option>
                 <option value="Golos">2. Golos</option>
                 <option value="Handicap">3. Handicap</option>
                 <option value="Intervalo/Fim do Jogo (HT/FT)">4. Intervalo/Fim do Jogo (HT/FT)</option>
                 <option value="Resultado Exato (Placar)">5. Resultado Exato (Placar)</option>
                 <option value="Espec√≠ficos por Equipa">6. Espec√≠ficos por Equipa</option>
                 <option value="Mercados Combinados">7. Mercados Combinados</option>
                 <option value="Tempo (Timing)">8. Tempo (Timing)</option>
                 <option value="Por Parte (1¬™ Parte / 2¬™ Parte)">9. Por Parte (1¬™ Parte / 2¬™ Parte)</option>
                 <option value="Mercados Especiais / Eventos">10. Mercados Especiais / Eventos</option>
                 <option value="Cantos">11. Cantos</option>
                 <option value="Cart√µes Amarelos">12. Cart√µes Amarelos</option>
                 <option value="Remates √† Baliza">13. Remates √† Baliza</option>
                 <option value="Faltas">14. Faltas</option>
                 <option value="Remates Totais">15. Remates Totais</option>
                 <option value="16. Jogadores (Totais)">16. Jogadores (Totais)</option>
              </select>
            </div>
        </div> <!-- End of controls container -->

        <!-- ===== SEARCH BAR FOR SUBCATEGORY TITLES ===== -->
        <div class="search-container">
             <input type="text" id="searchSubcategoryInput" placeholder="Pesquisar T√≠tulo da Subcategoria..." >
        </div>
        <!-- ===== END SEARCH BAR ===== -->

        <div id="outputTables"></div>
        <!-- == CONVERTER HTML END == -->

    </div>

    <!-- Main Content Area -->
    <div class="content">
        <h1>√Årbitro</h1>
        <div class="filter-container"> <!-- Filters for the main √Årbitro content -->
            <select id="round-filter" class="round-filter">
                <option value="">Todas as Rondas</option>
            </select>
            <select id="game-filter" class="round-filter">
                <option value="">Todos os Jogos</option>
            </select>
            <select id="gplayer-filter" class="gplayer-filter">
                <option value="">Todos os GPlayers</option>
            </select>
            <button id="launch-button" class="launch-button">Lan√ßar</button><span id="launch-status-icons"></span>
        </div>
        <div id="predictions-container" class="predictions-list">
            <div class="loading">Carregando palpites...</div>
        </div>
    </div>

    <!-- Scripts for Popup Interaction and Dragging -->
    <script>
        // Handle paste event for textarea
        function handlePaste(event) {
            setTimeout(() => {
                const textarea = event.target;
                textarea.value = textarea.value.trimRight() + '/////////////////////////////////////////////////////////////////////////////////////////////////////////\n';
            }, 0);
        }

        // Popup toggle and close functionality
        const popup = document.getElementById('settings-popup');
        const settingsIcon = document.getElementById('settings-icon-container');
        const closeButtonTopRight = document.getElementById('popup-close');
        const closeButtonScrollable = document.getElementById('popup-close-scrollable');

        const togglePopup = () => {
             if (popup.style.display === 'none' || !popup.style.display) {
                popup.style.display = 'block';
                // Reset position on open for consistency (optional)
                popup.style.left = '50%';
                popup.style.top = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                // --- Trigger fade-in ---
                setTimeout(() => {
                    popup.style.opacity = '1';
                    popup.style.visibility = 'visible';
                }, 10); // Small delay ensures transition applies
            } else {
                 // --- Trigger fade-out ---
                popup.style.opacity = '0';
                popup.style.visibility = 'hidden';
                // Wait for transition to finish before hiding
                setTimeout(() => {
                    popup.style.display = 'none';
                }, 300); // Match transition duration
            }
        };

        const closePopup = () => {
            popup.style.opacity = '0';
            popup.style.visibility = 'hidden';
            setTimeout(() => {
                popup.style.display = 'none';
            }, 300);
        };

        if (settingsIcon && popup && closeButtonTopRight && closeButtonScrollable) {
             settingsIcon.addEventListener('click', togglePopup);
             closeButtonTopRight.addEventListener('click', closePopup);
             closeButtonScrollable.addEventListener('click', closePopup);
        }


       // --- DRAGGABLE POPUP FUNCTIONALITY ---
        let isDragging = false;
        let offsetX = 0; // Use offset relative to top-left of the element
        let offsetY = 0;
        let initialPopupX = 0; // Store initial position for calculation
        let initialPopupY = 0;


        if (popup) {
            popup.addEventListener('mousedown', (e) => {
                // Only start dragging if the mousedown is on the popup header/background
                // Exclude interactive elements like textarea, select, button, close icons
                 if (e.target === popup || e.target.tagName === 'H2') {
                    isDragging = true;
                    // Record the initial position of the popup *itself*
                    const rect = popup.getBoundingClientRect();
                    initialPopupX = rect.left;
                    initialPopupY = rect.top;
                    // Record the mouse click position relative to the viewport
                    offsetX = e.clientX;
                    offsetY = e.clientY;

                    popup.style.cursor = 'grabbing';
                    popup.style.userSelect = 'none'; // Prevent text selection during drag
                    // Remove transform temporarily while dragging with top/left for smoother movement
                    popup.style.transform = 'none';
                 }
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                // Calculate the *change* in mouse position
                const dx = e.clientX - offsetX;
                const dy = e.clientY - offsetY;

                // Calculate the new top/left based on initial popup position + change
                let newX = initialPopupX + dx;
                let newY = initialPopupY + dy;

                // Boundary checks (optional but recommended)
                const popupWidth = popup.offsetWidth;
                const popupHeight = popup.offsetHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;

                // Keep popup within viewport horizontal bounds
                newX = Math.max(0, Math.min(newX, windowWidth - popupWidth));
                 // Keep popup within viewport vertical bounds
                newY = Math.max(0, Math.min(newY, windowHeight - popupHeight));

                // Apply the new position
                popup.style.left = newX + 'px';
                popup.style.top = newY + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    popup.style.cursor = 'grab';
                    popup.style.userSelect = ''; // Re-enable text selection
                }
            });
        }
       // --- END OF DRAGGABLE POPUP FUNCTIONALITY ---

    </script>

    <!-- Firebase and Main Page Logic (Keep existing script block as is) -->
    <script type="module">
        // --- EXISTING FIREBASE JAVASCRIPT MODULE ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, getDocs, doc, getDoc, updateDoc, where, addDoc, serverTimestamp, getCountFromServer, query, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

         const firebaseConfig = {
             apiKey: "YOUR_API_KEY", // IMPORTANT: Replace with your actual API Key or use secure method
             authDomain: "g-games-8a8fc.firebaseapp.com",
             projectId: "g-games-8a8fc",
             storageBucket: "g-games-8a8fc.appspot.com", // Corrected storage bucket domain
             messagingSenderId: "689897349449",
             appId: "1:689897349449:web:536599794579901beb7a98",
             measurementId: "G-GTTPJ6G5MD"
         };

         // Initialize Firebase
         const app = initializeApp(firebaseConfig);
         const db = getFirestore(app);

         // Initialize state variables for main page
         let currentRound = null;
         let currentGame = null;
         let currentGPlayer = null;
         let allPredictions = [];
         let isProcessingLaunch = false; // Flag to track processing state

         // --- Functions for the main √Årbitro page (loadPredictions, event listeners, launch logic) ---
         async function loadPredictions() {
             try {
                 const predictionsContainer = document.getElementById('predictions-container');
                 const roundFilter = document.getElementById('round-filter');
                 const palpitesSnapshot = await getDocs(collection(db, 'palpites'));

                 // Store all predictions
                 allPredictions = [];
                 const rounds = new Set();
                 const gplayers = new Set();

                 if (palpitesSnapshot.empty) {
                     predictionsContainer.innerHTML = '<div class="prediction-card">Nenhum palpite encontrado.</div>';
                     return;
                 }

                 // Collect all predictions and rounds
                 for (const palpiteDoc of palpitesSnapshot.docs) {
                     const palpite = palpiteDoc.data();
                     if (palpite.ronda) {
                         rounds.add(palpite.ronda);
                     }
                     if (palpite.nomeDeUsuario) {
                         gplayers.add(palpite.nomeDeUsuario);
                     }
                     allPredictions.push({
                         id: palpiteDoc.id,
                         ...palpite
                     });
                 }

                 // Update round filter options
                 const sortedRounds = Array.from(rounds).sort((a, b) => b - a); // Sort in descending order
                 roundFilter.innerHTML = '<option value="">Todas as Rondas</option>';
                 sortedRounds.forEach(round => {
                     roundFilter.innerHTML += `<option value="${round}">Ronda ${round}</option>`;
                 });

                 // Update game filter based on selected round
                 function updateGameFilter() {
                     const gameFilter = document.getElementById('game-filter');
                     const filteredByRound = currentRound ? allPredictions.filter(p => p.ronda === currentRound) : allPredictions;
                     const games = new Set(filteredByRound.map(p => p.nomeJogo).filter(Boolean));
                     const sortedGames = Array.from(games).sort();

                     gameFilter.innerHTML = '<option value="">Todos os Jogos</option>';
                     sortedGames.forEach(game => {
                         // Extract only team names from the game string by removing date and round info
                         const teamNamesMatch = game.match(/^([^-]+ vs [^-]+)/); // Match "TeamA vs TeamB" at the start
                         const displayGameName = teamNamesMatch ? teamNamesMatch[1].trim() : game; // Fallback to full name if no match

                         gameFilter.innerHTML += `<option value="${game}">${displayGameName}</option>`;
                     });
                     gameFilter.value = currentGame || '';
                 }

                 // Event listener for round filter
                 document.getElementById('round-filter').addEventListener('change', (e) => {
                     currentRound = e.target.value === "" ? null : Number(e.target.value);
                     currentGame = null; // Reset game selection when round changes
                     updateGameFilter();
                     loadPredictions(); // Reload predictions based on new round
                 });

                 // Event listener for game filter
                 document.getElementById('game-filter').addEventListener('change', (e) => {
                     currentGame = e.target.value || null;
                     loadPredictions(); // Reload predictions based on new game
                 });

                 // Event listener for gplayer filter
                 document.getElementById('gplayer-filter').addEventListener('change', (e) => {
                     currentGPlayer = e.target.value || null;
                     loadPredictions(); // Reload predictions based on new gplayer
                 });


                 // Set default round to highest when page loads for the first time
                 if (sortedRounds.length > 0 && currentRound === null) {
                     currentRound = sortedRounds[0];
                     roundFilter.value = currentRound;
                 } else {
                     // Maintain the selected round in the dropdown
                     roundFilter.value = currentRound || '';
                 }

                 updateGameFilter(); // Initial call to populate game filter based on default/selected round

                 // Update GPlayer filter options
                 const gplayerFilter = document.getElementById('gplayer-filter');
                 const sortedGPlayers = Array.from(gplayers).sort();
                 gplayerFilter.innerHTML = '<option value="">Todos os GPlayers</option>';
                 sortedGPlayers.forEach(gplayer => {
                     if (gplayer) { // Only add non-empty GPlayer names
                         gplayerFilter.innerHTML += `<option value="${gplayer}">${gplayer}</option>`;
                     }
                 });
                 gplayerFilter.value = currentGPlayer || ''; // Maintain selection

                 // Filter predictions by selected round, game, and GPlayer
                 let filteredPredictions = allPredictions;

                 if (currentRound) {
                     filteredPredictions = filteredPredictions.filter(p => p.ronda === currentRound);
                 }

                 if (currentGame) {
                     filteredPredictions = filteredPredictions.filter(p => p.nomeJogo === currentGame);
                 }

                 if (currentGPlayer) {
                     filteredPredictions = filteredPredictions.filter(p => p.nomeDeUsuario === currentGPlayer);
                 }

                 // --- Render Predictions ---
                 let predictionsHTML = '';
                 predictionsContainer.innerHTML = '<div class="loading">Carregando palpites...</div>'; // Show loading initially

                 if (filteredPredictions.length === 0) {
                     predictionsContainer.innerHTML = '<div class="prediction-card">Nenhum palpite encontrado para os filtros selecionados.</div>';
                     return;
                 }

                 // Fetch necessary related data efficiently (Example using Promise.all for teams/users if IDs are known)
                 const uniqueJogoIds = [...new Set(filteredPredictions.map(p => p.jogoId).filter(Boolean))];
                 const uniqueUserIds = [...new Set(filteredPredictions.map(p => p.userId).filter(Boolean))];
                 const jogoPromises = uniqueJogoIds.map(id => getDoc(doc(db, 'jogos', id)));
                 const userPromises = uniqueUserIds.map(id => getDoc(doc(db, 'users', id)));

                 const [jogoDocs, userDocs] = await Promise.all([
                     Promise.all(jogoPromises),
                     Promise.all(userPromises)
                 ]);

                 const jogosData = jogoDocs.reduce((acc, docSnap) => {
                     if (docSnap.exists()) acc[docSnap.id] = docSnap.data();
                     return acc;
                 }, {});
                 const usersData = userDocs.reduce((acc, docSnap) => {
                     if (docSnap.exists()) acc[docSnap.id] = docSnap.data();
                     return acc;
                 }, {});

                 // Fetch unique Club IDs from valid jogosData
                 const uniqueClubIds = new Set();
                 Object.values(jogosData).forEach(jogo => {
                     if (jogo && jogo.equipaCasaId) uniqueClubIds.add(jogo.equipaCasaId);
                     if (jogo && jogo.equipaForaId) uniqueClubIds.add(jogo.equipaForaId);
                 });

                 const clubPromises = Array.from(uniqueClubIds).map(id => getDoc(doc(db, 'clubes', id)));
                 const clubDocs = await Promise.all(clubPromises);
                 const clubsData = clubDocs.reduce((acc, docSnap) => {
                     if (docSnap.exists()) acc[docSnap.id] = docSnap.data();
                     return acc;
                 }, {});
                 // --- End Data Fetching Optimization ---


                 for (const palpite of filteredPredictions) {
                     try {
                         if (!palpite.jogoId) {
                             console.warn('Palpite sem jogoId encontrado:', palpite.id);
                             continue;
                         }

                         const jogo = jogosData[palpite.jogoId];
                         if (!jogo) {
                             console.warn(`Dados do Jogo com ID ${palpite.jogoId} n√£o encontrados ou carregados.`);
                             continue;
                         }
                         if (!jogo.equipaCasaId || !jogo.equipaForaId) {
                             console.warn(`Jogo com ID ${palpite.jogoId} tem IDs de equipa em falta:`, jogo);
                             continue;
                         }

                         const equipaCasaData = clubsData[jogo.equipaCasaId];
                         const equipaForaData = clubsData[jogo.equipaForaId];
                         const equipaCasa = equipaCasaData?.nome || 'Equipa Casa?';
                         const equipaFora = equipaForaData?.nome || 'Equipa Fora?';


                         let dataFormatada = 'Data?';
                         try {
                             if (jogo.dataJogo && typeof jogo.dataJogo.toDate === 'function') {
                                 const dataJogo = jogo.dataJogo.toDate();
                                 dataFormatada = dataJogo.toLocaleDateString('pt-PT');
                             }
                         } catch (error) {
                             console.warn('Erro ao formatar data do jogo:', jogo.jogoId, error);
                         }

                         const userData = palpite.userId ? usersData[palpite.userId] : null;
                         const userName = userData?.nomeDeUsuario || palpite.nomeDeUsuario || 'GPlayer?'; // Fallback to palpite data

                         let palpitesHTML = '';
                         const numeroPalpites = typeof jogo.numeroPalpites === 'number' ? jogo.numeroPalpites : 0;

                         for (let i = 1; i <= numeroPalpites; i++) {
                             const palpiteKey = `palpite${i}`;
                             const pontosKey = `Palpite${i}PontosQuanto`;
                             const statusKey = `palpite${i}Status`;

                             // Check if palpiteKey exists before rendering
                            if (palpite.hasOwnProperty(palpiteKey)) {
                                 const status = palpite[statusKey] || 'neutro';
                                 palpitesHTML += `
                                     <div class="prediction-value">
                                         <div class="prediction-points">
                                             <span class="prediction-label">Palpite ${i}</span>
                                             <span class="prediction-number ${status}">${palpite[palpiteKey]}</span>
                                         </div>
                                         <input type="number"
                                             class="points-input"
                                             min="0"
                                             max="999"
                                             value="${palpite[pontosKey] || ''}"
                                             data-palpite-id="${palpite.id}"
                                             data-pontos-key="${pontosKey}"
                                             placeholder="Pts">
                                         <select class="status-select ${status}"
                                             data-palpite-id="${palpite.id}"
                                             data-status-key="${statusKey}">
                                             <option value="neutro" ${status === 'neutro' ? 'selected' : ''}>Neutro</option>
                                             <option value="acerto" ${status === 'acerto' ? 'selected' : ''}>Acerto</option>
                                             <option value="falha" ${status === 'falha' ? 'selected' : ''}>Falha</option>
                                         </select>
                                     </div>`;
                            } else {
                                // Optionally log or handle missing palpite keys if needed
                                // console.log(`Palpite ${i} missing for ID ${palpite.id}`);
                            }
                         }

                         predictionsHTML += `
                             <div class="prediction-card" data-prediction-id="${palpite.id}">
                                 <div class="prediction-header">
                                     <div class="prediction-teams">${equipaCasa} vs ${equipaFora}</div>
                                     <div class="prediction-date">${dataFormatada} - ${userName}</div>
                                 </div>
                                 <div class="prediction-values">
                                     ${palpitesHTML}
                                 </div>
                             </div>`;
                     } catch (error) {
                         console.error('Erro ao processar o palpite com ID:', palpite?.id, error);
                         // Optionally add placeholder HTML for the errored card
                     }
                 } // End loop through filtered predictions

                 predictionsContainer.innerHTML = predictionsHTML; // Render the final HTML

                 // --- Add event listeners AFTER rendering ---
                 document.querySelectorAll('.status-select').forEach(select => {
                     select.addEventListener('change', async (e) => {
                         const palpiteId = e.target.dataset.palpiteId;
                         const statusKey = e.target.dataset.statusKey;
                         const newStatus = e.target.value;

                         if (!palpiteId || !statusKey) {
                             console.error("Missing data attributes on status select:", e.target);
                             return;
                         }

                         try {
                             const palpiteRef = doc(db, 'palpites', palpiteId);
                             await updateDoc(palpiteRef, { [statusKey]: newStatus });

                             // Update select and text appearance
                             e.target.className = `status-select ${newStatus}`;
                             const predictionNumberSpan = e.target.closest('.prediction-value')?.querySelector('.prediction-number');
                             if (predictionNumberSpan) {
                                 predictionNumberSpan.className = `prediction-number ${newStatus}`;
                             }
                             // Update local data store if needed (for immediate UI consistency without full reload)
                             const localPrediction = allPredictions.find(p => p.id === palpiteId);
                             if(localPrediction) localPrediction[statusKey] = newStatus;


                         } catch (error) {
                             console.error('Error updating status:', error);
                             alert('Erro ao atualizar o status.');
                             // Optionally revert UI
                             // e.target.value = localPrediction ? localPrediction[statusKey] : 'neutro'; // Revert dropdown
                             // e.target.className = `status-select ${e.target.value}`; // Revert class
                             // ... revert text class ...
                         }
                     });
                 });

                 document.querySelectorAll('.points-input').forEach(input => {
                     input.addEventListener('change', async (e) => {
                         const palpiteId = e.target.dataset.palpiteId;
                         const pontosKey = e.target.dataset.pontosKey;
                         const value = e.target.value;

                         if (!palpiteId || !pontosKey) {
                            console.error("Missing data attributes on points input:", e.target);
                            return;
                         }

                         const pointsValue = value ? parseInt(value) : 0; // Store as number, 0 if empty

                         if (value && (pointsValue < 0 || pointsValue > 999)) {
                             alert('Por favor, insira um n√∫mero entre 0 e 999.');
                             // Revert to previous value (fetch from local store or re-fetch doc)
                             const localPrediction = allPredictions.find(p => p.id === palpiteId);
                             e.target.value = localPrediction ? (localPrediction[pontosKey] || '') : '';
                             return;
                         }

                         try {
                             const palpiteRef = doc(db, 'palpites', palpiteId);
                             await updateDoc(palpiteRef, { [pontosKey]: pointsValue });

                             // Update local data store
                             const localPrediction = allPredictions.find(p => p.id === palpiteId);
                             if(localPrediction) localPrediction[pontosKey] = pointsValue;

                         } catch (error) {
                             console.error('Error updating points:', error);
                             alert('Erro ao atualizar os pontos.');
                             // Revert UI
                             const localPrediction = allPredictions.find(p => p.id === palpiteId);
                             e.target.value = localPrediction ? (localPrediction[pontosKey] || '') : '';
                         }
                     });
                 });


             } catch (error) {
                 console.error('Error loading predictions:', error);
                 document.getElementById('predictions-container').innerHTML =
                     '<div class="prediction-card">Erro ao carregar palpites. Tente atualizar a p√°gina.</div>';
             }
         }

         // --- Launch Button Logic ---
          document.getElementById('launch-button').addEventListener('click', async () => {
            // Disable button, show spinner etc. (as before)
            const launchButton = document.getElementById('launch-button');
            const statusIconsSpan = document.getElementById('launch-status-icons');
            statusIconsSpan.innerHTML = '<i class="fas fa-spinner fa-spin loading-icon" style="display: inline-block; color: #007bff;"></i>'; // Show spinner
            launchButton.disabled = true;
            isProcessingLaunch = true;

             try {
                 // Filter predictions based on CURRENT UI filters (Round, Game, GPlayer)
                 let predictionsToProcess = allPredictions;
                 if (currentRound) {
                     predictionsToProcess = predictionsToProcess.filter(p => p.ronda === currentRound);
                 }
                 if (currentGame) {
                     predictionsToProcess = predictionsToProcess.filter(p => p.nomeJogo === currentGame);
                 }
                 if (currentGPlayer) {
                     predictionsToProcess = predictionsToProcess.filter(p => p.nomeDeUsuario === currentGPlayer);
                 }

                 if (predictionsToProcess.length === 0) {
                    alert("N√£o h√° palpites vis√≠veis para lan√ßar com os filtros atuais.");
                    throw new Error("No predictions to process based on filters."); // Abort early
                 }

                 console.log(`Processing ${predictionsToProcess.length} predictions...`);

                 const userAggregatedData = {};
                 const currentAdminUserId = 'ADMIN_USER_ID'; // Replace with actual admin/system user ID

                 // Fetch all relevant jogos data once if not already cached well
                 const uniqueJogoIds = [...new Set(predictionsToProcess.map(p => p.jogoId).filter(Boolean))];
                 const jogoPromises = uniqueJogoIds.map(id => getDoc(doc(db, 'jogos', id)));
                 const jogoDocs = await Promise.all(jogoPromises);
                 const jogosDataMap = jogoDocs.reduce((acc, docSnap) => {
                     if (docSnap.exists()) acc[docSnap.id] = docSnap.data();
                     return acc;
                 }, {});


                 // --- Process each prediction card (grouping by user/game is better) ---
                 for (const palpite of predictionsToProcess) {
                     // Ensure we have the latest data? Or trust the loaded `allPredictions` state?
                     // For launch, maybe re-fetch the specific palpite doc for safety? Less efficient.
                     // Let's trust the `allPredictions` state which was updated by UI changes.

                     if (!palpite.userId || !palpite.jogoId || !palpite.temporada || !palpite.nomeJogo) {
                         console.warn("Skipping palpite due to missing critical data:", palpite.id, palpite);
                         continue;
                     }

                     const jogoData = jogosDataMap[palpite.jogoId];
                     const numeroPalpites = jogoData && typeof jogoData.numeroPalpites === 'number' ? jogoData.numeroPalpites : 0;

                     if (numeroPalpites === 0) {
                         console.warn("Skipping palpite as jogo has 0 numeroPalpites:", palpite.id, palpite.jogoId);
                         continue;
                     }

                     let cardTotalPontosPossiveis = 0;
                     let cardTotalPontosGanhos = 0; // Sum of points where status is 'acerto'
                     let hasBeenAnalysed = false; // Flag if any part of this palpite has been updated

                     const palpiteUpdateData = {}; // Accumulate updates for this palpite doc

                     for (let i = 1; i <= numeroPalpites; i++) {
                         const pontosKey = `Palpite${i}PontosQuanto`;
                         const statusKey = `palpite${i}Status`;
                         const pontosGanhosKey = `Palpite${i}PontosGanhos`;
                         const gCoinsGanhosKey = `Palpite${i}GCoinsGanhos`;

                         if (palpite.hasOwnProperty(pontosKey)) { // Process only if palpite exists
                             const pontosValue = palpite[pontosKey] || 0;
                             const status = palpite[statusKey] || 'neutro';
                             let pontosGanhosValue = 0;

                             if (status === 'acerto') {
                                 pontosGanhosValue = pontosValue;
                             }

                             palpiteUpdateData[pontosKey] = pontosValue; // Ensure points are saved
                             palpiteUpdateData[statusKey] = status;   // Ensure status is saved
                             palpiteUpdateData[pontosGanhosKey] = pontosGanhosValue;
                             palpiteUpdateData[gCoinsGanhosKey] = pontosGanhosValue; // GCoins = Points Won

                             cardTotalPontosPossiveis += pontosValue; // Always add potential points
                             cardTotalPontosGanhos += pontosGanhosValue; // Add only if 'acerto'
                             hasBeenAnalysed = true; // Mark that we processed this palpite detail
                         }
                     } // End loop through palpite details (1 to numeroPalpites)

                     // Only update if something was processed
                     if (hasBeenAnalysed) {
                         palpiteUpdateData["Analisado"] = "Sim";
                         palpiteUpdateData["TotalPontosGanhos"] = cardTotalPontosGanhos; // Add total won for this card
                         palpiteUpdateData["TotalPontosPossiveis"] = cardTotalPontosPossiveis; // Add total possible for this card

                         try {
                             const palpiteRef = doc(db, 'palpites', palpite.id);
                             await updateDoc(palpiteRef, palpiteUpdateData);
                             // console.log(`Updated palpite ${palpite.id}`);
                         } catch(error) {
                            console.error(`Failed to update palpite ${palpite.id}:`, error);
                            // Continue to next palpite, but maybe log failure
                         }


                         // --- Aggregate data per user for final update ---
                         const userId = palpite.userId;
                         const temporada = palpite.temporada; // e.g., "2023/24"

                         if (!userAggregatedData[userId]) {
                             userAggregatedData[userId] = {
                                 totalPontosGanhosOverall: 0,
                                 totalPontosPossiveisOverall: 0,
                                 temporadas: {} // Store per-season data here
                             };
                         }

                          const temporadaKey = temporada.replace('/', ''); // e.g., "202324"
                         if (!userAggregatedData[userId].temporadas[temporadaKey]) {
                            userAggregatedData[userId].temporadas[temporadaKey] = {
                                totalPontosGanhos: 0,
                                totalPontosPossiveis: 0,
                                // GCoins will be calculated later from movimentos
                            };
                         }

                         userAggregatedData[userId].temporadas[temporadaKey].totalPontosGanhos += cardTotalPontosGanhos;
                         userAggregatedData[userId].temporadas[temporadaKey].totalPontosPossiveis += cardTotalPontosPossiveis;
                         // Keep track of overall totals too if needed, maybe not necessary if only updating seasonal fields
                         // userAggregatedData[userId].totalPontosGanhosOverall += cardTotalPontosGanhos;
                         // userAggregatedData[userId].totalPontosPossiveisOverall += cardTotalPontosPossiveis;


                         // --- Create/Update 'movimentos' document ---
                         const temporadaFormattedMov = temporada.replace('/', ''); // e.g., 202324
                         const movimentoQuery = query(
                             collection(db, 'movimentos'),
                             where("userId", "==", userId),
                             where("nomeJogo", "==", palpite.nomeJogo),
                             where("temporada", "==", temporadaFormattedMov),
                             where("estado", "==", "Palpite Paid"), // Look for existing paid movement for this game/user/season
                             limit(1)
                         );

                         try {
                             const movimentoSnapshot = await getDocs(movimentoQuery);
                             const movimentoData = {
                                 "de": currentAdminUserId, // System/Admin pays out
                                 "estado": "Palpite Paid",
                                 "jogadorId": null, // Not applicable for palpite payout
                                 "mediapontos": null, // Not applicable
                                 "movimentoData": serverTimestamp(),
                                 "para": userId, // User receiving points/gcoins
                                 "posicao": null, // Not applicable
                                 "preco": cardTotalPontosGanhos, // "Price" is the points/gcoins awarded
                                 "temporada": temporadaFormattedMov,
                                 "userId": userId, // User associated with movement
                                 "valorreal": cardTotalPontosGanhos, // Real value awarded
                                 "nomeJogo": palpite.nomeJogo // Link to the specific game
                             };

                             if (!movimentoSnapshot.empty) {
                                 // Update existing movement if found
                                 const movimentoDocRef = doc(db, 'movimentos', movimentoSnapshot.docs[0].id);
                                 await updateDoc(movimentoDocRef, movimentoData);
                                 // console.log(`Updated movimento for game ${palpite.nomeJogo}, user ${userId}`);
                             } else {
                                 // Create new movement if none exists
                                 await addDoc(collection(db, 'movimentos'), movimentoData);
                                 // console.log(`Created movimento for game ${palpite.nomeJogo}, user ${userId}`);
                             }
                         } catch (error) {
                             console.error(`Error creating/updating movimento for game ${palpite.nomeJogo}, user ${userId}:`, error);
                             // Decide how critical this is. Maybe continue processing other users?
                         }
                     } // End if(hasBeenAnalysed)

                 } // --- END OF predictionsToProcess LOOP ---


                 // --- UPDATE USER DOCUMENTS WITH AGGREGATED DATA ---
                 console.log("Aggregated User Data:", userAggregatedData);
                 for (const userId in userAggregatedData) {
                     const userData = userAggregatedData[userId];
                     const userRef = doc(db, 'users', userId);
                     const userUpdatePayload = {}; // Build payload for this user

                     for (const temporadaKey in userData.temporadas) {
                         const temporadaData = userData.temporadas[temporadaKey];
                         const temporadaPontosFieldName = `${temporadaKey}Pontos`;
                         const temporadaGCoinsFieldName = `${temporadaKey}GCoins`;
                         const temporadaPontosPossiveisFieldName = `${temporadaKey}PontosPossiveis`;

                         // Query ALL 'Palpite Paid' movimentos for this user and season to get total GCoins
                         const movimentosQuery = query(collection(db, 'movimentos'),
                             where("userId", "==", userId),
                             where("temporada", "==", temporadaKey),
                             where("estado", "==", "Palpite Paid") // Crucial condition
                         );

                         let totalGCoinsGanhosFromMovimentos = 0;
                         try {
                             const movimentosDocs = await getDocs(movimentosQuery);
                             movimentosDocs.forEach(doc => {
                                 const movData = doc.data();
                                 if (typeof movData.valorreal === 'number') {
                                     totalGCoinsGanhosFromMovimentos += movData.valorreal;
                                 } else {
                                    console.warn(`Movimento ${doc.id} for user ${userId}, temporada ${temporadaKey} has non-numeric valorreal:`, movData.valorreal);
                                 }
                             });

                             // Add seasonal data to the user update payload
                             userUpdatePayload[temporadaPontosFieldName] = temporadaData.totalPontosGanhos;
                             userUpdatePayload[temporadaPontosPossiveisFieldName] = temporadaData.totalPontosPossiveis;
                             userUpdatePayload[temporadaGCoinsFieldName] = totalGCoinsGanhosFromMovimentos; // Total from all relevant movements

                         } catch (error) {
                             console.error(`Error fetching movimentos to calculate GCoins for user ${userId}, temporada ${temporadaKey}:`, error);
                             // Skip updating this season's GCoins? Or skip user update entirely?
                             // For now, let's log the error and potentially update other fields if available
                         }
                     } // End loop through temporadas for the user

                     // Update the user document if there's anything to update
                     if (Object.keys(userUpdatePayload).length > 0) {
                         try {
                             await updateDoc(userRef, userUpdatePayload);
                             console.log(`User ${userId} updated with payload:`, userUpdatePayload);
                         } catch (error) {
                             console.error(`Failed to update user ${userId}:`, error);
                         }
                     } else {
                         console.log(`No updates calculated for user ${userId}.`);
                     }
                 } // --- USER DOCUMENTS UPDATE END ---


                 // --- Success ---
                 statusIconsSpan.innerHTML = '<i class="fas fa-check-circle success-icon" style="display: inline-block; color: #28a745;"></i>'; // Show success
                 console.log("Launch process completed successfully.");
                 alert("Lan√ßamento conclu√≠do com sucesso!");

                 // Reload predictions to reflect "Analisado" status and totals visually
                 await loadPredictions();

                 setTimeout(() => {
                    statusIconsSpan.innerHTML = ''; // Clear icon
                    launchButton.disabled = false;
                    isProcessingLaunch = false;
                 }, 3000);


             } catch (error) {
                 console.error('General error during launch process:', error);
                 alert(`Erro durante o lan√ßamento: ${error.message || 'Verifique o console.'}`);
                 statusIconsSpan.innerHTML = ''; // Clear icon on error
                 launchButton.disabled = false;
                 isProcessingLaunch = false;
             }

          });


         // --- ADD BEFOREUNLOAD EVENT LISTENER ---
         window.addEventListener('beforeunload', (event) => {
             if (isProcessingLaunch) {
                 const confirmationMessage = 'As atualiza√ß√µes de palpites est√£o em andamento. Tem certeza de que deseja sair desta p√°gina? Se sair, o processo pode ser interrompido.';
                 event.preventDefault(); // Standard practice
                 event.returnValue = confirmationMessage; // For older browsers
                 return confirmationMessage; // For modern browsers
             }
         });

         // Load main page predictions when the page loads
         loadPredictions();

    </script>

    <!-- == CONVERTER JAVASCRIPT START == -->
    <script>
    (function() { // Self-executing anonymous function for the converter

        // Listas de categorias (fixas, especiais, mapa) - inclua suas listas completas aqui
        const categories = [ /* ... lista completa omitida mas necess√°ria ... */
             // 1. Resultado Final
             "Result", "Double Chance", "Draw No Bet",
             // 2. Golos (Excluindo "Total", "Asian Total")
             "Both Teams to Score", /*"Asian Total",*/ "Total Odd/Even", "1st Goal", "2nd Goal", "3rd Goal", "4th Goal", "5th Goal", "Last Goal", "Goal in Both Halves", "Both Halves Over 1.5", "Both Halves Under 1.5", "Both Halves Over 2.5", "Both Halves Under 2.5", "Both Teams to Score in Both Halves", "Total Goals", "Total Goals 0 - 1", "Total Goals 1 - 2", "Total Goals 1 - 3", "Total Goals 2 - 3", "Total Goals 2 - 4", "Total Goals 2 - 5", "Total Goals 2 - 6", "Total Goals 3 - 4", "Total Goals 3 - 5", "Total Goals 4 - 5", "Total Goals 4 - 6", "Scoring draw", "Only One Team to Score", "Both Teams to Score at Least 1 Half", "Race to 2 Goals", "Race to 3 Goals", "1st Goal to Score", "2nd Goal to Score", "Total", // Added Total here conceptually, though mapped elsewhere
             // 3. Handicap (Excluindo "Handicap", "Asian Handicap")
              "European Handicap (0:1)", "European Handicap (0:2)", "European Handicap (1:0)", "European Handicap (2:0)",
             // 4. Intervalo/Fim do Jogo (HT/FT)
             "Half time/Full time", "Half time/Full time - Home/Home", "Half time/Full time - Draw/Home", "Half time/Full time - Draw/Draw", "Half time/Full time - Draw/Away", "Half time/Full time - Away/Away", "Half time/Full time Double Chance",
             // 5. Resultado Exato (Placar)
             "Correct Score", "Match Score 1:0, 2:0 or 2:1", "Match Score 0:0, 1:0 or 2:0", "Match Score 1:0, 2:0 or 1:1", "Match Score 1:0, 2:0 or 3:0", "Match Score 2:0, 3:0 or 3:1", "Match Score 1:0, 0:0 or 0:1", "Match Score 0:1, 0:2 or 1:2", "Match Score 0:0, 0:1 or 0:2", "Match Score 0:1, 0:2 or 1:1", "Match Score 0:1, 0:2 or 0:3", "Match Score 0:2, 0:3 or 1:3",
             // 6. Espec√≠ficos por Equipa
             "Total Team 1", "Total Team 2", "Total Goals Team 1", "Total Goals Team 2", "Team 1 to Score", "Team 2 to Score", "Goal in Both Halves: Team 1", "Goal in Both Halves: Team 2", "Team 1: Total Goals 0 - 1", "Team 1: Total Goals 1 - 2", "Team 1: Total Goals 1 - 3", "Team 1: Total Goals 1 - 4", "Team 1: Total Goals 2 - 3", "Team 1: Total Goals 2 - 4", "Team 1: Total Goals 3 - 4", "Team 1: Total Goals 3 - 6", "Team 2: Total Goals 0 - 1", "Team 2: Total Goals 1 - 2", "Team 2: Total Goals 1 - 3", "Team 2: Total Goals 1 - 4", "Team 2: Total Goals 2 - 3", "Team 2: Total Goals 2 - 4", "Team 2: Total Goals 3 - 4", "Team 2: Total Goals 3 - 6", "Each Team Over 1.5", "Each Team Under 1.5", "Team 1 to Score 2 Goals in a Row", "Team 1 to Score 3 Goals in a Row", "Team 2 to Score 2 Goals in a Row", "Team 2 to Score 3 Goals in a Row", "Win 1 at Least 1 Half", "Win 2 at Least 1 Half", "Win 1 in Both Halves", "Team 1 Highest Scoring Half", "Team 2 Highest Scoring Half",
             "Team 1 Score Its 1st Goal", "Team 1 Score Its 2nd Goal", "Team 2 to Score Its 1st Goal", "Team 2 to Score Its 2nd Goal",
             // 7. Mercados Combinados
             "Both Teams to Score and Total", "Result and Total", "Double Chance & Total", "Result and Both Teams to Score:", "Double Chance and Both Teams to Score", "Result or Total", "Result or Both Teams To Score:", "Total or Both Teams to Score:", "Team 1 Win 1st Half & Not Win Match", "Team 2 Win 1st Half & Not Win Match", "Team 1 to Score First & Win", "Team 1 to Score First & Not Win", "Team 2 to Score First & Win", "Team 2 to Score First & Not Win", "Team 1 to Win to Nil", "Team 2 to Win to Nil", "1st half Over (0.5) and 2nd half Over (1.5)", "1st half Over (1.5) and 2nd half Over (0.5)", "Total Over (3.5) and 1st half Over (1.5)", "Win1 and 1st half Over (1.5)", "Win2 and 1st half Over (1.5)", "Win1 and 1st half H1 (-1.5)", "Win2 and 1st half H2 (-1.5)", "H1 (-2.5) and 1st half Win1", "H2 (-2.5) and 1st half Win2", "H1 (-1.5) and 1st half Win1", "H2 (-1.5) and 1st half Win2", "Win1 and Team1 Over (1.5)", "Win2 and Team2 Over (1.5)", "Team 1 to Score First and", "Team 2 to Score First and", "Team 1 to Score First and Total", "Team 2 to Score First and Total", "Half time/Full time and Total", "Win1 and Total Goals 2 - 3", "Win2 and Total Goals 2 - 3", "1st Half/2nd Half Both Teams to Score", "1st Half Result or Both Teams To Score:", "2nd Half Result or Both Teams To Score:", "Half time/Full time and Both Teams to Score", "Penalty & Sending Off", "Penalty or Sending Off",
             // 8. Tempo (Timing)
             "Highest Scoring Half", "1st Goal Minute", "2nd Goal Minute", "Goal from 1 to 10 min.", "Goal from 1 to 15 min.", "Goal from 1 to 20 min.", "Goal from 1 to 25 min.", "Goal from 1 to 30 min.", "Goal from 1 to 35 min.", "Goal from 1 to 40 min.", "Goal from 46 to 60 min.", "Goal from 46 to 65 min.", "Goal from 46 to 70 min.", "Goal from 46 to 75 min.", "Goal from 46 to 80 min.", "Goal from 46 to 85 min.", "Goal from 76 to 90+ min.", "Result from 1 to 10 min.", "Result from 1 to 30 min.", "Result from 1 to 50 min.", "Result from 1 to 60 min.", "Result from 1 to 70 min", "Result from 1 to 75 min", "1-15 min.", "16-30 min.", "31-45+ min.", "46-60 min.", "61-75 min.", "76-90+ min.", "Total Goal Minutes",
             // 9. Por Parte (1¬™ Parte / 2¬™ Parte) (Excluindo Handicaps/Totals especiais)
             "1st Half: Goal", "2nd Half: Goal", "1st Half: Sending Off", "2nd Half: Sending Off", "1st Half: Penalty", "2nd Half: Penalty", "1st half: Both Teams to Score", "2nd half: Both Teams to Score", /*"1st half: Total",*/ "1st half: Total Team 1", "1st half: Total Team 2", /*"1st half: Asian Total",*/ "1st half: Total Even/Odd", /*"2nd half: Total",*/ "2nd half: Total Team 1", "2nd half: Total Team 2", /*"2nd half: Asian Total",*/ "2nd half: Total Even/Odd", /*"1st half: Handicap", "1st half: Asian Handicap", "2nd half: Handicap", "2nd half: Asian Handicap",*/ "1st half: Correct Score", "2nd half: Correct Score", "1st half: Result", "1st half: Double Chance", "1st half: Team 1 to Score", "1st half: Team 2 to Score", "1st half: Result and Total", "1st half: Result and Both Teams to Score:", "1st half: 1st Goal", "1st half: 2nd Goal", "1st half: 3rd Goal", "1st half: European Handicap (0:1)", "1st half: European Handicap (1:0)", "1st half: Total Goals 0 - 1", "1st half: Total Goals 1 - 2", "1st half: Total Goals 1 - 3", "1st half: Total Goals 2 - 3", "1st half: Total Goals 2 - 4", "1st half: Total Goals 2 - 5", "1st half: Total Goals 2 - 6", "1st half: Total Goals 3 - 4", "1st half: Total Goals 3 - 5", "1st half: Team 1: Total Goals 0 - 1", "1st half: Team 1: Total Goals 1 - 2", "1st half: Team 1: Total Goals 1 - 3", "1st half: Team 1: Total Goals 1 - 4", "1st half: Team 1: Total Goals 2 - 3", "1st half: Team 1: Total Goals 2 - 4", "1st half: Team 2: Total Goals 0 - 1", "1st half: Team 2: Total Goals 1 - 2", "1st half: Team 2: Total Goals 1 - 3", "1st half: Team 2: Total Goals 1 - 4", "1st half: Team 2: Total Goals 2 - 3", "1st half: Team 2: Total Goals 2 - 4", "1st half: Total Goals Team 1", "1st half: Total Goals Team 2", "1st half: Total Goals", "1st half: Team 1 to Win to Nil", "1st half: Team 2 to Win to Nil", "1st half: Last Goal", "2nd half: Result", "2nd half: Double Chance", "2nd half: Team 1 to Score", "2nd half: Team 2 to Score", "2nd half: 1st Goal", "2nd half: 2nd Goal", "2nd half: 3rd Goal", "2nd half: European Handicap (0:1)", "2nd half: European Handicap (1:0)", "2nd half: Total Goals 0 - 1", "2nd half: Total Goals 1 - 2", "2nd half: Total Goals 1 - 3", "2nd half: Total Goals 2 - 3", "2nd half: Total Goals 2 - 4", "2nd half: Total Goals 2 - 5", "2nd half: Total Goals 2 - 6", "2nd half: Total Goals 3 - 4", "2nd half: Total Goals 3 - 5", "2nd half: Team 1: Total Goals 0 - 1", "2nd half: Team 1: Total Goals 1 - 2", "2nd half: Team 1: Total Goals 1 - 3", "2nd half: Team 1: Total Goals 1 - 4", "2nd half: Team 1: Total Goals 2 - 3", "2nd half: Team 1: Total Goals 2 - 4", "2nd half: Team 2: Total Goals 0 - 1", "2nd half: Team 2: Total Goals 1 - 2", "2nd half: Team 2: Total Goals 1 - 3", "2nd half: Team 2: Total Goals 1 - 4", "2nd half: Team 2: Total Goals 2 - 3", "2nd half: Team 2: Total Goals 2 - 4", "2nd half: Total Goals Team 1", "2nd half: Total Goals Team 2", "2nd half: Total Goals", "2nd half: Team 1 to Win to Nil", "2nd half: Team 2 to Win to Nil", "2nd half: Last Goal", "1st half or match",
             // 10. Mercados Especiais / Eventos
             "Tie Breaker", "Penalty", "Sending Off", "Sending Off Team 1", "Sending Off Team 2", "1st to Happen:", "How is Scored 1st Goal", "Team 1 Winning Margin 1 Goal", "Team 1 Winning Margin 2 Goals", "Team 1 Winning Margin 1 or 2 Goals", "Team 1 Winning Margin 2 or 3 Goals", "Team 1 Winning Margin 2 or more Goals", "Team 1 Winning Margin 1 Goal or Draw", "Team 1 Winning Margin 2 Goals or Draw", "Team 2 Winning Margin 1 Goal", "Team 2 Winning Margin 2 Goals", "Team 2 Winning Margin 1 or 2 Goals", "Team 2 Winning Margin 2 or 3 Goals", "Team 2 Winning Margin 2 or more Goals", "Team 2 Winning Margin 1 Goal or Draw", "Team 2 Winning Margin 2 Goals or Draw", "Draw in at least one of the Halves", "Any Team Winning Margin 1", "Any Team Winning Margin 2", "Any Team Winning Margin 3", "Any Team Winning Margin 2 & more", "Any Team Winning Margin 3 & more", "Team 1 win from Behind", "Team 2 Win from Behind", "Own Goal", "Double", "1:1 During The Match", "2:0 or 0:2 During The Match", "2:0 During The Match", "0:2 During The Match", "To Miss A Penalty", "To Score A Penalty", "Red card in both teams",
             // 11. Cantos (Excluindo "Corners: Total", "Corners: Handicap")
             /*"Corners: Total",*/ "Corners: Total Team 1", "Corners: Total Team 2", "Corners: Total Even/Odd", "Corners: 1st Half: Total:", "Corners: 1st Half: Total Team 1", "Corners: 1st Half: Total Team 2", "Corners: 2nd Half: Total", "Corners: 2nd Half: Total Team 1", "Corners: 2nd Half: Total Team 2", "Corners: Total (3 way)", /*"Corners: Handicap",*/ "Corners: 1st Half: Handicap", "Corners: 2nd Half: Handicap", "Corners: Result", "Corners: 1st Half: Result", "Corners: 2nd Half: Result", "Corners: Highest Scoring Half", "Corners: 1st Corner", "Corners: Last Corner:", "Corners: 10 Minutes Corners (00:00-9:59)", "Corners: Race to Corners",
             // 12. Cart√µes Amarelos (Excluindo "Yellow Cards: Total", "Yellow Cards: Handicap")
             /*"Yellow Cards: Total",*/ "Yellow Cards: Total Team 1", "Yellow Cards: Total Team 2", "Yellow Cards: Total Odd/Even", "Yellow Cards: 1st Half: Total:", "Yellow Cards: 1st Half: Total Team 1", "Yellow Cards: 1st Half: Total Team 2", "Yellow Cards: 2nd Half: Total", /*"Yellow Cards: Handicap",*/ "Yellow Cards: 1st Half: Handicap", "Yellow Cards: 2nd Half: Handicap", "Yellow Cards: Result", "Yellow Cards: Double Chance", "Yellow Cards: 1st Half: Result", "Yellow Cards: 1st Half: Double Chance", "Yellow Cards: 2nd Half: Result", "Yellow Cards: 2nd Half: Double Chance", "Yellow Cards: Highest Scoring Half", "Yellow Cards: 1st Yellow Card Minute", "Yellow Cards: Both Teams to Receive Cards", "Yellow Cards: Both Teams to Receive 2 or More Cards",
             // 13. Remates √† Baliza
             "Shots on target: Total", "Shots on target: Total Team 1", "Shots on target: Total Team 2", "Shots on target: Total Even/Odd", "Shots on target: 1st Half: Total:", "Shots on target: 1st Half: Total Team 1", "Shots on target: 1st Half: Total Team 2", "Shots on target: Handicap", "Shots on target: 1st Half: Handicap", "Shots on target: Result", "Shots on target: Double Chance", "Shots on target: 1st Half: Result", "Shots on target: 1st Half: Double Chance", "Shots on target: Highest Scoring Half",
             // 14. Faltas
             "Fouls: Total", "Fouls: Total Team 1", "Fouls: Total Team 2", "Fouls: Total Even/Odd", "Fouls: Handicap", "Fouls: Result", "Fouls: Double Chance", "Fouls: Highest Scoring Half",
             "Offsides: Total", "Offsides: Total Team 1", "Offsides: Total Team 2", "Offsides: Total Even/Odd", "Offsides: Handicap", "Offsides: Result", "Offsides: Double Chance",
             // 15. Remates Totais
             "Shots: Total", "Shots: Total Team 1", "Shots: Total Team 2", "Shots: Total Even/Odd", "Shots: 1st Half: Total Team 1", "Shots: 1st Half: Total Team 2", "Shots: Handicap", "Shots: 1st Half: Handicap", "Shots: Result", "Shots: Double Chance", "Shots: 1st Half: Result", "Shots: 1st Half: Double Chance", "Shots: Highest Scoring Half",
             // --- NOVAS Subcategorias "Specials:" ---
             "Specials: Total Headed Goals",
             "Specials: To Occur First - Corner or Goal:",
             "Specials: To Occur First - Throw in or Foul:",
             "Specials: 1st half 1X and Corners under 10.5 and Yellow Cards over 3.5:",
             "Specials: Over 9.5 corners & over 4.5 yellow cards:",
             "Specials: Over 9.5 corners & over 3.5 yellow cards:",
             "Specials: Win1, over 10.5 corners & over 3.5 yellow cards:",
             "Specials: Win1, over 9.5 corners & over 3.5 yellow cards:",
             "Specials: Win1, over 1.5 1st half goals & over 3.5 yellow cards:",
             "Specials: Over 1.5 1st half goals, over 3.5 yellow cards & over 10.5 corners",
             "Specials: Over 3.5 goals & over 10.5 corners:",
             "Specials: Over 2.5 goals & over 10.5 corners:",
             "Specials: Win1 & over 9.5 corners:",
             "Specials: Over 3.5 Goals, Over 9.5 Corners & Over 3.5 Yellow Card",
             "Specials: Under 3.5 goals, under 9.5 corners & under 3.5 yellow cards:",
             "Specials: Win1, corners win1 & yellow cards win1:",
             "Specials: Over 3.5 goals & under 10.5 corners:",
             "Specials: X2, yellow cards-win2 and corners over 9.5",
             "Specials: Win1 & over 3.5 yellow cards:",
             "Specials: Win1 & over 4.5 yellow cards:",
             "Specials: Win1 & over 10.5 corners:",
             "Specials: The medical team will appear on the field",
             "Specials: Goal from outside the penalty area:",
             "Specials: The goalkeeper will get a red card:",
             // 16. Jogadores
             "Players:" // Base for player markets
        ];

        // Lista DEFINITIVA de categorias ESPECIAIS (max 1 principal, max 1 alternativa)
        const specialCategories = new Set([ /* ... lista completa omitida mas necess√°ria ... */
            "Total", // Movida para Resultado Final no map, mas ainda especial para l√≥gica
            "Asian Total",
            "Handicap",
            "Asian Handicap",
            "1st half: Total",
            "1st half: Asian Total",
            "1st half: Handicap",
            "1st half: Asian Handicap",
            "2nd half: Total",
            "2nd half: Asian Total",
            "2nd half: Handicap",
            "2nd half: Asian Handicap",
            "Corners: Total",
            "Corners: Handicap",
            "Yellow Cards: Total",
            "Yellow Cards: Handicap"
        ]);

        // Mapeamento das subcategorias para as categorias principais do Filtro
        const categoryMap = { /* ... mapa completo omitido mas necess√°rio ... */
             // 1. Resultado Final
             "Result": "Resultado Final", "Double Chance": "Resultado Final", "Draw No Bet": "Resultado Final",
             // Total movido para Golos
             // 2. Golos
             "Total": "Golos", // <-- ALTERADO AQUI
             "Both Teams to Score": "Golos", "Asian Total": "Golos", "Total Odd/Even": "Golos", "1st Goal": "Golos", "2nd Goal": "Golos", "3rd Goal": "Golos", "4th Goal": "Golos", "5th Goal": "Golos", "Last Goal": "Golos", "Goal in Both Halves": "Golos", "Both Halves Over 1.5": "Golos", "Both Halves Under 1.5": "Golos", "Both Halves Over 2.5": "Golos", "Both Halves Under 2.5": "Golos", "Both Teams to Score in Both Halves": "Golos", "Total Goals": "Golos", "Total Goals 0 - 1": "Golos", "Total Goals 1 - 2": "Golos", "Total Goals 1 - 3": "Golos", "Total Goals 2 - 3": "Golos", "Total Goals 2 - 4": "Golos", "Total Goals 2 - 5": "Golos", "Total Goals 2 - 6": "Golos", "Total Goals 3 - 4": "Golos", "Total Goals 3 - 5": "Golos", "Total Goals 4 - 5": "Golos", "Total Goals 4 - 6": "Golos", "Scoring draw": "Golos", "Only One Team to Score": "Golos", "Both Teams to Score at Least 1 Half": "Golos", "Race to 2 Goals": "Golos", "Race to 3 Goals": "Golos", "1st Goal to Score": "Golos", "2nd Goal to Score": "Golos",
             // 3. Handicap
             "Handicap": "Handicap", "Asian Handicap": "Handicap", "European Handicap (0:1)": "Handicap", "European Handicap (0:2)": "Handicap", "European Handicap (1:0)": "Handicap", "European Handicap (2:0)": "Handicap",
             // 4. Intervalo/Fim do Jogo (HT/FT)
             "Half time/Full time": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Home/Home": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Draw/Home": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Draw/Draw": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Draw/Away": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Away/Away": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time Double Chance": "Intervalo/Fim do Jogo (HT/FT)",
             // 5. Resultado Exato (Placar)
             "Correct Score": "Resultado Exato (Placar)", "Match Score 1:0, 2:0 or 2:1": "Resultado Exato (Placar)", "Match Score 0:0, 1:0 or 2:0": "Resultado Exato (Placar)", "Match Score 1:0, 2:0 or 1:1": "Resultado Exato (Placar)", "Match Score 1:0, 2:0 or 3:0": "Resultado Exato (Placar)", "Match Score 2:0, 3:0 or 3:1": "Resultado Exato (Placar)", "Match Score 1:0, 0:0 or 0:1": "Resultado Exato (Placar)", "Match Score 0:1, 0:2 or 1:2": "Resultado Exato (Placar)", "Match Score 0:0, 0:1 or 0:2": "Resultado Exato (Placar)", "Match Score 0:1, 0:2 or 1:1": "Resultado Exato (Placar)", "Match Score 0:1, 0:2 or 0:3": "Resultado Exato (Placar)", "Match Score 0:2, 0:3 or 1:3": "Resultado Exato (Placar)",
             // 6. Espec√≠ficos por Equipa
             "Total Team 1": "Espec√≠ficos por Equipa", "Total Team 2": "Espec√≠ficos por Equipa", "Total Goals Team 1": "Espec√≠ficos por Equipa", "Total Goals Team 2": "Espec√≠ficos por Equipa", "Team 1 to Score": "Espec√≠ficos por Equipa", "Team 2 to Score": "Espec√≠ficos por Equipa", "Goal in Both Halves: Team 1": "Espec√≠ficos por Equipa", "Goal in Both Halves: Team 2": "Espec√≠ficos por Equipa", "Team 1: Total Goals 0 - 1": "Espec√≠ficos por Equipa", "Team 1: Total Goals 1 - 2": "Espec√≠ficos por Equipa", "Team 1: Total Goals 1 - 3": "Espec√≠ficos por Equipa", "Team 1: Total Goals 1 - 4": "Espec√≠ficos por Equipa", "Team 1: Total Goals 2 - 3": "Espec√≠ficos por Equipa", "Team 1: Total Goals 2 - 4": "Espec√≠ficos por Equipa", "Team 1: Total Goals 3 - 4": "Espec√≠ficos por Equipa", "Team 1: Total Goals 3 - 6": "Espec√≠ficos por Equipa", "Team 2: Total Goals 0 - 1": "Espec√≠ficos por Equipa", "Team 2: Total Goals 1 - 2": "Espec√≠ficos por Equipa", "Team 2: Total Goals 1 - 3": "Espec√≠ficos por Equipa", "Team 2: Total Goals 1 - 4": "Espec√≠ficos por Equipa", "Team 2: Total Goals 2 - 3": "Espec√≠ficos por Equipa", "Team 2: Total Goals 2 - 4": "Espec√≠ficos por Equipa", "Team 2: Total Goals 3 - 4": "Espec√≠ficos por Equipa", "Team 2: Total Goals 3 - 6": "Espec√≠ficos por Equipa", "Each Team Over 1.5": "Espec√≠ficos por Equipa", "Each Team Under 1.5": "Espec√≠ficos por Equipa", "Team 1 to Score 2 Goals in a Row": "Espec√≠ficos por Equipa", "Team 1 to Score 3 Goals in a Row": "Espec√≠ficos por Equipa", "Team 2 to Score 2 Goals in a Row": "Espec√≠ficos por Equipa", "Team 2 to Score 3 Goals in a Row": "Espec√≠ficos por Equipa", "Win 1 at Least 1 Half": "Espec√≠ficos por Equipa", "Win 2 at Least 1 Half": "Espec√≠ficos por Equipa", "Win 1 in Both Halves": "Espec√≠ficos por Equipa", "Team 1 Highest Scoring Half": "Espec√≠ficos por Equipa", "Team 2 Highest Scoring Half": "Espec√≠ficos por Equipa",
             "Team 1 Score Its 1st Goal": "Espec√≠ficos por Equipa", "Team 1 Score Its 2nd Goal": "Espec√≠ficos por Equipa", "Team 2 to Score Its 1st Goal": "Espec√≠ficos por Equipa", "Team 2 to Score Its 2nd Goal": "Espec√≠ficos por Equipa",
             // 7. Mercados Combinados
             "Both Teams to Score and Total": "Mercados Combinados", "Result and Total": "Mercados Combinados", "Double Chance & Total": "Mercados Combinados", "Result and Both Teams to Score:": "Mercados Combinados", "Double Chance and Both Teams to Score": "Mercados Combinados", "Result or Total": "Mercados Combinados", "Result or Both Teams To Score:": "Mercados Combinados", "Total or Both Teams to Score:": "Mercados Combinados", "Team 1 Win 1st Half & Not Win Match": "Mercados Combinados", "Team 2 Win 1st Half & Not Win Match": "Mercados Combinados", "Team 1 to Score First & Win": "Mercados Combinados", "Team 1 to Score First & Not Win": "Mercados Combinados", "Team 2 to Score First & Win": "Mercados Combinados", "Team 2 to Score First & Not Win": "Mercados Combinados", "Team 1 to Win to Nil": "Mercados Combinados", "Team 2 to Win to Nil": "Mercados Combinados", "1st half Over (0.5) and 2nd half Over (1.5)": "Mercados Combinados", "1st half Over (1.5) and 2nd half Over (0.5)": "Mercados Combinados", "Total Over (3.5) and 1st half Over (1.5)": "Mercados Combinados", "Win1 and 1st half Over (1.5)": "Mercados Combinados", "Win2 and 1st half Over (1.5)": "Mercados Combinados", "Win1 and 1st half H1 (-1.5)": "Mercados Combinados", "Win2 and 1st half H2 (-1.5)": "Mercados Combinados", "H1 (-2.5) and 1st half Win1": "Mercados Combinados", "H2 (-2.5) and 1st half Win2": "Mercados Combinados", "H1 (-1.5) and 1st half Win1": "Mercados Combinados", "H2 (-1.5) and 1st half Win2": "Mercados Combinados", "Win1 and Team1 Over (1.5)": "Mercados Combinados", "Win2 and Team2 Over (1.5)": "Mercados Combinados", "Team 1 to Score First and": "Mercados Combinados", "Team 2 to Score First and": "Mercados Combinados", "Team 1 to Score First and Total": "Mercados Combinados", "Team 2 to Score First and Total": "Mercados Combinados", "Half time/Full time and Total": "Mercados Combinados", "Win1 and Total Goals 2 - 3": "Mercados Combinados", "Win2 and Total Goals 2 - 3": "Mercados Combinados", "1st Half/2nd Half Both Teams to Score": "Mercados Combinados", "1st Half Result or Both Teams To Score:": "Mercados Combinados", "2nd Half Result or Both Teams To Score:": "Mercados Combinados", "Half time/Full time and Both Teams to Score": "Mercados Combinados", "Penalty & Sending Off": "Mercados Combinados", "Penalty or Sending Off": "Mercados Combinados",
             "Specials: 1st half 1X and Corners under 10.5 and Yellow Cards over 3.5:": "Mercados Combinados", "Specials: Over 9.5 corners & over 4.5 yellow cards:": "Mercados Combinados", "Specials: Over 9.5 corners & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, over 10.5 corners & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, over 9.5 corners & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, over 1.5 1st half goals & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Over 1.5 1st half goals, over 3.5 yellow cards & over 10.5 corners": "Mercados Combinados", "Specials: Over 3.5 goals & over 10.5 corners:": "Mercados Combinados", "Specials: Over 2.5 goals & over 10.5 corners:": "Mercados Combinados", "Specials: Win1 & over 9.5 corners:": "Mercados Combinados", "Specials: Over 3.5 Goals, Over 9.5 Corners & Over 3.5 Yellow Card": "Mercados Combinados", "Specials: Under 3.5 goals, under 9.5 corners & under 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, corners win1 & yellow cards win1:": "Mercados Combinados", "Specials: Over 3.5 goals & under 10.5 corners:": "Mercados Combinados", "Specials: X2, yellow cards-win2 and corners over 9.5": "Mercados Combinados", "Specials: Win1 & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1 & over 4.5 yellow cards:": "Mercados Combinados", "Specials: Win1 & over 10.5 corners:": "Mercados Combinados",
             // 8. Tempo (Timing)
             "Highest Scoring Half": "Tempo (Timing)", "1st Goal Minute": "Tempo (Timing)", "2nd Goal Minute": "Tempo (Timing)", "Goal from 1 to 10 min.": "Tempo (Timing)", "Goal from 1 to 15 min.": "Tempo (Timing)", "Goal from 1 to 20 min.": "Tempo (Timing)", "Goal from 1 to 25 min.": "Tempo (Timing)", "Goal from 1 to 30 min.": "Tempo (Timing)", "Goal from 1 to 35 min.": "Tempo (Timing)", "Goal from 1 to 40 min.": "Tempo (Timing)", "Goal from 46 to 60 min.": "Tempo (Timing)", "Goal from 46 to 65 min.": "Tempo (Timing)", "Goal from 46 to 70 min.": "Tempo (Timing)", "Goal from 46 to 75 min.": "Tempo (Timing)", "Goal from 46 to 80 min.": "Tempo (Timing)", "Goal from 46 to 85 min.": "Tempo (Timing)", "Goal from 76 to 90+ min.": "Tempo (Timing)", "Result from 1 to 10 min.": "Tempo (Timing)", "Result from 1 to 30 min.": "Tempo (Timing)", "Result from 1 to 50 min.": "Tempo (Timing)", "Result from 1 to 60 min.": "Tempo (Timing)", "Result from 1 to 70 min": "Tempo (Timing)", "Result from 1 to 75 min": "Tempo (Timing)", "1-15 min.": "Tempo (Timing)", "16-30 min.": "Tempo (Timing)", "31-45+ min.": "Tempo (Timing)", "46-60 min.": "Tempo (Timing)", "61-75 min.": "Tempo (Timing)", "76-90+ min.": "Tempo (Timing)", "Total Goal Minutes": "Tempo (Timing)",
             // 9. Por Parte (1¬™ Parte / 2¬™ Parte)
             "1st Half: Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd Half: Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st Half: Sending Off": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd Half: Sending Off": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st Half: Penalty": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd Half: Penalty": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Both Teams to Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Both Teams to Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Team 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Team 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Asian Total": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Even/Odd": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Team 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Team 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Asian Total": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Even/Odd": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Handicap": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Asian Handicap": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Handicap": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Asian Handicap": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Correct Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Correct Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Result": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Double Chance": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1 to Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2 to Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Result and Total": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Result and Both Teams to Score:": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: 1st Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: 2nd Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: 3rd Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: European Handicap (0:1)": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: European Handicap (1:0)": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 0 - 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 1 - 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 1 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 2 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 2 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 2 - 5": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 2 - 6": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 3 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals 3 - 5": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1: Total Goals 0 - 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1: Total Goals 1 - 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1: Total Goals 1 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1: Total Goals 1 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1: Total Goals 2 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1: Total Goals 2 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2: Total Goals 0 - 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2: Total Goals 1 - 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2: Total Goals 1 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2: Total Goals 1 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2: Total Goals 2 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2: Total Goals 2 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals Team 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals Team 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Total Goals": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 1 to Win to Nil": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Team 2 to Win to Nil": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half: Last Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Result": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Double Chance": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1 to Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2 to Score": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: 1st Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: 2nd Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: 3rd Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: European Handicap (0:1)": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: European Handicap (1:0)": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 0 - 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 1 - 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 1 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 2 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 2 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 2 - 5": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 2 - 6": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 3 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals 3 - 5": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1: Total Goals 0 - 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1: Total Goals 1 - 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1: Total Goals 1 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1: Total Goals 1 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1: Total Goals 2 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1: Total Goals 2 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2: Total Goals 0 - 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2: Total Goals 1 - 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2: Total Goals 1 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2: Total Goals 1 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2: Total Goals 2 - 3": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2: Total Goals 2 - 4": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals Team 1": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals Team 2": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Total Goals": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 1 to Win to Nil": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Team 2 to Win to Nil": "Por Parte (1¬™ Parte / 2¬™ Parte)", "2nd half: Last Goal": "Por Parte (1¬™ Parte / 2¬™ Parte)", "1st half or match": "Por Parte (1¬™ Parte / 2¬™ Parte)",
             // 10. Mercados Especiais / Eventos
             "Tie Breaker": "Mercados Especiais / Eventos", "Penalty": "Mercados Especiais / Eventos", "Sending Off": "Mercados Especiais / Eventos", "Sending Off Team 1": "Mercados Especiais / Eventos", "Sending Off Team 2": "Mercados Especiais / Eventos", "1st to Happen:": "Mercados Especiais / Eventos", "How is Scored 1st Goal": "Mercados Especiais / Eventos", "Team 1 Winning Margin 1 Goal": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 1 or 2 Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 or 3 Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 or more Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 1 Goal or Draw": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 Goals or Draw": "Mercados Especiais / Eventos", "Team 2 Winning Margin 1 Goal": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 1 or 2 Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 or 3 Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 or more Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 1 Goal or Draw": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 Goals or Draw": "Mercados Especiais / Eventos", "Draw in at least one of the Halves": "Mercados Especiais / Eventos", "Any Team Winning Margin 1": "Mercados Especiais / Eventos", "Any Team Winning Margin 2": "Mercados Especiais / Eventos", "Any Team Winning Margin 3": "Mercados Especiais / Eventos", "Any Team Winning Margin 2 & more": "Mercados Especiais / Eventos", "Any Team Winning Margin 3 & more": "Mercados Especiais / Eventos", "Team 1 win from Behind": "Mercados Especiais / Eventos", "Team 2 Win from Behind": "Mercados Especiais / Eventos", "Own Goal": "Mercados Especiais / Eventos", "Double": "Mercados Especiais / Eventos", "1:1 During The Match": "Mercados Especiais / Eventos", "2:0 or 0:2 During The Match": "Mercados Especiais / Eventos", "2:0 During The Match": "Mercados Especiais / Eventos", "0:2 During The Match": "Mercados Especiais / Eventos", "To Miss A Penalty": "Mercados Especiais / Eventos", "To Score A Penalty": "Mercados Especiais / Eventos", "Red card in both teams": "Mercados Especiais / Eventos",
             "Specials: Total Headed Goals": "Mercados Especiais / Eventos", "Specials: To Occur First - Corner or Goal:": "Mercados Especiais / Eventos", "Specials: To Occur First - Throw in or Foul:": "Mercados Especiais / Eventos", "Specials: The medical team will appear on the field": "Mercados Especiais / Eventos", "Specials: Goal from outside the penalty area:": "Mercados Especiais / Eventos", "Specials: The goalkeeper will get a red card:": "Mercados Especiais / Eventos",
             // 11. Cantos
             "Corners: Total": "Cantos", "Corners: Total Team 1": "Cantos", "Corners: Total Team 2": "Cantos", "Corners: Total Even/Odd": "Cantos", "Corners: 1st Half: Total:": "Cantos", "Corners: 1st Half: Total Team 1": "Cantos", "Corners: 1st Half: Total Team 2": "Cantos", "Corners: 2nd Half: Total": "Cantos", "Corners: 2nd Half: Total Team 1": "Cantos", "Corners: 2nd Half: Total Team 2": "Cantos", "Corners: Total (3 way)": "Cantos", "Corners: Handicap": "Cantos", "Corners: 1st Half: Handicap": "Cantos", "Corners: 2nd Half: Handicap": "Cantos", "Corners: Result": "Cantos", "Corners: 1st Half: Result": "Cantos", "Corners: 2nd Half: Result": "Cantos", "Corners: Highest Scoring Half": "Cantos", "Corners: 1st Corner": "Cantos", "Corners: Last Corner:": "Cantos", "Corners: 10 Minutes Corners (00:00-9:59)": "Cantos", "Corners: Race to Corners": "Cantos",
             // 12. Cart√µes Amarelos
             "Yellow Cards: Total": "Cart√µes Amarelos", "Yellow Cards: Total Team 1": "Cart√µes Amarelos", "Yellow Cards: Total Team 2": "Cart√µes Amarelos", "Yellow Cards: Total Odd/Even": "Cart√µes Amarelos", "Yellow Cards: 1st Half: Total:": "Cart√µes Amarelos", "Yellow Cards: 1st Half: Total Team 1": "Cart√µes Amarelos", "Yellow Cards: 1st Half: Total Team 2": "Cart√µes Amarelos", "Yellow Cards: 2nd Half: Total": "Cart√µes Amarelos", "Yellow Cards: Handicap": "Cart√µes Amarelos", "Yellow Cards: 1st Half: Handicap": "Cart√µes Amarelos", "Yellow Cards: 2nd Half: Handicap": "Cart√µes Amarelos", "Yellow Cards: Result": "Cart√µes Amarelos", "Yellow Cards: Double Chance": "Cart√µes Amarelos", "Yellow Cards: 1st Half: Result": "Cart√µes Amarelos", "Yellow Cards: 1st Half: Double Chance": "Cart√µes Amarelos", "Yellow Cards: 2nd Half: Result": "Cart√µes Amarelos", "Yellow Cards: 2nd Half: Double Chance": "Cart√µes Amarelos", "Yellow Cards: Highest Scoring Half": "Cart√µes Amarelos", "Yellow Cards: 1st Yellow Card Minute": "Cart√µes Amarelos", "Yellow Cards: Both Teams to Receive Cards": "Cart√µes Amarelos", "Yellow Cards: Both Teams to Receive 2 or More Cards": "Cart√µes Amarelos",
             // 13. Remates √† Baliza
             "Shots on target: Total": "Remates √† Baliza", "Shots on target: Total Team 1": "Remates √† Baliza", "Shots on target: Total Team 2": "Remates √† Baliza", "Shots on target: Total Even/Odd": "Remates √† Baliza", "Shots on target: 1st Half: Total:": "Remates √† Baliza", "Shots on target: 1st Half: Total Team 1": "Remates √† Baliza", "Shots on target: 1st Half: Total Team 2": "Remates √† Baliza", "Shots on target: Handicap": "Remates √† Baliza", "Shots on target: 1st Half: Handicap": "Remates √† Baliza", "Shots on target: Result": "Remates √† Baliza", "Shots on target: Double Chance": "Remates √† Baliza", "Shots on target: 1st Half: Result": "Remates √† Baliza", "Shots on target: 1st Half: Double Chance": "Remates √† Baliza", "Shots on target: Highest Scoring Half": "Remates √† Baliza",
             // 14. Faltas
             "Fouls: Total": "Faltas", "Fouls: Total Team 1": "Faltas", "Fouls: Total Team 2": "Faltas", "Fouls: Total Even/Odd": "Faltas", "Fouls: Handicap": "Faltas", "Fouls: Result": "Faltas", "Fouls: Double Chance": "Faltas", "Fouls: Highest Scoring Half": "Faltas",
             "Offsides: Total": "Faltas", "Offsides: Total Team 1": "Faltas", "Offsides: Total Team 2": "Faltas", "Offsides: Total Even/Odd": "Faltas", "Offsides: Handicap": "Faltas", "Offsides: Result": "Faltas", "Offsides: Double Chance": "Faltas",
             // 15. Remates Totais
             "Shots: Total": "Remates Totais", "Shots: Total Team 1": "Remates Totais", "Shots: Total Team 2": "Remates Totais", "Shots: Total Even/Odd": "Remates Totais", "Shots: 1st Half: Total Team 1": "Remates Totais", "Shots: 1st Half: Total Team 2": "Remates Totais", "Shots: Handicap": "Remates Totais", "Shots: 1st Half: Handicap": "Remates Totais", "Shots: Result": "Remates Totais", "Shots: Double Chance": "Remates Totais", "Shots: 1st Half: Result": "Remates Totais", "Shots: 1st Half: Double Chance": "Remates Totais", "Shots: Highest Scoring Half": "Remates Totais",
             // 16. Jogadores (Totais)
             "Players:": "16. Jogadores (Totais)", // Catch-all for player markets
             // *** NEW: Add mapping for our pattern ***
             "Pattern: Team Scores Only One Half": "Espec√≠ficos por Equipa" // Map to appropriate filter category
        };

        // --- CONSTANTE para frases a ignorar ---
        const ignorePhrases = new Set([ /* ... lista completa omitida mas necess√°ria ... */
            "Live Info", "Live TV", "Bet Slip", "Odds:", "TOTAL WIN", "Log in", "Handicap:Handicap 1 (-1)", "1 000", "LIVE TV IS UNAVAILABLE!",
            "Stake", "Multi System", "Single", "Place bet", "Place", "Log in to watch live matches by using your username and password."
        ]);

        // --- Fun√ß√µes auxiliares (isOddNumber, classifySpecialBlock, createCategoryTable, addTableRow) ---
        function isOddNumber(str) {
             if (!str) return false;
             // Check if it's a number, potentially with a decimal point
             return /^\s*\d+(\.\d+)?\s*$/.test(str);
         }

         function classifySpecialBlock(header, pairs) {
             const numPairs = pairs.length;
              // Heuristic: Differentiate based on the number of pairs common for these types
              if (header.includes("Corners: Total") || header.includes("Yellow Cards: Total")) {
                   // Typically Over/Under (2 pairs) is principal, 3-way (3 pairs) is alternative? Or vice-versa?
                   // Let's assume 2 pairs = principal (Over/Under)
                  return numPairs === 2 ? 'principal' : 'alternative';
             } else if (header.includes("Handicap") || header.includes("Total")) { // Covers Total, Asian Total, 1st half: Total etc.
                   // Standard Handicap/Total usually has 2 options (e.g., H1/H2 or Over/Under)
                  return numPairs === 2 ? 'principal' : 'alternative';
             }
             // Fallback for unexpected special categories
             // console.warn("ClassifySpecialBlock fallback (treating as principal) for:", header);
             return 'principal'; // Treat unknown specials as principal by default
         }

          function createCategoryTable(headerText) {
             const table = document.createElement('table');
             table.style.display = 'none'; // Initially hide tables until filtered
             const thead = document.createElement('thead');
             const headerRow = document.createElement('tr');
             const headerCell = document.createElement('th');
             headerCell.colSpan = 3; // Span across Option, Odd, Score columns
             headerCell.textContent = headerText;
             headerRow.appendChild(headerCell);

             // Add sub-headers for columns
             const subHeaderRow = document.createElement('tr');
             const optionTh = document.createElement('th');
             optionTh.textContent = 'Op√ß√£o';
             optionTh.style.textAlign = 'left';
             const oddTh = document.createElement('th');
             oddTh.textContent = 'Odd';
             oddTh.style.textAlign = 'right';
             const scoreTh = document.createElement('th');
             scoreTh.textContent = 'Score';
             scoreTh.style.textAlign = 'right';
             subHeaderRow.appendChild(optionTh);
             subHeaderRow.appendChild(oddTh);
             subHeaderRow.appendChild(scoreTh);

             thead.appendChild(headerRow);
             table.appendChild(thead);
             const tbody = document.createElement('tbody');
             table.appendChild(tbody);
             return table;
         }

         function addTableRow(table, optionText, oddValue) {
             const tbody = table.querySelector('tbody');
             if (!tbody) return;

             const row = document.createElement('tr');
             const textCell = document.createElement('td');
             textCell.textContent = optionText.trim();

             const numberCell = document.createElement('td');
             numberCell.textContent = oddValue.trim();
             numberCell.style.textAlign = 'right'; // Align odd right

             const calculationCell = document.createElement('td');
             calculationCell.style.textAlign = 'right'; // Align score right
             const odd = parseFloat(oddValue.trim());

             if (!isNaN(odd)) {
                 // Define the logarithmic scale parameters
                 const oddMin = 1.01; // Minimum odd to start scaling from 1
                 const oddMax = 15.0; // Odd value that corresponds to score 10
                 const scoreMin = 1;   // Minimum score
                 const scoreMax = 10;  // Maximum score

                 let score;

                 if (odd < 0.5) {
                     score = 0; // Odds below 0.5 get score 0
                 } else if (odd < oddMin) {
                     score = 1; // Odds between 0.5 and 1.01 (exclusive) get score 1
                 } else if (odd >= oddMax) {
                     score = 10; // Odds 15 or higher get score 10
                 } else {
                     // Apply logarithmic scaling between oddMin and oddMax
                     const logOdd = Math.log(odd);
                     const logOddMin = Math.log(oddMin);
                     const logOddMax = Math.log(oddMax);

                     // Avoid division by zero if logOddMax happens to equal logOddMin (unlikely with chosen values)
                     if (logOddMax > logOddMin) {
                          // Calculate the score on a scale from scoreMin to scoreMax
                         score = scoreMin + (scoreMax - scoreMin) * (logOdd - logOddMin) / (logOddMax - logOddMin);
                     } else {
                         // Fallback if min/max odds are too close or equal
                         score = (odd >= oddMin) ? scoreMax : scoreMin;
                     }

                     // Round up to the nearest integer and clamp between min/max scores
                     score = Math.ceil(score);
                     score = Math.max(scoreMin, Math.min(score, scoreMax));
                 }

                 const boldText = document.createElement('b');
                 boldText.textContent = score;
                 calculationCell.appendChild(boldText);
             } else {
                 calculationCell.textContent = "-"; // Placeholder if odd is not a number
             }
             row.appendChild(textCell);
             row.appendChild(numberCell);
             row.appendChild(calculationCell);
             tbody.appendChild(row);
         }


        // *** NEW FUNCTION: Applies title search to VISIBLE tables ***
        function applyTitleSearchToVisibleTables() {
            const searchInput = document.getElementById("searchSubcategoryInput");
            if (!searchInput) return; // Exit if search input doesn't exist yet

            const searchTerm = searchInput.value.toLowerCase().trim();
            // Only select tables that are NOT currently display:none (i.e., visible after category filter)
            const visibleTables = document.querySelectorAll("#settings-popup #outputTables table:not([style*='display: none'])");

            visibleTables.forEach(table => {
                const headerCell = table.querySelector('thead th[colspan="3"]'); // Get the main header cell
                let matchesSearch = true; // Assume match if search term is empty

                if (headerCell && searchTerm !== '') { // Check only if search term exists
                    const headerText = headerCell.textContent.toLowerCase();
                    matchesSearch = headerText.includes(searchTerm);
                }

                // Hide the table if it doesn't match the search term
                if (!matchesSearch) {
                    table.style.display = 'none';
                }
                // No 'else' needed: if it matches, it remains visible (as it was selected by the querySelector)
            });
        }


         // Make filterTables globally accessible on the window object
         // This function now handles BOTH category and title search filtering
         window.filterTables = function() {
             var selectedCategoryValue = document.getElementById("categoryFilter").value;
             var tables = document.querySelectorAll("#settings-popup #outputTables table");

             // 1. Apply Category Filter First
             tables.forEach(function(table) {
                 const tableCategory = table.getAttribute('data-category');
                 if (selectedCategoryValue === 'all' || tableCategory === selectedCategoryValue) {
                     table.style.display = ''; // Show table based on category
                 } else {
                     table.style.display = 'none'; // Hide table based on category
                 }
             });

             // 2. Apply Title Search Filter to the result of the Category Filter
             applyTitleSearchToVisibleTables();
         }


        // *** MODIFIED: Define the Regex for the pattern ***
        const teamScoresOneHalfRegex = /^(.+)\s+to score in only one of halves$/i; // i for case-insensitive

        // Make convertToTable globally accessible on the window object
        window.convertToTable = function() {
            var inputText = document.getElementById("inputTextArea").value;
            var lines = inputText.split('\n');
            var outputDiv = document.getElementById("outputTables");
            outputDiv.innerHTML = ''; // Clear previous tables
            // *** Reset search input when creating new tables ***
            const searchInput = document.getElementById("searchSubcategoryInput");
            if (searchInput) searchInput.value = '';


            let allParsedBlocks = [];
            let currentBlockData = null;
            const playersPrefix = "Players:";
            const playersCategory = "16. Jogadores (Totais)";

            // --- Pass 1: Parse ALL blocks and classify ---
            for (const line of lines) {
                let trimmedLine = line.trim();

                // Skip ignored phrases and special characters/empty lines
                if (ignorePhrases.has(trimmedLine) || ["√ô", "√É", "√Å", ""].includes(trimmedLine) || trimmedLine.length === 0) {
                    continue;
                }

                let isHeader = false;
                let potentialHeader = null; // The exact line matched
                let canonicalHeader = null; // The consistent internal name
                let mainCategory = null;
                let isSpecial = false;
                let isPatternMatch = false; // Flag for our specific pattern

                // *** MODIFIED: Check for the pattern FIRST ***
                const patternMatch = trimmedLine.match(teamScoresOneHalfRegex);
                if (patternMatch) {
                    isHeader = true;
                    potentialHeader = trimmedLine; // Store the original line ("Verona...")
                    canonicalHeader = "Pattern: Team Scores Only One Half"; // Assign canonical name
                    mainCategory = categoryMap[canonicalHeader]; // Get filter category from map
                    isSpecial = false; // Not special in the sense of principal/alternative classification
                    isPatternMatch = true; // Set our flag
                }
                // --- End pattern check ---
                else if (trimmedLine.startsWith(playersPrefix)) { // Check Players next
                    isHeader = true;
                    potentialHeader = trimmedLine;
                    canonicalHeader = potentialHeader; // For players, original = canonical for now
                    mainCategory = playersCategory;
                    isSpecial = false;
                } else if (specialCategories.has(trimmedLine)) { // Check Special categories
                    isHeader = true;
                    potentialHeader = trimmedLine;
                    canonicalHeader = potentialHeader;
                    mainCategory = categoryMap[potentialHeader] || "Outras Categorias Especiais";
                    isSpecial = true;
                } else if (categories.includes(trimmedLine)) { // Check Standard categories
                    isHeader = true;
                    potentialHeader = trimmedLine;
                    canonicalHeader = potentialHeader;
                    mainCategory = categoryMap[potentialHeader] || "Outras Categorias";
                    isSpecial = false;
                }

                // Process block change or add content
                if (isHeader) {
                    // Finalize the previous block
                    if (currentBlockData && currentBlockData.pairs.length > 0) {
                         if (currentBlockData.isSpecial && !currentBlockData.isPatternMatch) { // Only classify non-pattern specials
                              currentBlockData.classification = classifySpecialBlock(currentBlockData.header, currentBlockData.pairs);
                         }
                         allParsedBlocks.push(currentBlockData);
                    }
                    // Start a new block
                    currentBlockData = {
                        header: potentialHeader,         // Original matched text
                        canonicalHeader: canonicalHeader, // Consistent internal name
                        pairs: [],
                        mainCategory: mainCategory,
                        isSpecial: isSpecial,           // For principal/alternative logic
                        isPatternMatch: isPatternMatch, // Our specific pattern flag
                        classification: 'standard',
                        pendingOption: null
                    };
                } else if (currentBlockData) { // Add option/odd pair
                    if (currentBlockData.pendingOption === null) {
                        currentBlockData.pendingOption = trimmedLine;
                    } else {
                        if (isOddNumber(trimmedLine)) {
                            currentBlockData.pairs.push([currentBlockData.pendingOption, trimmedLine]);
                            currentBlockData.pendingOption = null;
                        } else {
                            // Discard previous pending option, assume this is the new option
                            // console.log("Discarding pending:", currentBlockData.pendingOption, "- next line not an odd:", trimmedLine);
                            currentBlockData.pendingOption = trimmedLine;
                        }
                    }
                }
            } // End loop through lines

            // Finalize the last block
            if (currentBlockData && currentBlockData.pairs.length > 0) {
                 if (currentBlockData.isSpecial && !currentBlockData.isPatternMatch) {
                      currentBlockData.classification = classifySpecialBlock(currentBlockData.header, currentBlockData.pairs);
                 }
                allParsedBlocks.push(currentBlockData);
            }

            // --- Pass 2: Filter and Render based on rules ---
            let renderedNormal = new Set();
            let renderedSpecialPrincipal = new Set();
            let renderedSpecialAlternative = new Set();
            // *** NEW: Set to track rendered *original headers* for our specific pattern ***
            let renderedTeamScoreOneHalfHeaders = new Set();

            for (const block of allParsedBlocks) {
                // Destructure block data, including the new flags/fields
                const { header, canonicalHeader, pairs, mainCategory, isSpecial, isPatternMatch, classification } = block;

                 if (!mainCategory) {
                     console.warn("Skipping block with missing mainCategory:", header);
                     continue;
                 }

                let displayHeader = header; // Default display header is the original matched text
                 if (header.startsWith(playersPrefix)) {
                    displayHeader = header.substring(playersPrefix.length).trim();
                    if (!displayHeader) displayHeader = "Jogador - Geral";
                 }

                let table = null;

                // *** MODIFIED: Handle our pattern rendering ***
                if (isPatternMatch) {
                    // Check if this *specific original header* (e.g., "Verona...") has been rendered *for this pattern*
                    if (!renderedTeamScoreOneHalfHeaders.has(header)) {
                        renderedTeamScoreOneHalfHeaders.add(header); // Mark this specific team/line as rendered
                        table = createCategoryTable(displayHeader); // Use original header for display
                        table.setAttribute('data-original-category', header);
                        table.setAttribute('data-canonical-category', canonicalHeader); // Store canonical name too if needed
                        table.setAttribute('data-category', mainCategory); // Use mapped category for filtering
                        pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                        outputDiv.appendChild(table);
                    }
                // --- End pattern rendering ---
                } else if (!isSpecial) { // Standard or Player category (not our pattern)
                    if (!renderedNormal.has(header)) { // Check original header for uniqueness
                        renderedNormal.add(header);
                        table = createCategoryTable(displayHeader); // Use potentially modified player header
                        table.setAttribute('data-original-category', header);
                        table.setAttribute('data-category', mainCategory);
                        pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                        outputDiv.appendChild(table);
                    }
                } else { // Special Category (Total, Handicap, etc. - not our pattern)
                    if (classification === 'principal') {
                        if (!renderedSpecialPrincipal.has(header)) {
                            renderedSpecialPrincipal.add(header);
                            table = createCategoryTable(displayHeader);
                            table.setAttribute('data-original-category', header);
                            table.setAttribute('data-category', mainCategory);
                            pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                            outputDiv.appendChild(table);
                        }
                    } else if (classification === 'alternative') {
                        if (!renderedSpecialAlternative.has(header)) {
                            renderedSpecialAlternative.add(header);
                            table = createCategoryTable(displayHeader + ""); // Suffix was empty, keep it that way unless needed
                            table.setAttribute('data-original-category', header);
                            table.setAttribute('data-category', mainCategory);
                            pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                            outputDiv.appendChild(table);
                        }
                    } else { // Fallback 'standard' for special
                         if (!renderedSpecialPrincipal.has(header)) { // Treat fallback as principal
                             renderedSpecialPrincipal.add(header);
                             table = createCategoryTable(displayHeader);
                             table.setAttribute('data-original-category', header);
                             table.setAttribute('data-category', mainCategory);
                             pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                             outputDiv.appendChild(table);
                         }
                    }
                }
            } // End loop through parsed blocks

            // Apply initial filtering (category + potentially empty search term) after creating tables
            window.filterTables();

            // *** Add Event Listener for Search Input AFTER tables are created ***
            const searchInputForTitles = document.getElementById("searchSubcategoryInput");
            if (searchInputForTitles) {
                 // Remove previous listener if any to avoid duplicates (optional but safer)
                 // searchInputForTitles.removeEventListener('input', window.filterTables);
                 searchInputForTitles.addEventListener('input', window.filterTables); // Trigger combined filter on input
            } else {
                console.warn("Search input ('searchSubcategoryInput') not found after table creation.");
            }

        } // End of convertToTable function

    })(); // End of converter's self-executing anonymous function
    </script>
    <!-- == CONVERTER JAVASCRIPT END == -->

</body>
</html>
