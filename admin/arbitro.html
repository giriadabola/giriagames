<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Árbitro - G EMPIRE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .top-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 12px 0;
            display: flex;
            justify-content: center;
            gap: 24px;
            align-items: center;
            z-index: 1000; /* Existing z-index */
        }

        .menu-item {
            text-decoration: none;
            color: #666;
            transition: color 0.3s ease;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        .menu-item:hover, .menu-item.active {
            color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }

        .menu-item i {
            font-size: 16px;
        }

        .content {
            padding: 80px 20px 20px; /* Adjusted top padding accounts for menu */
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }

        .predictions-list {
            display: grid;
            gap: 20px;
            margin-top: 20px;
        }

        .prediction-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .prediction-teams {
            font-weight: bold;
            color: #333;
        }

        .prediction-date {
            color: #666;
            font-size: 0.9em;
        }

        .prediction-values {
            display: grid;
            gap: 10px;
            margin-top: 10px;
        }

        .prediction-value {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .prediction-points {
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 7px;
        }

        .points-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            text-align: center;
            margin-right: 8px;
        }

        .points-input:focus {
            border-color: #28a745;
            outline: none;
        }

        .status-select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .status-select option {
            padding: 4px 8px;
        }

        .status-select.neutro {
            color: #666;
            border-color: #ddd;
        }

        .status-select.acerto {
            color: #28a745;
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }

        .status-select.falha {
            color: #dc3545;
            border-color: #dc3545;
            background-color: rgba(220, 53, 69, 0.1);
        }

        .prediction-label {
            color: #666;
        }

        .prediction-number {
            font-weight: bold;
        }

        .prediction-number.neutro {
            color: #333;
            }

        .prediction-number.acerto {
            color: #28a745;
        }

        .prediction-number.falha {
            color: #dc3545;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .filter-container {
            margin-bottom: 20px;
            text-align: center;
        }

        .round-filter {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
            color: #333;
            background-color: white;
            cursor: pointer;
            outline: none;
        }

        .round-filter:hover, .gplayer-filter:hover {
            border-color: #28a745;
        }

        .filter-container {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .gplayer-filter {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
            color: #333;
            background-color: white;
            cursor: pointer;
            outline: none;
        }

        .launch-button {
            padding: 8px 16px;
            border: 1px solid #28a745;
            border-radius: 4px;
            font-size: 1em;
            color: white;
            background-color: #28a745;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .launch-button:hover {
            background-color: #218838;
            border-color: #1e7e34;
        }

        #launch-status-icons {
            margin-left: 8px; /* Adjust spacing as needed */
            display: inline-flex; /* Align icons nicely with the button */
            align-items: center;
        }

        #launch-status-icons i {
            margin-right: 4px; /* Spacing between icons if needed */
        }

        .loading-icon {
            display: none; /* Initially hidden */
            color: #007bff; /* Example loading icon color */
            animation: spin 1s linear infinite; /* Optional spinning animation */
        }

        .success-icon {
            display: none; /* Initially hidden */
            color: #28a745; /* Success icon color (green) */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* --- NEW CSS FOR GEAR ICON AND POPUP --- */
        #settings-icon-container {
            position: fixed;
            /* Estimate top based on content padding-top, adjust as needed */
            top: 85px;
            right: 25px;
            z-index: 999; /* Below menu (1000), above content */
            cursor: pointer;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.5); /* Slight background */
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        #settings-icon-container i {
            font-size: 22px; /* Adjust size as needed */
            color: #555;
            display: block; /* Prevents tiny layout shifts */
            transition: color 0.3s ease;
        }

        #settings-icon-container:hover i {
            color: #28a745; /* Use theme color on hover */
        }
         #settings-icon-container:hover {
            background-color: rgba(255, 255, 255, 0.8); /* More opaque on hover */
        }


        #settings-popup {
    display: none;
    position: fixed;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 500px;
    max-height: calc(80vh - 60px); /* Reduz altura máxima para dar espaço ao ícone */
    background-color: white;
    padding: 25px;
    border-radius: 8px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    z-index: 1001;
    overflow-y: auto;
    cursor: grab; /* Use grab cursor to indicate draggable */
}

        #settings-popup:active {
            cursor: grabbing; /* Change cursor when actively dragging */
        }

        #settings-popup h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
            font-size: 1.2em;
        }

        #popup-close {
            position: auto;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
            transition: color 0.3s ease;
            z-index: 1002; /* Ensure close button is above popup content */
        }

        #popup-close:hover {
            color: #333;
        }

        /* --- NEW CSS FOR SCROLLABLE CLOSE ICON --- */
        #popup-close-scrollable {
    position: sticky; /* Alterado para absolute */
    bottom: 20px;
    right: 35px;
    font-size: 24px;
    color: #aaa;
    cursor: pointer;
    line-height: 1;
    transition: color 0.3s ease;
    z-index: 1002;
    background-color: white;
    border-radius: 50%;
    width: 30px;
    height: 30px;
    text-align: center;
    padding: 5px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
}

        #popup-close-scrollable:hover {
            color: #333;
        }

        /* Ensure close buttons are still interactive */
        #popup-close, #popup-close-scrollable {
            cursor: pointer; /* Re-set cursor for close buttons */
        }
        /* --- END OF NEW CSS FOR SCROLLABLE CLOSE ICON --- */


        /* --- ESTILOS DO CÓDIGO 2 COLADOS AQUI --- */
        table {
          border-collapse: collapse;
          width: 100%;
          margin-bottom: 20px;
        }
        th, td {
          border: 1px solid black;
          padding: 8px;
          text-align: left;
        }
        th {
          background-color: #f2f2f2;
          text-align: center;
        }
        td:nth-child(2),
        td:nth-child(3) {
          text-align: right;
        }

        .filter-container {
          display: flex;
          justify-content: flex-end;
          align-items: center;
          margin-bottom: 10px;
          width: 100%;
          max-width: 350px;
          margin-left: auto;
          margin-right: auto;
        }

        .filter-container label {
          margin-right: 10px;
        }

        /* NOVAS PROPRIEDADES ADICIONADAS */
        #inputTextArea {
            max-width: 100%;
            box-sizing: border-box;
            max-height: 70px; /* REDUCED HEIGHT OF TEXTAREA */
        }

        #categoryFilter {
            width: auto;
            max-width: 100%;
            box-sizing: border-box;
        }
        /* FIM DAS NOVAS PROPRIEDADES ADICIONADAS */

        /* --- FIM DOS ESTILOS DO CÓDIGO 2 --- */


    </style>
</head>
<body>
    <nav class="top-menu">
        <a href="engrenagem.html" class="menu-item"><i class="fas fa-home"></i></a>
        <a href="criar-gplayer.html" class="menu-item"><i class="fas fa-plus"></i> CRIAR</a>
        <a href="editar-gplayer.html" class="menu-item"><i class="fas fa-edit"></i> EDITAR</a>
        <a href="gerenciar-jogadores.html" class="menu-item"><i class="fas fa-users"></i> JOGADORES LIVE</a>
    </nav>

    <!-- --- NEW HTML FOR GEAR ICON --- -->
    <div id="settings-icon-container" title="Configurações">
        <i class="fas fa-cog"></i>
    </div>
    <!-- --- END OF NEW HTML FOR GEAR ICON --- -->

    <!-- --- NEW HTML FOR POPUP (Initially Hidden) --- -->
    <div id="settings-popup">
        <span id="popup-close" title="Fechar">×</span> <!-- ORIGINAL CLOSE ICON (TOP RIGHT) -->

        <!-- --- NEW SCROLLABLE CLOSE ICON (BOTTOM RIGHT) --- -->
        <span id="popup-close-scrollable" title="Fechar"><i class="fas fa-times"></i></span>
        <!-- --- END OF NEW SCROLLABLE CLOSE ICON --- -->


        <h2>Colar Bets</h2>
        <!-- Conteúdo do código 2 colado AQUI -->

        <textarea id="inputTextArea" rows="10" cols="40" placeholder="Enter text here"></textarea> <br><br>
        <button onclick="window.convertToTable()">Convert to Table</button>

        <div class="filter-container">
          <select id="categoryFilter" onchange="window.filterTables()">
            <option value="all">All Categories</option>
            <option value="Resultado da Partida (Match Result)">Resultado da Partida (Match Result)</option>
            <option value="Gols (Goals)">Gols (Goals)</option>
            <option value="Ambas as Equipes Marcam (Both Teams To Score - BTTS)">Ambas as Equipes Marcam (Both Teams To Score - BTTS)</option>
            <option value="Intervalos e Metades (Halves & Intervals)">Intervalos e Metades (Halves & Intervals)</option>
            <option value="Placar Correto (Correct Score)">Placar Correto (Correct Score)</option>
            <option value="Escanteios (Corners)">Escanteios (Corners)</option>
            <option value="Cartões e Disciplina (Bookings & Discipline)">Cartões e Disciplina (Bookings & Discipline)</option>
            <option value="Marcadores de Gol (Goalscorers)">Marcadores de Gol (Goalscorers)</option>
            <option value="Limpeza de Gol (Clean Sheet)">Limpeza de Gol (Clean Sheet)</option>
            <option value="Apostas Combinadas (Combined Bets)">Apostas Combinadas (Combined Bets)</option>
            <option value="Ímpar/Par (Odd/Even)">Ímpar/Par (Odd/Even)</option>
          </select>
        </div>

        <div id="outputTables"></div>
        <!-- Fim do conteúdo do código 2 -->
    </div>
    <!-- --- END OF NEW HTML FOR POPUP --- -->


    <div class="content">
        <h1>Árbitro</h1>
        <div class="filter-container">
            <select id="round-filter" class="round-filter">
                <option value="">Todas as Rondas</option>
            </select>
            <select id="game-filter" class="round-filter">
                <option value="">Todos os Jogos</option>
            </select>
            <select id="gplayer-filter" class="gplayer-filter">
                <option value="">Todos os GPlayers</option>
            </select>
            <button id="launch-button" class="launch-button">Lançar</button><span id="launch-status-icons"></span>
        </div>
        <div id="predictions-container" class="predictions-list">
            <div class="loading">Carregando palpites...</div>
        </div>
    </div>

    <script type="module">
        // --- EXISTING FIREBASE JAVASCRIPT MODULE (UNCHANGED) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getFirestore, collection, getDocs, doc, getDoc, updateDoc, where, addDoc, serverTimestamp, getCountFromServer, query, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

         const firebaseConfig = {
             apiKey: "AIzaSyD8WcFD7jC55feYYqdY7aJSgxXyXkEjTX0",
             authDomain: "g-games-8a8fc.firebaseapp.com",
             projectId: "g-games-8a8fc",
             storageBucket: "g-games-8a8fc.firebasestorage.app",
             messagingSenderId: "689897349449",
             appId: "1:689897349449:web:536599794579901beb7a98",
             measurementId: "G-GTTPJ6G5MD"
         };

         // Initialize Firebase
         const app = initializeApp(firebaseConfig);
         const db = getFirestore(app);

         // Initialize state variables
         let currentRound = null;
         let currentGame = null;
         let currentGPlayer = null;
         let allPredictions = [];
         let isProcessingLaunch = false; // Flag to track processing state

         async function loadPredictions() {
             try {
                 const predictionsContainer = document.getElementById('predictions-container');
                 const roundFilter = document.getElementById('round-filter');
                 const palpitesSnapshot = await getDocs(collection(db, 'palpites'));

                 // Store all predictions
                 allPredictions = [];
                 const rounds = new Set();
                 const gplayers = new Set();

                 if (palpitesSnapshot.empty) {
                     predictionsContainer.innerHTML = '<div class="prediction-card">Nenhum palpite encontrado.</div>';
                     return;
                 }

                 // Collect all predictions and rounds
                 for (const palpiteDoc of palpitesSnapshot.docs) {
                     const palpite = palpiteDoc.data();
                     if (palpite.ronda) {
                         rounds.add(palpite.ronda);
                     }
                     if (palpite.nomeDeUsuario) {
                         gplayers.add(palpite.nomeDeUsuario);
                     }
                     allPredictions.push({
                         id: palpiteDoc.id,
                         ...palpite
                     });
                 }

                 // Update round filter options
                 const sortedRounds = Array.from(rounds).sort((a, b) => b - a); // Sort in descending order
                 roundFilter.innerHTML = '<option value="">Todas as Rondas</option>';
                 sortedRounds.forEach(round => {
                     roundFilter.innerHTML += `<option value="${round}">Ronda ${round}</option>`;
                 });

                 // Update game filter based on selected round
                 function updateGameFilter() {
                     const gameFilter = document.getElementById('game-filter');
                     const filteredByRound = currentRound ? allPredictions.filter(p => p.ronda === currentRound) : allPredictions;
                     const games = new Set(filteredByRound.map(p => p.nomeJogo).filter(Boolean));
                     const sortedGames = Array.from(games).sort();

                     gameFilter.innerHTML = '<option value="">Todos os Jogos</option>';
                     sortedGames.forEach(game => {
                         // Extract only team names from the game string by removing date and round info
                         const teamNames = game.split('-')[0].trim(); // This will keep only the "EquipaA vs EquipaB" part
                         gameFilter.innerHTML += `<option value="${game}">${teamNames}</option>`;
                     });
                     gameFilter.value = currentGame || '';
                 }

                 // Event listener for round filter
                 document.getElementById('round-filter').addEventListener('change', (e) => {
                     currentRound = e.target.value === "" ? null : Number(e.target.value);
                     currentGame = null; // Reset game selection when round changes
                     updateGameFilter();
                     loadPredictions();
                 });

                 // Event listener for game filter
                 document.getElementById('game-filter').addEventListener('change', (e) => {
                     currentGame = e.target.value || null;
                     loadPredictions();
                 });

                 // Event listener for gplayer filter
                 document.getElementById('gplayer-filter').addEventListener('change', (e) => {
                     currentGPlayer = e.target.value || null;
                     loadPredictions();
                 });

                 // Set default round to highest when page loads for the first time
                 if (sortedRounds.length > 0 && currentRound === null) {
                     currentRound = sortedRounds[0];
                     roundFilter.value = currentRound;
                 } else {
                     // Maintain the selected round in the dropdown
                     roundFilter.value = currentRound || '';
                 }

                 updateGameFilter();
                 // Update GPlayer filter options
                 const gplayerFilter = document.getElementById('gplayer-filter');
                 const sortedGPlayers = Array.from(gplayers).sort();
                 gplayerFilter.innerHTML = '<option value="">Todos os GPlayers</option>';
                 sortedGPlayers.forEach(gplayer => {
                     if (gplayer) { // Only add non-empty GPlayer names
                         gplayerFilter.innerHTML += `<option value="${gplayer}">${gplayer}</option>`;
                     }
                 });
                 gplayerFilter.value = currentGPlayer || '';

                 // Filter predictions by selected round, game, and GPlayer
                 let filteredPredictions = allPredictions;

                 if (currentRound) {
                     filteredPredictions = filteredPredictions.filter(p => p.ronda === currentRound);
                 }

                 if (currentGame) {
                     filteredPredictions = filteredPredictions.filter(p => p.nomeJogo === currentGame);
                 }

                 if (currentGPlayer) {
                     filteredPredictions = filteredPredictions.filter(p => p.nomeDeUsuario === currentGPlayer);
                 }

                 let predictionsHTML = '';

                 for (const palpite of filteredPredictions) {
                     try {
                         // Verificar se jogoId existe
                         if (!palpite.jogoId) {
                             console.warn('Palpite sem jogoId encontrado:', palpite);
                             continue; // Pular este palpite
                         }

                         const jogoDoc = await getDoc(doc(db, 'jogos', palpite.jogoId));

                         // Verificar se o documento do jogo existe
                         if (!jogoDoc.exists()) {
                             console.warn(`Jogo com ID ${palpite.jogoId} não encontrado`);
                             continue; // Pular este palpite
                         }

                         const jogo = jogoDoc.data();

                         // Verificar se jogo tem as propriedades necessárias
                         if (!jogo || !jogo.equipaCasaId || !jogo.equipaForaId) {
                             console.warn(`Jogo com ID ${palpite.jogoId} tem dados incompletos:`, jogo);
                             continue; // Pular este palpite
                         }

                         // Get team names
                         const [equipaCasaDoc, equipaForaDoc] = await Promise.all([
                             getDoc(doc(db, 'clubes', jogo.equipaCasaId)),
                             getDoc(doc(db, 'clubes', jogo.equipaForaId))
                         ]);

                     // Add null checks and default values
                     const equipaCasa = equipaCasaDoc && equipaCasaDoc.exists() ? equipaCasaDoc.data()?.nome || 'Equipa Desconhecida' : 'Equipa Desconhecida';
                     const equipaFora = equipaForaDoc && equipaForaDoc.exists() ? equipaForaDoc.data()?.nome || 'Equipa Desconhecida' : 'Equipa Desconhecida';

                     // Format date - com verificação de segurança
                     let dataFormatada = 'Data não disponível';
                     try {
                         if (jogo.dataJogo && typeof jogo.dataJogo.toDate === 'function') {
                             const dataJogo = jogo.dataJogo.toDate();
                             dataFormatada = dataJogo.toLocaleDateString('pt-PT');
                         }
                     } catch (error) {
                         console.warn('Erro ao formatar data do jogo:', error);
                     }

                     // Get user name - com verificação de segurança
                     let userName = 'Usuário Desconhecido';
                     try {
                         if (palpite.userId) {
                             const userDoc = await getDoc(doc(db, 'users', palpite.userId));
                             userName = userDoc.exists() ? userDoc.data()?.nomeDeUsuario || 'Usuário Desconhecido' : 'Usuário Desconhecido';
                         }
                     } catch (error) {
                         console.warn('Erro ao buscar dados do usuário:', error);
                     }

                     // Create prediction values HTML
                     let palpitesHTML = '';
                     // Verificar se jogo.numeroPalpites existe e é um número válido
                     const numeroPalpites = jogo && typeof jogo.numeroPalpites === 'number' ? jogo.numeroPalpites : 0;
                     for (let i = 1; i <= numeroPalpites; i++) {
                         const palpiteKey = `palpite${i}`; // Mantém palpiteKey para referenciar o texto do palpite
                         const pontosKey = `Palpite${i}PontosQuanto`;
                         // Check if palpiteKey exists in palpite data before accessing it
                         if (palpite.hasOwnProperty(palpiteKey)) {
                             palpitesHTML += `
                                 <div class="prediction-value">
                                     <div class="prediction-points">
                                         <span class="prediction-label">Palpite ${i}</span>
                                         <span class="prediction-number ${palpite[`palpite${i}Status`] || 'neutro'}">${palpite[palpiteKey]}</span>  <!--- Mostra o texto do palpite -->
                                     </div>
                                     <input type="number"
                                         class="points-input"
                                         min="0"
                                         max="999"
                                         value="${palpite[pontosKey] || ''}"
                                         data-palpite-id="${palpite.id}"
                                         data-pontos-key="${pontosKey}"
                                         placeholder="Pts">
                                     <select class="status-select ${palpite[`palpite${i}Status`] || 'neutro'}"
                                         data-palpite-id="${palpite.id}"
                                         data-status-key="palpite${i}Status">
                                         <option value="neutro" ${(palpite[`palpite${i}Status`] || 'neutro') === 'neutro' ? 'selected' : ''}>Neutro</option>
                                         <option value="acerto" ${palpite[`palpite${i}Status`] === 'acerto' ? 'selected' : ''}>Acerto</option>
                                         <option value="falha" ${palpite[`palpite${i}Status`] === 'falha' ? 'selected' : ''}>Falha</option>
                                     </select>
                                 </div>`;
                         }
                     }

                     predictionsHTML += `
                         <div class="prediction-card">
                             <div class="prediction-header">
                                 <div class="prediction-teams">${equipaCasa} vs ${equipaFora}</div>
                                 <div class="prediction-date">${dataFormatada} - ${userName}</div>
                             </div>
                             <div class="prediction-values">
                                 ${palpitesHTML}
                             </div>
                         </div>`;
                     } catch (error) {
                         console.error('Erro ao processar palpite:', error, palpite);
                         // Continua para o próximo palpite
                     }
                 }

                 predictionsContainer.innerHTML = predictionsHTML;

                 // Add event listeners to status toggle buttons
                 document.querySelectorAll('.status-select').forEach(select => {
                     select.addEventListener('change', async (e) => {
                         const palpiteId = e.target.dataset.palpiteId;
                         const statusKey = e.target.dataset.statusKey;
                         const newStatus = e.target.value;

                         try {
                             const palpiteRef = doc(db, 'palpites', palpiteId);
                             const updateData = {};
                             updateData[statusKey] = newStatus; // Atualiza usando statusKey correto

                             await updateDoc(palpiteRef, updateData);

                             // Update select appearance
                             e.target.className = `status-select ${newStatus}`;
                             const predictionNumber = e.target.closest('.prediction-value').querySelector('.prediction-number');
                             predictionNumber.className = `prediction-number ${newStatus}`;
                         } catch (error) {
                             console.error('Error updating status:', error);
                             alert('Erro ao atualizar o status. Por favor, tente novamente.');
                         }
                     });
                 });

                 document.querySelectorAll('.points-input').forEach(input => {
                     input.addEventListener('change', async (e) => {
                         const palpiteId = e.target.dataset.palpiteId;
                         const pontosKey = e.target.dataset.pontosKey; // Usa pontosKey correto
                         const value = e.target.value;

                         if (value && (value < 0 || value > 999)) {
                             alert('Por favor, insira um número entre 0 e 999.');
                             e.target.value = '';
                             return;
                         }

                         try {
                             const palpiteRef = doc(db, 'palpites', palpiteId);
                             const updateData = {};
                             updateData[pontosKey] = value ? parseInt(value) : 0; // Atualiza usando pontosKey correto
                             console.log("pontosKey:", pontosKey);
                             console.log("updateData:", updateData);
                             await updateDoc(palpiteRef, updateData);
                             console.log(`Updated ${pontosKey} with value:`, value);
                         } catch (error) {
                             console.error('Error updating points:', error);
                             alert('Erro ao atualizar os pontos. Por favor, tente novamente.');
                             // Revert the input value to its previous state
                             const palpiteDoc = await getDoc(palpiteRef);
                             if (palpiteDoc.exists()) {
                                 e.target.value = palpiteDoc.data()[pontosKey] || '';
                             }
                         }
                     });
                 });
             } catch (error) {
                 console.error('Error loading predictions:', error);
                 document.getElementById('predictions-container').innerHTML =
                     '<div class="prediction-card">Erro ao carregar palpites. Por favor, tente novamente mais tarde.</div>';
             }
         }

         document.getElementById('launch-button').addEventListener('click', async () => {
            const launchButton = document.getElementById('launch-button');
            const statusIconsSpan = document.getElementById('launch-status-icons');

            // Create and display loading icon
            statusIconsSpan.innerHTML = '<i class="fas fa-spinner fa-spin loading-icon"></i>';
            const loadingIcon = statusIconsSpan.querySelector('.loading-icon');
            loadingIcon.style.display = 'inline-block'; // Show loading icon

            launchButton.disabled = true; // Disable button during processing
            isProcessingLaunch = true; // Set processing flag to true

            try {
                const predictions = document.querySelectorAll('.prediction-card');
                let updateCount = 0;
                const userAggregatedData = {};

                const currentUserId = 'ADMIN_USER_ID'; // PLACEHOLDER -  IMPLEMENTE A SUA LÓGICA AQUI

                for (const predictionCard of predictions) {
                    const predictionValues = predictionCard.querySelectorAll('.prediction-value');
                    let cardTotalPontosGanhosForMovimento = 0;
                    let cardTotalPontosPossiveis = 0;
                    let cardTotalPontosGanhos = 0;
                    let currentGameTemporada = null;
                    let currentGameCardUserId = null;
                    let currentGameNomeJogo = null;

                    for (const value of predictionValues) {
                        const select = value.querySelector('.status-select');
                        const input = value.querySelector('.points-input');
                        const palpiteId = select.dataset.palpiteId;

                        const palpiteDocSnap = await getDoc(doc(db, 'palpites', palpiteId));
                        const palpiteData = palpiteDocSnap.data();
                        currentGameCardUserId = palpiteData.userId;
                        currentGameTemporada = palpiteData.temporada;
                        currentGameNomeJogo = palpiteData.nomeJogo;


                        const pontosKey = input.dataset.pontosKey;
                        const palpiteNumber = pontosKey.match(/\d+/)[0];
                        const pontosValue = input ? parseInt(input.value) || 0 : 0;
                        const status = select.value;

                        const palpiteRef = doc(db, 'palpites', palpiteId);
                        const updateData = {};

                        updateData[pontosKey] = pontosValue;

                        let pontosGanhosValue = 0;
                        if (status === 'acerto') {
                            pontosGanhosValue = pontosValue;
                            cardTotalPontosGanhos += pontosValue;
                        }
                        const pontosGanhosKey = `Palpite${palpiteNumber}PontosGanhos`;
                        updateData[pontosGanhosKey] = pontosGanhosValue;
                        const gCoinsGanhosKey = `Palpite${palpiteNumber}GCoinsGanhos`;
                        updateData[gCoinsGanhosKey] = pontosGanhosValue;
                        updateData["Analisado"] = "Sim";

                        cardTotalPontosPossiveis += pontosValue;

                        await updateDoc(palpiteRef, updateData);
                        updateCount++;

                        cardTotalPontosGanhosForMovimento += pontosGanhosValue;
                        // --- REMOVED - Criação do documento "movimentos" daqui ---
                    } // --- END OF PREDICTION VALUE LOOP ---

                    // --- INÍCIO DO PASSO 5.1: Criar/Editar documento em "movimentos" (AGORA FORA DO LOOP DE PALPITES INDIVIDUAIS) ---
                    // Debugging logs START
                    const firstPredictionValue = predictionCard.querySelector('.prediction-value');
                    const firstPalpiteId = firstPredictionValue.querySelector('.status-select').dataset.palpiteId;
                    const firstPalpiteDocSnap = await getDoc(doc(db, 'palpites', firstPalpiteId));
                    const firstPalpiteData = firstPalpiteDocSnap.data();

                    console.log("predictionCard:", predictionCard);
                    console.log("firstPredictionValue:", firstPredictionValue);
                    console.log("firstPalpiteId:", firstPalpiteId);
                    console.log("firstPalpiteDocSnap:", firstPalpiteDocSnap);
                    console.log("firstPalpiteData:", firstPalpiteData);
                    // Debugging logs END


                    // Check if movimento with nomeJogo already exists
                    const movimentoQuery = query(collection(db, 'movimentos'), where("nomeJogo", "==", currentGameNomeJogo), limit(1));
                    const movimentoSnapshot = await getDocs(movimentoQuery);
                    let movimentoRefToUpdate;

                    const movimentoData = {
                        "de": currentUserId,
                        "estado": "Palpite Paid",
                        "jogadorId": null,
                        "mediapontos": null,
                        "movimentoData": serverTimestamp(),
                        "para": currentGameCardUserId,
                        "posicao": null,
                        "preco": cardTotalPontosGanhosForMovimento,
                        "temporada": currentGameTemporada.replace('/', ''),
                        "userId": currentGameCardUserId,
                        "valorreal": cardTotalPontosGanhosForMovimento,
                        "nomeJogo": currentGameNomeJogo
                    };


                    if (!movimentoSnapshot.empty) {
                        // Document exists, get ref for update
                        movimentoRefToUpdate = doc(db, 'movimentos', movimentoSnapshot.docs[0].id);
                        try {
                            await updateDoc(movimentoRefToUpdate, movimentoData);
                            console.log('Documento "movimentos" ATUALIZADO com sucesso para o JOGO (cartão de palpite). Nome Jogo:', currentGameNomeJogo, 'Pontos Ganhos Totais:', cardTotalPontosGanhosForMovimento);
                        } catch (error) {
                            console.error('Erro ao ATUALIZAR documento em "movimentos" (POR JOGO):', error);
                            alert('Erro ao atualizar documento de movimento (por jogo). Veja o console para detalhes.');
                        }


                    } else {
                        // Document does not exist, create new
                        try {
                            await addDoc(collection(db, 'movimentos'), movimentoData);
                            console.log('Documento "movimentos" CRIADO com sucesso para o JOGO (cartão de palpite). Pontos Ganhos Totais:', cardTotalPontosGanhosForMovimento);
                        } catch (error) {
                            console.error('Erro ao CRIAR documento em "movimentos" (POR JOGO):', error);
                            alert('Erro ao criar documento de movimento (por jogo). Veja o console para detalhes.');
                        }
                    }
                    // --- FIM DO PASSO 5.1: Criar/Editar documento em "movimentos" (POR JOGO) ---


                    // --- AGGREGATE DATA PER USER ---
                    if (currentGameCardUserId && currentGameTemporada) { // Changed to currentGameTemporada
                        if (!userAggregatedData[currentGameCardUserId]) {
                            userAggregatedData[currentGameCardUserId] = {
                                totalPontosPossiveis: 0,
                                totalPontosGanhos: 0,
                                temporada: currentGameTemporada // Changed to currentGameTemporada
                            };
                        }
                        userAggregatedData[currentGameCardUserId].totalPontosPossiveis += cardTotalPontosPossiveis;
                        userAggregatedData[currentGameCardUserId].totalPontosGanhos += cardTotalPontosGanhos;
                        // GCoinsGanhos will be calculated from movimentos later
                    }
                    // --- USER DATA AGGREGATION END ---


                } // --- END OF PREDICTION CARD LOOP ---


                // --- UPDATE USER DOCUMENTS WITH AGGREGATED DATA and GCOINS from MOVIMENTOS ---
                for (const userId in userAggregatedData) {
                    const userData = userAggregatedData[userId];
                    const userRef = doc(db, 'users', userId);

                    const temporadaPontosFieldName = `${userData.temporada.replace('/', '')}Pontos`;
                    const temporadaGCoinsFieldName = `${userData.temporada.replace('/', '')}GCoins`;
                    const temporadaPontosPossiveisFieldName = `${userData.temporada.replace('/', '')}PontosPossiveis`;

                    const temporadaFormatted = userData.temporada.replace('/', '');

                    // Query movimentos to sum valorreal for GCoinsGanhos
                    const movimentosQuery = query(collection(db, 'movimentos'),
                        where("userId", "==", userId),
                        where("temporada", "==", temporadaFormatted)
                    );

                    const movimentosSnapshot = await getCountFromServer(movimentosQuery);
                    let totalGCoinsGanhosFromMovimentos = 0;
                    const movimentosDocs = await getDocs(movimentosQuery);
                    movimentosDocs.forEach(doc => {
                        const movimentoData = doc.data();
                        totalGCoinsGanhosFromMovimentos += movimentoData.valorreal || 0; // Sum valorreal
                    });


                    const userUpdateData = {
                        [temporadaPontosFieldName]: (userData.totalPontosGanhos || 0),
                        [temporadaGCoinsFieldName]: totalGCoinsGanhosFromMovimentos, // GCoins from movimentos sum
                        [temporadaPontosPossiveisFieldName]: (userData.totalPontosPossiveis || 0)
                    };
                    await updateDoc(userRef, userUpdateData);
                }
                // --- USER DOCUMENTS UPDATE END ---

                // Success: Display success icon and remove loading icon
                statusIconsSpan.innerHTML = '<i class="fas fa-check-circle success-icon"></i>';
                const successIcon = statusIconsSpan.querySelector('.success-icon');
                successIcon.style.display = 'inline-block'; // Show success icon
                loadingIcon.style.display = 'none'; // Hide loading icon (if it's still somehow visible)


                // Remove success icon after 3 seconds
                setTimeout(() => {
                    statusIconsSpan.innerHTML = ''; // Clear the status icons span
                    launchButton.disabled = false; // Re-enable button
                    isProcessingLaunch = false; // Set processing flag to false (after success)
                }, 3000); // 3000 milliseconds = 3 seconds


            } catch (error) {
                console.error('Error updating predictions and user points/GCoins/PontosPossiveis (userId correto) and movimentos (POR JOGO) and GCOINS:', error);
                alert('Erro ao atualizar os palpites, pontos/GCoins/PontosPossiveis de usuário e movimentos (por jogo) e GCOINS. Por favor, tente novamente.');

                // Error: Remove loading icon and re-enable button (no success icon in case of error)
                if (statusIconsSpan.querySelector('.loading-icon')) { // Check if loading icon exists before trying to hide
                    statusIconsSpan.querySelector('.loading-icon').style.display = 'none';
                }
                statusIconsSpan.innerHTML = ''; // Optionally clear any status icons in case of error.
                launchButton.disabled = false; // Re-enable button
                isProcessingLaunch = false; // Set processing flag to false (after error)
            } finally {
                if (launchButton.disabled && !statusIconsSpan.querySelector('.success-icon') && !statusIconsSpan.querySelector('.loading-icon') ) {
                    launchButton.disabled = false; // Ensure button is re-enabled even if try block fails before setting icons.
                    isProcessingLaunch = false; // Ensure processing flag is false in any unexpected scenario
                }
            }
        });

        // --- ADD BEFOREUNLOAD EVENT LISTENER ---
        window.addEventListener('beforeunload', (event) => {
            if (isProcessingLaunch) {
                event.preventDefault();
                event.returnValue = 'As atualizações de palpites estão em andamento. Tem certeza de que deseja sair desta página? Se sair, o processo pode ser interrompido.'; // For older browsers
                return 'As atualizações de palpites estão em andamento. Tem certeza de que deseja sair desta página? Se sair, o processo pode ser interrompido.'; // For modern browsers
            }
        });
         // Load predictions when the page loads
         loadPredictions();

         /* --- CÓDIGO JAVASCRIPT DO CÓDIGO 2 COLADO AQUI --- */
         (function() { // Self-executing anonymous function

           var categories = [
             "Full Time",
             "Double Chance",
             "Additional Totals",
             "Both Teams to Score",
             "Double Chance and Both Teams Score",
             "First 10 mins",
             "Half Time",
             "1st Half Totals",
             "Matchbet & Both Team to Score",
             "Double Chance and Total",
             "Half Time/Full Time",
             "Highest Scoring Half",
             "First Team to Score",
             "MultiGoals",
             "Correct Score",
             "Handicap",
             "Both Teams to score and Totals",
             "1st Half - Double Chance and Both Teams Score",
             "2nd Half - Double Chance and Both Teams Score",
             "Multiscores",
             "1st Half - Multigoals",
             "2nd Half - Multigoals",
             "Multigoals Home Team",
             "Multigoals Away Team",
             "Double Chance(Match) & 1st Half Both Teams Score",
             "Double Chance (Match) & 2nd Half Both Teams Score",
             "1st Half - Exact Number of Goals",
             "2nd Half 1X2",
             "2nd Half Totals",
             "Home Or Both Teams To Score",
             "Clean Sheet Home Team",
             "Draw Or Both Teams To Score",
             "Clean Sheet Away Team",
             "Away Or Both Teams To Score",
             "Which Team To Score",
             "Home Or Any Clean Sheet",
             "Draw Or Any Clean Sheet",
             "Away Or Any Clean Sheet",
             "1st Half - First Team to Score",
             "1st Half - Totals Home Team",
             "1st Half - Totals Away Team",
             "Odd Even Goals",
             "1st Half - Clean Sheet Home Team",
             "Draw No Bet",
             "1st Half - Clean Sheet Away Team",
             "Goals Home",
             "Goals Away",
             "1st Half - Handicap (1x2)",
             "2nd Half - Totals Home Team",
             "2nd Half - Totals Away Team",
             "2nd Half - Clean Sheet Home Team",
             "2nd Half - Clean Sheet Away Team",
             "2nd Half - Correct Score",
             "Total Goals (exact)",
             "2nd Half - First Team to score",
             "2nd Half - Handicap (1x2)",
             "Home No Bet",
             "Away No Bet",
             "Home to win to Nil",
             "Away to win Nil",
             "Odd Even Home Team",
             "Odd Even Away Team",
             "First Half - Matchbet + Totals",
             "Totals Away team",
             "First Half - Matchbet + Both Teams To Score",
             "Totals Home Team",
             "Total Goals (aggregated)",
             "1st Half - Correct Score",
             "Home to win both Halves",
             "Matchbet + Totals",
             "Home to win either half",
             "Home To Score In Both Halves",
             "Matchflow",
             "Away to win both Halves",
             "Away to win either half",
             "Away To Score In Both Halves",
             "Both Halves Over 1.5",
             "Both Halves Under 1.5",
             "1st Half Double Chance",
             "1st Half - Draw no Bet",
             "First Goal Interval 10 Min",
             "First Goal Interval 15 Min",
             "1st Half - Both Teams to score",
             "2nd Half - Both Teams to score",
             "Highest Scoring Half Hometeam",
             "Highest Scoring Half Away team",
             "2nd Half - Odd / Even",
             "2nd Half - Draw No Bet",
             "2nd Half Double Chance",
             "Half Time/Full Time & Total",
             "1st Half - Odd Even Goals",
             "Winning Margins",
             "Last Team To Score",
             "Both Teams to score 1st Half & 2nd Half",
             "2nd Half - Matchbet and Total",
             "2nd Half - MatchBet and BTTS",
             "Total Corners",
             "1st Half - Total Corners",
             "1st Half - Corner Handicap",
             "Corner Matchbet",
             "1st Half - Corner Matchbet",
             "Corner Odd/Even",
             "1st Half - Corner Odd/Even",
             "First Corner",
             "Home Team Number of Corners",
             "1st Half - Home Team Number of Corners",
             "Last Corner",
             "1st Half - Last Corner",
             "Away Team Number of Corners",
             "1st Half - Away Team Number of Corners",
             "Corner Total (Aggregated)",
             "1st Half - Corner Total (Aggregated)",
             "1st Half - Number of Bookings Home",
             "Number of Bookings Away",
             "1st Half - Number of Bookings Away",
             "1st Half - First Team Booked",
             "Most Match Bookings",
             "1st Half - Match Bookings",
             "Exact Bookings",
             "1st Half - Exact Bookings",
             "Home Team Player Sent Off",
             "Away Team Player Sent Off",
             "Total Number of bookings",
             "1st Half - Total Number of Bookings",
             "Player Sent Off?",
             "1st Half - Player Sent Off?",
             "Number of Bookings Home",
             "First Goal Time",
             "Last GoalScorer",
             "First GoalScorer",
             "Anytime GoalsScorer"
           ];

           const categoryMap = {
             "Full Time": "Resultado da Partida (Match Result)",
             "Double Chance": "Resultado da Partida (Match Result)",
             "Draw No Bet": "Resultado da Partida (Match Result)",
             "Home No Bet": "Resultado da Partida (Match Result)",
             "Away No Bet": "Resultado da Partida (Match Result)",
             "Handicap": "Resultado da Partida (Match Result)",
             "1st Half - Handicap (1x2)": "Resultado da Partida (Match Result)",
             "2nd Half - Handicap (1x2)": "Resultado da Partida (Match Result)",
             "1st Half Double Chance": "Resultado da Partida (Match Result)",
             "2nd Half Double Chance": "Resultado da Partida (Match Result)",
             "2nd Half 1X2": "Resultado da Partida (Match Result)",
             "1st Half - Draw no Bet": "Resultado da Partida (Match Result)",
             "Corner Matchbet": "Resultado da Partida (Match Result)",
             "1st Half - Corner Matchbet": "Resultado da Partida (Match Result)",

             "Additional Totals": "Gols (Goals)",
             "Total Goals (aggregated)": "Gols (Goals)",
             "Total Goals (exact)": "Gols (Goals)",
             "1st Half Totals": "Gols (Goals)",
             "2nd Half Totals": "Gols (Goals)",
             "Odd Even Goals": "Gols (Goals)",
             "1st Half - Odd Even Goals": "Gols (Goals)",
             "Goals Home": "Gols (Goals)",
             "Goals Away": "Gols (Goals)",
             "Totals Home Team": "Gols (Goals)",
             "Totals Away team": "Gols (Goals)",
             "1st Half - Totals Home Team": "Gols (Goals)",
             "1st Half - Totals Away Team": "Gols (Goals)",
             "2nd Half - Totals Home Team": "Gols (Goals)",
             "2nd Half - Totals Away Team": "Gols (Goals)",
             "Multigoals": "Gols (Goals)",
             "1st Half - Multigoals": "Gols (Goals)",
             "2nd Half - Multigoals": "Gols (Goals)",
             "Multigoals Home Team": "Gols (Goals)",
             "Multigoals Away Team": "Gols (Goals)",
             "1st Half - Exact Number of Goals": "Gols (Goals)",
             "2nd Half Totals": "Gols (Goals)",
             "Both Halves Over 1.5": "Gols (Goals)",
             "Both Halves Under 1.5": "Gols (Goals)",

             "Both Teams to Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Both Teams to score and Totals": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Matchbet & Both Team to Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Double Chance and Both Teams Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "1st Half - Both Teams to score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "2nd Half - Both Teams to score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Double Chance(Match) & 1st Half Both Teams Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Double Chance (Match) & 2nd Half Both Teams Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "1st Half - Double Chance and Both Teams Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "2nd Half - Double Chance and Both Teams Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "First Half - Matchbet + Both Teams To Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "2nd Half - MatchBet and BTTS": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Both Teams to score 1st Half & 2nd Half": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Home Or Both Teams To Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Draw Or Both Teams To Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",
             "Away Or Both Teams To Score": "Ambas as Equipes Marcam (Both Teams To Score - BTTS)",

             "Half Time": "Intervalos e Metades (Halves & Intervals)",
             "Half Time/Full Time": "Intervalos e Metades (Halves & Intervals)",
             "Half Time/Full Time & Total": "Intervalos e Metades (Halves & Intervals)",
             "Highest Scoring Half": "Intervalos e Metades (Halves & Intervals)",
             "Highest Scoring Half Hometeam": "Intervalos e Metades (Halves & Intervals)",
             "Highest Scoring Half Away team": "Intervalos e Metades (Halves & Intervals)",
             "Home to win both Halves": "Intervalos e Metades (Halves & Intervals)",
             "Away to win both Halves": "Intervalos e Metades (Halves & Intervals)",
             "Home to win either half": "Intervalos e Metades (Halves & Intervals)",
             "Away to win either half": "Intervalos e Metades (Halves & Intervals)",
             "Home To Score In Both Halves": "Intervalos e Metades (Halves & Intervals)",
             "Away To Score In Both Halves": "Intervalos e Metades (Halves & Intervals)",
             "First 10 mins": "Intervalos e Metades (Halves & Intervals)",
             "First Goal Interval 10 Min": "Intervalos e Metades (Halves & Intervals)",
             "First Goal Interval 15 Min": "Intervalos e Metades (Halves & Intervals)",
             "First Goal Time": "Intervalos e Metades (Halves & Intervals)",

             "Correct Score": "Placar Correto (Correct Score)",
             "1st Half - Correct Score": "Placar Correto (Correct Score)",
             "2nd Half - Correct Score": "Placar Correto (Correct Score)",
             "Multiscores": "Placar Correto (Correct Score)",

             "Total Corners": "Escanteios (Corners)",
             "1st Half - Total Corners": "Escanteios (Corners)",
             "Corner Odd/Even": "Escanteios (Corners)",
             "1st Half - Corner Odd/Even": "Escanteios (Corners)",
             "First Corner": "Escanteios (Corners)",
             "Last Corner": "Escanteios (Corners)",
             "Corner Total (Aggregated)": "Escanteios (Corners)",
             "1st Half - Corner Total (Aggregated)": "Escanteios (Corners)",
             "Home Team Number of Corners": "Escanteios (Corners)",
             "Away Team Number of Corners": "Escanteios (Corners)",
             "1st Half - Home Team Number of Corners": "Escanteios (Corners)",
             "1st Half - Away Team Number of Corners": "Escanteios (Corners)",
             "1st Half - Corner Handicap": "Escanteios (Corners)",

             "Total Number of bookings": "Cartões e Disciplina (Bookings & Discipline)",
             "1st Half - Total Number of Bookings": "Cartões e Disciplina (Bookings & Discipline)",
             "Number of Bookings Home": "Cartões e Disciplina (Bookings & Discipline)",
             "Number of Bookings Away": "Cartões e Disciplina (Bookings & Discipline)",
             "1st Half - Number of Bookings Home": "Cartões e Disciplina (Bookings & Discipline)",
             "1st Half - Number of Bookings Away": "Cartões e Disciplina (Bookings & Discipline)",
             "Exact Bookings": "Cartões e Disciplina (Bookings & Discipline)",
             "1st Half - Exact Bookings": "Cartões e Disciplina (Bookings & Discipline)",
             "Most Match Bookings": "Cartões e Disciplina (Bookings & Discipline)",
             "1st Half - Match Bookings": "Cartões e Disciplina (Bookings & Discipline)",
             "1st Half - First Team Booked": "Cartões e Disciplina (Bookings & Discipline)",
             "Home Team Player Sent Off": "Cartões e Disciplina (Bookings & Discipline)",
             "Away Team Player Sent Off": "Cartões e Disciplina (Bookings & Discipline)",
             "Player Sent Off?": "Cartões e Disciplina (Bookings & Discipline)",
             "1st Half - Player Sent Off?": "Cartões e Disciplina (Bookings & Discipline)",
             "Number of Bookings Home": "Cartões e Disciplina (Bookings & Discipline)",

             "First GoalScorer": "Marcadores de Gol (Goalscorers)",
             "Last Goalscorer": "Marcadores de Gol (Goalscorers)",
             "Anytime GoalsScorer": "Marcadores de Gol (Goalscorers)",
             "First Team to Score": "Marcadores de Gol (Goalscorers)",
             "1st Half - First Team to Score": "Marcadores de Gol (Goalscorers)",
             "Last Team To Score": "Marcadores de Gol (Goalscorers)",
             "2nd Half - First Team to score": "Marcadores de Gol (Goalscorers)",
             "Which Team To Score": "Marcadores de Gol (Goalscorers)",

             "Clean Sheet Home Team": "Limpeza de Gol (Clean Sheet)",
             "Clean Sheet Away Team": "Limpeza de Gol (Clean Sheet)",
             "1st Half - Clean Sheet Home Team": "Limpeza de Gol (Clean Sheet)",
             "1st Half - Clean Sheet Away Team": "Limpeza de Gol (Clean Sheet)",
             "2nd Half - Clean Sheet Home Team": "Limpeza de Gol (Clean Sheet)",
             "2nd Half - Clean Sheet Away Team": "Limpeza de Gol (Clean Sheet)",
             "Home to win to Nil": "Limpeza de Gol (Clean Sheet)",
             "Away to win Nil": "Limpeza de Gol (Clean Sheet)",
             "Home Or Any Clean Sheet": "Limpeza de Gol (Clean Sheet)",
             "Draw Or Any Clean Sheet": "Limpeza de Gol (Clean Sheet)",
             "Away Or Any Clean Sheet": "Limpeza de Gol (Clean Sheet)",

             "Matchbet + Totals": "Apostas Combinadas (Combined Bets)",
             "First Half - Matchbet + Totals": "Apostas Combinadas (Combined Bets)",
             "Matchflow": "Apostas Combinadas (Combined Bets)",
             "Winning Margins": "Apostas Combinadas (Combined Bets)",
             "2nd Half - Matchbet and Total": "Apostas Combinadas (Combined Bets)",

             "Odd Even Home Team": "Ímpar/Par (Odd/Even)",
             "Odd Even Away Team": "Ímpar/Par (Odd/Even)",
             "2nd Half - Odd / Even": "Ímpar/Par (Odd/Even)"
         };


           window.convertToTable = function() { // Make convertToTable global
             var inputText = document.getElementById("inputTextArea").value;
             var lines = inputText.split('\n');
             var outputDiv = document.getElementById("outputTables");
             outputDiv.innerHTML = ''; // Limpar tabelas anteriores

             var currentCategory = null;
             var currentTable = null;

             for (const line of lines) {
               const trimmedLine = line.trim();
               if (trimmedLine === "") continue; // Ignorar linhas vazias

               if (categories.includes(trimmedLine)) {
                 if (currentTable) {
                   outputDiv.appendChild(currentTable); // Adicionar tabela anterior se existir
                 }
                 currentCategory = trimmedLine;
                 currentTable = createCategoryTable(currentCategory);
                 currentTable.setAttribute('data-original-category', currentCategory); // Store original category
                 const displayCategory = categoryMap[currentCategory] || "Outras Categorias"; // Get mapped category or default
                 currentTable.setAttribute('data-category', displayCategory); // Store display category for filtering
               } else if (currentCategory) {
                 const parts = splitTextNumber(trimmedLine, currentCategory);
                 if (parts) {
                   addTableRow(currentTable, parts.text, parts.number);
                 }
               }
             }

             if (currentTable) {
               outputDiv.appendChild(currentTable); // Adicionar a última tabela
             }
             filterTables(); // Apply initial filter (show all)
           }

           function createCategoryTable(category) {
             const table = document.createElement('table');
             const thead = document.createElement('thead');
             const headerRow = document.createElement('tr');
             const headerCell = document.createElement('th');
             headerCell.colSpan = 3;
             headerCell.textContent = category;
             headerRow.appendChild(headerCell);
             thead.appendChild(headerRow);
             table.appendChild(thead);
             const tbody = document.createElement('tbody');
             table.appendChild(tbody);
             return table;
           }

           function addTableRow(table, text, number) {
             const tbody = table.querySelector('tbody');
             const row = document.createElement('tr');
             const textCell = document.createElement('td');
             textCell.textContent = text.trim();
             const numberCell = document.createElement('td');
             numberCell.textContent = number;

             const calculationCell = document.createElement('td');
             if (number && !isNaN(parseFloat(number))) {
                 const odd = parseFloat(number);
                 const oddMin = 1.1;
                 const oddMax = 10;
                 let score;

                 if (odd < 0.5) {
                   score = 0;
                 } else if (odd >= 0.5 && odd < 1) {
                   score = 1;
                 } else if (odd >= 1) {
                   score = 1 + 9 * (Math.log(odd) - Math.log(oddMin)) / (Math.log(oddMax) - Math.log(oddMin));
                   score = Math.ceil(score);

                   if (score > 10) {
                     score = 10;
                   }
                 } else {
                   score = "-";
                 }

                 const boldText = document.createElement('b');
                 boldText.textContent = score;
                 calculationCell.appendChild(boldText);
             } else {
                 calculationCell.textContent = "-";
             }


             row.appendChild(textCell);
             row.appendChild(numberCell);
             row.appendChild(calculationCell);
             tbody.appendChild(row);
           }

           function splitTextNumber(line, currentCategory) {
             const multiGoalRanges = ["1-2", "1-3", "1-4", "1-5", "1-6", "2-3", "2-4", "2-5", "2-6", "3-4", "3-5", "3-6", "4-5", "4-6", "5-6", "7+", "0"];
             const firstHalfExactGoalsRanges = ["0", "1", "2", "3+"];
             const secondHalfCorrectScoreRanges = ["0:0", "0:1", "0:2", "1:0", "1:1", "1:2", "2:0", "2:1", "2:2", "OTHER"];
             const totalGoalsExactRanges = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9+"];
             const totalGoalsAggregatedRanges = ["0-1", "2-3", "4-5", "6+"];
             const firstHalfCorrectScoreRanges = ["0:0", "1:1", "2:2", "1:0", "2:0", "2:1", "0:1", "0:2", "1:2", "OTHERS"];
             const firstGoalInterval10MinRanges = ["1-10", "11-20", "21-30", "31-40", "41-50", "51-60", "61-70", "71-80", "81-90", "NO GOALS IN THE MATCH"];
             const firstGoalInterval15MinRanges = ["1-15", "16-30", "31-45", "46-60", "61-75", "76-90"];
             const firstGoalTimeRanges = ["1-10", "1-15", "1-30", "31+", "No Goals in the Match"];
             const awayOrBothTeamsScoreRanges = ["YES", "NO"];

             if (currentCategory === "Home Team Number of Corners" || currentCategory === "Away Team Number of Corners") {
                 const cornerRanges = ["0-2", "3-4", "5-6", "7+"];
                 for (const range of cornerRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Home Team Number of Corners") {
                 const firstHalfHomeCornerRanges = ["0-1", "2", "3", "4+"];
                 for (const range of firstHalfHomeCornerRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Corner Total (Aggregated)") {
                 const cornerTotalAggregatedRanges = ["0-8", "9-11", "12+"];
                 for (const range of cornerTotalAggregatedRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Corner Total (Aggregated)") {
                 const firstHalfCornerTotalAggregatedRanges = ["5-6", "7+", "0-4"];
                 for (const range of firstHalfCornerTotalAggregatedRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Number of Bookings Home") {
                 const firstHalfBookingsHomeRanges = ["2", "0", "1", "3+"];
                 for (const range of firstHalfBookingsHomeRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Number of Bookings Away") {
                 const bookingsAwayRanges = ["0-1", "2", "3", "4+"];
                 for (const range of bookingsAwayRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Number of Bookings Away") {
                 const firstHalfBookingsAwayRanges = ["2", "0", "1", "3+"];
                 for (const range of firstHalfBookingsAwayRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             }  else if (currentCategory === "Exact Bookings") {
                 const exactBookingsRanges = ["0-3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
                 for (const range of exactBookingsRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Exact Bookings") {
                 const firstHalfExactBookingsRanges = ["0", "1", "2", "3", "4", "5", "6+"];
                 for (const range of firstHalfExactBookingsRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Number of Bookings Home") {
                 const bookingsHomeRanges = ["0-1", "2", "3", "4+"];
                 for (const range of bookingsHomeRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "MultiGoals") {
                 for (const range of multiGoalRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Correct Score") {
                 const correctScoreRanges = ["0:0", "0:1", "0:2", "0:3", "0:4", "0:5", "0:6", "1:0", "1:1", "1:2", "1:3", "1:4", "1:5", "2:0", "2:1", "2:2", "2:3", "2:4", "3:0", "3:1", "3:2", "3:3", "4:0", "4:1", "4:2", "5:0", "5:1", "6:0", "OTHER"];
                 for (const score of correctScoreRanges) {
                     if (line.startsWith(score)) {
                         const numberPart = line.substring(score.length).trim();
                         return {
                             text: score,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Multiscores") {
                 const multiScoresRanges = ["1:0, 2:0 OR 3:0", "0:1, 0:2 OR 0:3", "4:0, 5:0 OR 6:0", "0:4, 0:5 OR 0:6", "2:1, 3:1 OR 4:1", "1:2, 1:3 OR 1:4", "3:2, 4:2, 4:3 OR 5:1", "2:3, 2:4, 3:4 OR 1:5", "OTHER HOMEWIN", "OTHER AWAYWIN", "X"];
                 for (const scoreRange of multiScoresRanges) {
                     if (line.startsWith(scoreRange)) {
                         const numberPart = line.substring(scoreRange.length).trim();
                         return {
                             text: scoreRange,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Multigoals" || currentCategory === "2nd Half - Multigoals" || currentCategory === "Multigoals Home Team" || currentCategory === "Multigoals Away Team") {
                 for (const range of multiGoalRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Exact Number of Goals" || currentCategory === "Goals Home" || currentCategory === "Goals Away") {
                 for (const range of firstHalfExactGoalsRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "2nd Half - Correct Score") {
                 for (const score of secondHalfCorrectScoreRanges) {
                     if (line.startsWith(score)) {
                         const numberPart = line.substring(score.length).trim();
                         return {
                             text: score,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Total Goals (exact)") {
                 for (const range of totalGoalsExactRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Total Goals (aggregated)") {
                 for (const range of totalGoalsAggregatedRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "1st Half - Correct Score") {
                 for (const score of firstHalfCorrectScoreRanges) {
                     if (line.startsWith(score)) {
                         const numberPart = line.substring(score.length).trim();
                         return {
                             text: score,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "First Goal Interval 10 Min") {
                 for (const range of firstGoalInterval10MinRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "First Goal Interval 15 Min") {
                 for (const range of firstGoalInterval15MinRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "First Goal Time") {
                 for (const range of firstGoalTimeRanges) {
                     if (line.startsWith(range)) {
                         const numberPart = line.substring(range.length).trim();
                         return {
                             text: range,
                             number: numberPart
                         };
                     }
                 }
             } else if (currentCategory === "Away Or Both Teams To Score") {
                 for (const value of awayOrBothTeamsScoreRanges) {
                     if (line.startsWith(value)) {
                         const numberPart = line.substring(value.length).trim();
                         return {
                             text: value,
                             number: numberPart
                         };
                     }
                 }
             }


             const overUnderKeywords = ["OVER", "UNDER"];
             for (const keyword of overUnderKeywords) {
                 const keywordIndex = line.indexOf(keyword);
                 if (keywordIndex !== -1) {
                     const prefix = line.substring(0, keywordIndex);
                     const suffixStart = keywordIndex + keyword.length;
                     const remainingText = line.substring(suffixStart).trim();

                     let numberRegex = /^(\s*\d\.\d)/;
                     const numberMatch = remainingText.match(numberRegex);
                     if (numberMatch) {
                         const number = numberMatch[1].trim();
                         let numberPart = remainingText.substring(number.length).trim();

                         const lastNumberSplit = numberPart.match(/^(.*?)([0-9.]+)$/);
                         if (lastNumberSplit && lastNumberSplit.length === 3) {
                             numberPart = lastNumberSplit[2];
                             return {
                                 text: (prefix + keyword + " " + number + " " + lastNumberSplit[1]).trim(),
                                 number: numberPart
                             };
                         }


                         return {
                             text: (prefix + keyword + " " + number + " " + numberPart).trim(),
                             number: ""
                         };
                     }
                 }
             }

             const parts = line.match(/^(.*?)([0-9.]+)$/);
             if (parts && parts.length === 3) {
                 return {
                     text: parts[1].trim(),
                     number: parts[2]
                 };
             } else {
                 return {
                     text: line.trim(),
                     number: ""
                 };
             }
           }

           window.filterTables = function() { // Make filterTables global
             var selectedCategory = document.getElementById("categoryFilter").value;
             var tables = document.querySelectorAll("#outputTables table");

             tables.forEach(function(table) {
               if (selectedCategory === 'all' || table.getAttribute('data-category') === selectedCategory) {
                 table.style.display = ''; // Show table
               } else {
                 table.style.display = 'none'; // Hide table
               }
             });
           }

         })(); // End of self-executing anonymous function


     </script>

    <!-- --- NEW JAVASCRIPT FOR POPUP INTERACTION --- -->
    <script>
        document.addEventListener('DOMContentLoaded', (event) => {
            const settingsIcon = document.getElementById('settings-icon-container');
            const settingsPopup = document.getElementById('settings-popup');
            const closeButtonTopRight = document.getElementById('popup-close');
            const closeButtonScrollable = document.getElementById('popup-close-scrollable');

            if (settingsIcon && settingsPopup && closeButtonTopRight && closeButtonScrollable) {
                settingsIcon.addEventListener('click', () => {
                    settingsPopup.style.display = 'block';
                });

                closeButtonTopRight.addEventListener('click', () => {
                    settingsPopup.style.display = 'none';
                });

                closeButtonScrollable.addEventListener('click', () => {
                    settingsPopup.style.display = 'none';
                });

                // --- DRAGGABLE POPUP FUNCTIONALITY ---
                let isDragging = false;
                let offsetX, offsetY;

                settingsPopup.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    offsetX = e.clientX - settingsPopup.offsetLeft;
                    offsetY = e.clientY - settingsPopup.offsetTop;
                    settingsPopup.style.cursor = 'grabbing'; // Change cursor during drag
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    settingsPopup.style.left = (e.clientX - offsetX) + 'px';
                    settingsPopup.style.top = (e.clientY - offsetY) + 'px';
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    settingsPopup.style.cursor = 'grab'; // Reset cursor after drag
                });
                // --- END OF DRAGGABLE POPUP FUNCTIONALITY ---


            } else {
                console.error("Could not find elements for settings popup interaction.");
            }
        });
    </script>
    <!-- --- END OF NEW JAVASCRIPT --- -->

</body>
</html>
