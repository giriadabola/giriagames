<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Árbitro - G EMPIRE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <!-- 1. SCRIPT DE SEGURANÇA: Verifica o login e a permissão do utilizador -->
   <script type="module" src="js/auth-guard.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .top-menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 12px 0;
            display: flex;
            justify-content: center;
            gap: 24px;
            align-items: center;
            z-index: 1000; /* Existing z-index */
        }

        .menu-item {
            text-decoration: none;
            color: #666;
            transition: color 0.3s ease;
            font-weight: 500;
            padding: 8px 16px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            line-height: 1.4;
        }

        .menu-item:hover, .menu-item.active {
            color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }

        .menu-item i {
            font-size: 16px;
        }

        .content {
            padding: 80px 20px 20px; /* Adjusted top padding accounts for menu */
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #333;
            margin-bottom: 30px;
            text-align: center;
        }

        .predictions-list {
            display: grid;
            gap: 20px;
            margin-top: 20px;
        }

        .prediction-card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .prediction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .prediction-teams {
            font-weight: bold;
            color: #333;
        }

        .prediction-date {
            color: #666;
            font-size: 0.9em;
        }

        .prediction-values {
            display: grid;
            gap: 10px;
            margin-top: 10px;
        }

        .prediction-value {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
        }

        .prediction-points {
            margin-right: auto;
            display: flex;
            align-items: center;
            gap: 7px;
        }

        .points-input {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            text-align: center;
            margin-right: 8px;
        }

        .points-input:focus {
            border-color: #28a745;
            outline: none;
        }

        .status-select {
            padding: 4px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.9em;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .status-select option {
            padding: 4px 8px;
        }

        .status-select.neutro {
            color: #666;
            border-color: #ddd;
        }

        .status-select.acerto {
            color: #28a745;
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.1);
        }

        .status-select.falha {
            color: #dc3545;
            border-color: #dc3545;
            background-color: rgba(220, 53, 69, 0.1);
        }

        .prediction-label {
            color: #666;
        }

        .prediction-number {
            font-weight: bold;
        }

        .prediction-number.neutro {
            color: #333;
            }

        .prediction-number.acerto {
            color: #28a745;
        }

        .prediction-number.falha {
            color: #dc3545;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .filter-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .round-filter, .gplayer-filter {
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1em;
            color: #333;
            background-color: white;
            cursor: pointer;
            outline: none;
        }

        .round-filter:hover, .gplayer-filter:hover {
            border-color: #28a745;
        }

        .launch-button {
            padding: 8px 16px;
            border: 1px solid #28a745;
            border-radius: 4px;
            font-size: 1em;
            color: white;
            background-color: #28a745;
            cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .launch-button:hover {
            background-color: #218838;
            border-color: #1e7e34;
        }

        #launch-status-icons {
            margin-left: 8px;
            display: inline-flex;
            align-items: center;
        }

        #launch-status-icons i {
            margin-right: 4px;
        }

        .loading-icon {
            display: none;
            color: #007bff;
            animation: spin 1s linear infinite;
        }

        .success-icon {
            display: none;
            color: #28a745;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #settings-icon-container {
            position: fixed;
            top: 85px;
            right: 25px;
            z-index: 999;
            cursor: pointer;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        #settings-icon-container i {
            font-size: 22px;
            color: #555;
            display: block;
            transition: color 0.3s ease;
        }

        #settings-icon-container:hover i {
            color: #28a745;
        }
         #settings-icon-container:hover {
            background-color: rgba(255, 255, 255, 0.8);
        }

        #settings-popup {
            display: none;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            min-height: 200px;
            max-height: 80vh;
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            overflow-y: auto;
            cursor: grab;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #settings-popup:active {
            cursor: grabbing;
        }

        #settings-popup h2 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #333;
            text-align: center;
            font-size: 1.2em;
        }

        #popup-close {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 24px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
            transition: color 0.3s ease;
            z-index: 1002;
        }

        #popup-close:hover {
            color: #333;
        }

        #popup-close-scrollable {
            position: fixed;
            bottom: 20px;
            right: 35px;
            font-size: 24px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
            transition: color 0.3s ease;
            z-index: 1002;
            background-color: white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            text-align: center;
            padding: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #popup-close-scrollable:hover {
            color: #333;
        }

        #popup-close, #popup-close-scrollable {
            cursor: pointer;
        }

        #settings-popup table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 20px;
        }
        #settings-popup th, #settings-popup td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
        }
        #settings-popup th {
            background-color: #f2f2f2;
            text-align: center;
        }
        #settings-popup td:nth-child(2),
        #settings-popup td:nth-child(3) {
            text-align: right;
        }

        #settings-popup #inputTextArea {
            width: 100%;
            box-sizing: border-box;
            max-height: 150px;
            margin-bottom: 15px;
        }

        #settings-popup .popup-controls-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            gap: 15px;
        }

        #settings-popup .popup-controls-container button {
             padding: 8px 16px;
             border: 1px solid #28a745;
             border-radius: 4px;
             font-size: 1em;
             color: white;
             background-color: #28a745;
             cursor: pointer;
             outline: none;
             transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease;
             display: inline-flex;
             align-items: center;
             justify-content: center;
        }
        #settings-popup .popup-controls-container button:hover {
             background-color: #218838;
             border-color: #1e7e34;
        }
        #settings-popup .popup-controls-container button:disabled {
            background-color: #cccccc;
            border-color: #bbbbbb;
            cursor: not-allowed;
            opacity: 0.7;
        }

        #settings-popup .popup-controls-container .popup-icon-button {
             padding: 8px 12px;
             line-height: 1;
        }

        #settings-popup .popup-controls-container .popup-icon-button i {
            /* No specific styles needed, flex handles alignment */
        }

        #settings-popup .converter-filter-container {
            display: flex;
            align-items: center;
            margin-left: auto;
        }

        #settings-popup .converter-filter-container label {
            margin-right: 5px;
            font-size: 0.9em;
            color: #333;
        }

        #settings-popup #categoryFilter {
            width: auto;
            max-width: 100%;
            box-sizing: border-box;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em;
            background-color: white;
            cursor: pointer;
            outline: none;
        }
        #settings-popup #categoryFilter:hover {
             border-color: #28a745;
        }

        #settings-popup .search-container {
            margin-bottom: 15px;
        }
        #settings-popup #searchSubcategoryInput {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 0.95em;
        }
        #settings-popup #searchSubcategoryInput:focus {
            border-color: #28a745;
            outline: none;
        }
.launch-button.button--loading {
    /* Deixa o botão ligeiramente transparente para indicar inatividade */
    opacity: 0.7;
    /* Muda o cursor para o de "espera" */
    cursor: wait;
}

/* Estilo para o ícone de spinner DENTRO do botão */
.launch-button .spinner {
    /* Adiciona um pequeno espaço entre o texto e o ícone */
    margin-left: 8px;
}


        @media (max-width: 768px) {

    /* --- AJUSTES GERAIS DE LAYOUT --- */
    .content {
        /* Reduz o espaçamento nas laterais e um pouco no topo */
        padding: 70px 10px 10px;
    }

    h1 {
        /* Reduz um pouco o tamanho do título principal */
        font-size: 1.8em;
    }

    /* --- MENU SUPERIOR --- */
    .top-menu {
        /* Permite que os itens quebrem a linha se não couberem */
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px; /* Reduz o espaçamento entre os itens */
        padding: 10px 0;
    }

    .menu-item {
        padding: 6px 12px; /* Reduz o padding dos botões do menu */
        font-size: 13px;
    }

    /* --- BARRA DE FILTROS PRINCIPAL --- */
    .filter-container {
        /* A MÁGICA ACONTECE AQUI: muda a direção para vertical */
        flex-direction: column;
        align-items: stretch; /* Faz todos os itens ocuparem a largura total */
        gap: 12px; /* Adiciona espaçamento vertical entre os filtros */
    }

    /* --- CARTÕES DE PALPITES --- */
    .prediction-value {
        /* Permite que os controlos (input/select) passem para a linha de baixo */
        flex-wrap: wrap;
        gap: 8px; /* Adiciona um pequeno espaçamento quando os itens quebram a linha */
        justify-content: space-between; /* Melhora o alinhamento quando quebra a linha */
    }
    
    .prediction-header {
        /* Permite que o cabeçalho se quebre em duas linhas se for muito longo */
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
    }

    /* --- POPUP DE CONFIGURAÇÕES ("COLAR BETS") --- */
    #settings-popup {
        /* Garante que o popup não ocupa a tela inteira, deixando margens */
        width: 95%;
        max-height: 85vh; /* Garante que é visível em altura */
    }

    #settings-popup .popup-controls-container {
        /* Também empilha os controlos do popup verticalmente */
        flex-direction: column;
        align-items: stretch; /* Estica os botões para largura total */
        gap: 10px;
    }

    #settings-popup .converter-filter-container {
        margin-left: 0; /* Remove a margem que empurrava o filtro para a direita */
    }

    /* Adiciona scroll horizontal APENAS às tabelas se elas forem muito largas */
    #outputTables {
        overflow-x: auto;
    }
}

status-indicator {
    margin-left: 10px; /* Espaçamento entre o título e o emoji */
    font-size: 1.1em;  /* Deixa o emoji ligeiramente maior */
    cursor: help;      /* Muda o cursor para indicar que há uma dica */
}


    </style>
</head>
<body style="display: none;"> <!-- 2. Corpo da página oculto por defeito -->

    <nav class="top-menu">
        <a href="engrenagem.html" class="menu-item"><i class="fas fa-home"></i></a>
        <a href="criar-gplayer.html" class="menu-item"><i class="fas fa-plus"></i> CRIAR</a>
        <a href="editar-gplayer.html" class="menu-item"><i class="fas fa-edit"></i> EDITAR</a>
    </nav>

    <!-- Gear Icon -->
    <div id="settings-icon-container" title="Configurações">
        <i class="fas fa-cog"></i>
    </div>

    <!-- Popup (Initially Hidden) -->
    <div id="settings-popup">
        <span id="popup-close" title="Fechar">×</span>
        <span id="popup-close-scrollable" title="Fechar"><i class="fas fa-times"></i></span>
        <h2>Colar Bets</h2>
        <textarea id="inputTextArea" rows="10" cols="60" placeholder="Cole aqui o texto das bets (Nome subcategoria seguido das linhas de Opção e Odd)" onpaste="handlePaste(event)"></textarea>
        <div class="popup-controls-container">
            <button id="create-table-button" onclick="window.convertToTable()">Criar Tabela</button>
            <button id="auto-fill-button" class="popup-icon-button" title="Preencher Pontos Automaticamente">
                <i class="fas fa-rocket"></i>
                <i class="fas fa-spinner fa-spin loading-icon" style="display: none; margin-left: 5px;"></i>
            </button>
            <div class="converter-filter-container">
              <select id="categoryFilter" onchange="window.filterTables()">
                 <option value="all">Todas as Categorias</option>
                 <option value="Resultado Final">1. Resultado Final</option>
                 <option value="Golos">2. Golos</option>
                 <option value="Handicap">3. Handicap</option>
                 <option value="Intervalo/Fim do Jogo (HT/FT)">4. Intervalo/Fim do Jogo (HT/FT)</option>
                 <option value="Resultado Exato (Placar)">5. Resultado Exato (Placar)</option>
                 <option value="Específicos por Equipa">6. Específicos por Equipa</option>
                 <option value="Mercados Combinados">7. Mercados Combinados</option>
                 <option value="Tempo (Timing)">8. Tempo (Timing)</option>
                 <option value="Por Parte (1ª Parte / 2ª Parte)">9. Por Parte (1ª Parte / 2ª Parte)</option>
                 <option value="Mercados Especiais / Eventos">10. Mercados Especiais / Eventos</option>
                 <option value="Cantos">11. Cantos</option>
                 <option value="Cartões Amarelos">12. Cartões Amarelos</option>
                 <option value="Remates à Baliza">13. Remates à Baliza</option>
                 <option value="Faltas">14. Faltas</option>
                 <option value="Remates Totais">15. Remates Totais</option>
                 <option value="Jogadores (Totais)">16. Jogadores (Totais)</option>
                 <option value="Cartões Vermelhos">17. Cartões Vermelhos</option>
                 <option value="Foras de Jogo">18. Foras de Jogo</option>
                 <option value="Defesas do GR">19. Defesas do GR</option>
                 <option value="Posse de Bola">20. Posse de Bola</option>
                 <option value="Jogadores (Individuais)">21. Jogadores (Individuais)</option>
                 <option value="Jogadores (Confrontos)">22. Jogadores (Confrontos)</option>
                 <option value="Jogadores (Especiais)">23. Jogadores (Especiais)</option>
                 <option value="Jogadores (Cartões)">24. Jogadores (Cartões)</option>
                 <option value="Jogadores (Assistências)">25. Jogadores (Assistências)</option>
                 <option value="Jogadores (Remates)">26. Jogadores (Remates)</option>
                 <option value="Jogadores (Passes)">27. Jogadores (Passes)</option>
                 <option value="Jogadores (Defesas)">28. Jogadores (Defesas)</option>
              </select>
            </div>
        </div>
        <div class="search-container">
             <input type="text" id="searchSubcategoryInput" placeholder="Pesquisar Título da Subcategoria..." >
        </div>
        <div id="outputTables"></div>
    </div>

    <div class="content">
        <h1>Árbitro</h1>

    <!-- Main Content Area -->
    <div class="filter-container">
        <select id="round-filter" class="round-filter"><option value="">Todas as Rondas</option></select>
        <select id="game-filter" class="round-filter"><option value="">Todos os Jogos</option></select>
        <select id="gplayer-filter" class="gplayer-filter"><option value="">Todos os GPlayers</option></select>
        <button id="launch-button" class="launch-button">Lançar</button>
        <!-- O seu novo elemento está correto aqui -->
        <span id="voter-count-display" style="margin-left: 10px; font-weight: bold; font-size: 1.1em;"></span>
        <span id="launch-status-icons"></span>
    </div>

    <!-- A lista de palpites vem a seguir, também dentro de .content -->
    <div id="predictions-container" class="predictions-list">
        <div class="loading">Carregando palpites...</div>
    </div>
 
</div>

    <!-- Scripts for Popup Interaction and Dragging (sem alterações) -->
  

    <!-- Scripts for Popup Interaction and Dragging (sem alterações) -->
    <script>
        function handlePaste(event) {
            event.preventDefault();
            const text = (event.clipboardData || window.clipboardData).getData('text');
            const textarea = event.target;
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const currentText = textarea.value;
            textarea.value = currentText.substring(0, start) + text + currentText.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + text.length;
            setTimeout(() => {
                textarea.value = textarea.value.trimRight() + '\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n';
            }, 0);
        }
        const popup = document.getElementById('settings-popup');
        const settingsIcon = document.getElementById('settings-icon-container');
        const closeButtonTopRight = document.getElementById('popup-close');
        const closeButtonScrollable = document.getElementById('popup-close-scrollable');
        const togglePopup = () => {
             if (popup.style.display === 'none' || !popup.style.display) {
                popup.style.display = 'block';
                popup.style.left = '50%';
                popup.style.top = '50%';
                popup.style.transform = 'translate(-50%, -50%)';
                setTimeout(() => {
                    popup.style.opacity = '1';
                    popup.style.visibility = 'visible';
                }, 10);
            } else {
                popup.style.opacity = '0';
                popup.style.visibility = 'hidden';
                setTimeout(() => {
                    popup.style.display = 'none';
                }, 300);
            }
        };
        const closePopup = () => {
            popup.style.opacity = '0';
            popup.style.visibility = 'hidden';
            setTimeout(() => {
                popup.style.display = 'none';
            }, 300);
        };
        if (settingsIcon && popup && closeButtonTopRight && closeButtonScrollable) {
             settingsIcon.addEventListener('click', togglePopup);
             closeButtonTopRight.addEventListener('click', closePopup);
             closeButtonScrollable.addEventListener('click', closePopup);
        }
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;
        let initialPopupX = 0;
        let initialPopupY = 0;
        if (popup) {
            popup.addEventListener('mousedown', (e) => {
                 const nonDraggableTags = ['TEXTAREA', 'SELECT', 'BUTTON', 'INPUT', 'TABLE', 'TBODY', 'TR', 'TD', 'TH', 'A', 'I'];
                 const clickedElement = e.target;
                 const isCloseButton = clickedElement.id === 'popup-close' ||
                                      clickedElement.closest('#popup-close') ||
                                      clickedElement.id === 'popup-close-scrollable' ||
                                      clickedElement.closest('#popup-close-scrollable');

                 if (!isCloseButton && !nonDraggableTags.includes(clickedElement.tagName) && clickedElement.closest('#settings-popup') === popup) {
                    isDragging = true;
                    const rect = popup.getBoundingClientRect();
                    initialPopupX = rect.left;
                    initialPopupY = rect.top;
                    offsetX = e.clientX;
                    offsetY = e.clientY;
                    popup.style.cursor = 'grabbing';
                    popup.style.userSelect = 'none';
                    popup.style.transform = 'none';
                 }
            });
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = e.clientX - offsetX;
                const dy = e.clientY - offsetY;
                let newX = initialPopupX + dx;
                let newY = initialPopupY + dy;
                const popupWidth = popup.offsetWidth;
                const popupHeight = popup.offsetHeight;
                const windowWidth = window.innerWidth;
                const windowHeight = window.innerHeight;
                newX = Math.max(0, Math.min(newX, windowWidth - popupWidth));
                newY = Math.max(0, Math.min(newY, windowHeight - popupHeight));
                popup.style.left = newX + 'px';
                popup.style.top = newY + 'px';
            });
            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    popup.style.cursor = 'grab';
                    popup.style.userSelect = '';
                }
            });
        }
    </script>


    <!-- 3. SCRIPT PRINCIPAL DA PÁGINA (MODIFICADO) -->
  <script type="module">
    // Importa a conexão 'db' do guardião central. A inicialização do Firebase já foi feita lá.
   import { db } from './js/auth-guard.js';
    
    // Importa as outras funções do Firestore que esta página específica precisa.
    import { collection, getDocs, doc, getDoc, updateDoc, where, addDoc, serverTimestamp, getCountFromServer, query, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
    
    let currentRound = null;
    let currentGame = null;
    let currentGPlayer = null;
    let allPredictions = [];
    let isProcessingLaunch = false;
    let totalEligibleVoters = 0; // Movido para o escopo global para ser acessível
    
   async function loadPredictions() {
    // ALTERAÇÃO 1: Busca os GPlayers qualificados da coleção 'users'
    let qualifiedGPlayers = [];
    try {
        const usersRef = collection(db, 'users');
        const q = query(usersRef, where("aceite", "==", "Yes"), where("natabela", "==", "Yes"));
        const querySnapshot = await getDocs(q);
        querySnapshot.forEach((doc) => {
            qualifiedGPlayers.push({
                id: doc.id,
                nometabela: doc.data().nometabela
            });
        });
        qualifiedGPlayers.sort((a, b) => a.nometabela.localeCompare(b.nometabela));
    } catch (error) {
        console.error("Erro ao buscar GPlayers qualificados:", error);
    }

    try {
        const predictionsContainer = document.getElementById('predictions-container');
        const roundFilter = document.getElementById('round-filter');
        const palpitesSnapshot = await getDocs(collection(db, 'palpites'));
        allPredictions = [];
        const rounds = new Set();
        // A variável 'gplayers' não é mais necessária aqui
        if (palpitesSnapshot.empty) {
            predictionsContainer.innerHTML = '<div class="prediction-card">Nenhum palpite encontrado.</div>';
            return;
        }
        const uniqueJogoIdsFromPalpites = [...new Set(palpitesSnapshot.docs.map(d => d.data().jogoId).filter(Boolean))];
        const jogoPromises = uniqueJogoIdsFromPalpites.map(id => getDoc(doc(db, 'jogos', id)));
        const jogoDocs = await Promise.all(jogoPromises);
        const jogosDataMap = jogoDocs.reduce((acc, docSnap) => {
            if (docSnap.exists()) acc[docSnap.id] = docSnap.data();
            return acc;
        }, {});
        for (const palpiteDoc of palpitesSnapshot.docs) {
            const palpite = palpiteDoc.data();
            const jogoData = palpite.jogoId ? jogosDataMap[palpite.jogoId] : null;
            const numeroPalpites = jogoData && typeof jogoData.numeroPalpites === 'number' ? jogoData.numeroPalpites : 0;
            if (palpite.ronda) {
                rounds.add(palpite.ronda);
            }
            // Não precisamos mais popular a lista de gplayers a partir daqui
            allPredictions.push({
                id: palpiteDoc.id,
                ...palpite,
                numeroPalpites: numeroPalpites
            });
        }
        const sortedRounds = Array.from(rounds).sort((a, b) => b - a);
        roundFilter.innerHTML = '<option value="">Todas as Rondas</option>';
        sortedRounds.forEach(round => {
            roundFilter.innerHTML += `<option value="${round}">Ronda ${round}</option>`;
        });
        function updateGameFilter() {
            const gameFilter = document.getElementById('game-filter');
            const filteredByRound = currentRound ? allPredictions.filter(p => p.ronda === currentRound) : allPredictions;
            const games = new Set(filteredByRound.map(p => p.nomeJogo).filter(Boolean));
            const sortedGames = Array.from(games).sort();
            gameFilter.innerHTML = '<option value="">Todos os Jogos</option>';
            sortedGames.forEach(game => {
                const teamNamesMatch = game.match(/^([^-]+ vs [^-]+)/);
                const displayGameName = teamNamesMatch ? teamNamesMatch[1].trim() : game;
                gameFilter.innerHTML += `<option value="${game}">${displayGameName}</option>`;
            });
            gameFilter.value = currentGame || '';
        }
        const gameFilter = document.getElementById('game-filter');
        const gplayerFilter = document.getElementById('gplayer-filter');
        roundFilter.replaceWith(roundFilter.cloneNode(true));
        gameFilter.replaceWith(gameFilter.cloneNode(true));
        gplayerFilter.replaceWith(gplayerFilter.cloneNode(true));
        document.getElementById('round-filter').addEventListener('change', (e) => {
            currentRound = e.target.value === "" ? null : Number(e.target.value);
            currentGame = null;
            updateGameFilter();
            loadPredictions();
        });
        document.getElementById('game-filter').addEventListener('change', (e) => {
            currentGame = e.target.value || null;
            loadPredictions();
        });
        document.getElementById('gplayer-filter').addEventListener('change', (e) => {
            currentGPlayer = e.target.value || null;
            loadPredictions();
        });
        if (sortedRounds.length > 0 && currentRound === null) {
            currentRound = sortedRounds[0];
            document.getElementById('round-filter').value = currentRound;
        } else {
           document.getElementById('round-filter').value = currentRound || '';
        }
        updateGameFilter();

        // ALTERAÇÃO 2: Nova lógica para preencher o dropdown de GPlayers
        const gplayerFilterElement = document.getElementById('gplayer-filter');
        gplayerFilterElement.innerHTML = '<option value="">Todos os GPlayers</option>';
        qualifiedGPlayers.forEach(player => {
            gplayerFilterElement.innerHTML += `<option value="${player.id}">${player.nometabela}</option>`;
        });
        gplayerFilterElement.value = currentGPlayer || '';
        
        let filteredPredictions = allPredictions;
        if (currentRound) {
            filteredPredictions = filteredPredictions.filter(p => p.ronda === currentRound);
        }
        if (currentGame) {
            filteredPredictions = filteredPredictions.filter(p => p.nomeJogo === currentGame);
        }
        
        // ALTERAÇÃO 3: Lógica de filtro ajustada para usar o userId
        if (currentGPlayer) {
            filteredPredictions = filteredPredictions.filter(p => p.userId === currentGPlayer);
        }

       const voterCountDisplay = document.getElementById('voter-count-display');
        if (currentGame && totalEligibleVoters > 0) {
            const votedUserIds = new Set(filteredPredictions.map(p => p.userId));
            const votedCount = votedUserIds.size;
            voterCountDisplay.textContent = `(${votedCount}/${totalEligibleVoters})`;
            if (votedCount === totalEligibleVoters) {
                voterCountDisplay.style.color = '#28a745';
            } else {
                voterCountDisplay.style.color = '#dc3545';
            }
        } else {
            voterCountDisplay.textContent = '';
        }

        let predictionsHTML = '';
        predictionsContainer.innerHTML = '<div class="loading">Carregando palpites...</div>';
        if (filteredPredictions.length === 0) {
            predictionsContainer.innerHTML = '<div class="prediction-card">Nenhum palpite encontrado para os filtros selecionados.</div>';
            return;
        }
        const uniqueUserIds = [...new Set(filteredPredictions.map(p => p.userId).filter(Boolean))];
        const userPromises = uniqueUserIds.map(id => getDoc(doc(db, 'users', id)));
        const uniqueClubIds = new Set();
        filteredPredictions.forEach(p => {
            const jogo = p.jogoId ? jogosDataMap[p.jogoId] : null;
            if (jogo) {
                if (jogo.equipaCasaId) uniqueClubIds.add(jogo.equipaCasaId);
                if (jogo.equipaForaId) uniqueClubIds.add(jogo.equipaForaId);
            }
        });
        const clubPromises = Array.from(uniqueClubIds).map(id => getDoc(doc(db, 'clubes', id)));
        const [userDocs, clubDocs] = await Promise.all([
            Promise.all(userPromises),
            Promise.all(clubPromises)
        ]);
        const usersData = userDocs.reduce((acc, docSnap) => {
            if (docSnap.exists()) acc[docSnap.id] = docSnap.data();
            return acc;
        }, {});
        const clubsData = clubDocs.reduce((acc, docSnap) => {
            if (docSnap.exists()) acc[docSnap.id] = docSnap.data();
            return acc;
        }, {});

        for (const palpite of filteredPredictions) {
            try {
                if (!palpite.jogoId) {
                    console.warn('Palpite sem jogoId encontrado:', palpite.id);
                    continue;
                }
                const jogo = jogosDataMap[palpite.jogoId];
                if (!jogo) {
                    console.warn(`Dados do Jogo com ID ${palpite.jogoId} não encontrados ou carregados.`);
                    continue;
                }
                if (!jogo.equipaCasaId || !jogo.equipaForaId) {
                    console.warn(`Jogo com ID ${palpite.jogoId} tem IDs de equipa em falta:`, jogo);
                    continue;
                }
                const equipaCasaData = clubsData[jogo.equipaCasaId];
                const equipaForaData = clubsData[jogo.equipaForaId];
                const equipaCasa = equipaCasaData?.nome || 'Equipa Casa?';
                const equipaFora = equipaForaData?.nome || 'Equipa Fora?';
                let dataFormatada = 'Data?';
                try {
                    if (jogo.dataJogo && typeof jogo.dataJogo.toDate === 'function') {
                        const dataJogo = jogo.dataJogo.toDate();
                        dataFormatada = dataJogo.toLocaleDateString('pt-PT');
                    }
                } catch (error) {
                    console.warn('Erro ao formatar data do jogo:', jogo.jogoId, error);
                }
                const userData = palpite.userId ? usersData[palpite.userId] : null;
                const userName = userData?.nometabela || palpite.nometabela || 'GPlayer?';

                let statusIndicatorHTML = '';
                if (palpite.Analisado === "Sim") {
                    statusIndicatorHTML = `<span class="status-indicator" title="Este palpite já foi lançado ao público.">🟢</span>`;
                } else {
                    statusIndicatorHTML = `<span class="status-indicator" title="Este palpite ainda não foi analisado e lançado.">🟠</span>`;
                }
                
                let palpitesHTML = '';
                for (let i = 1; i <= 10; i++) {
                    const palpiteKey = `palpite${i}`;
                    const pontosKey = `Palpite${i}PontosQuanto`;
                    const statusKey = `palpite${i}Status`;
                    if (palpite[palpiteKey]) {
                        const status = palpite[statusKey] || 'neutro';
                        palpitesHTML += `
                            <div class="prediction-value">
                                <div class="prediction-points">
                                    <span class="prediction-label">Palpite ${i}</span>
                                    <span class="prediction-number ${status}">${palpite[palpiteKey]}</span>
                                </div>
                                <input type="number" class="points-input" min="0" max="999" value="${palpite[pontosKey] || ''}" data-palpite-id="${palpite.id}" data-pontos-key="${pontosKey}" placeholder="Pts">
                                <select class="status-select ${status}" data-palpite-id="${palpite.id}" data-status-key="${statusKey}">
                                    <option value="neutro" ${status === 'neutro' ? 'selected' : ''}>Neutro</option>
                                    <option value="acerto" ${status === 'acerto' ? 'selected' : ''}>Acerto</option>
                                    <option value="falha" ${status === 'falha' ? 'selected' : ''}>Falha</option>
                                </select>
                            </div>`;
                   }
                }
                predictionsHTML += `
                    <div class="prediction-card" data-prediction-id="${palpite.id}">
                        <div class="prediction-header">
                            <div class="prediction-teams">${equipaCasa} vs ${equipaFora}${statusIndicatorHTML}</div>
                            <div class="prediction-date">${dataFormatada} - ${userName}</div>
                        </div>
                        <div class="prediction-values">${palpitesHTML}</div>
                    </div>`;
            } catch (error) {
                console.error('Erro ao processar o palpite com ID:', palpite?.id, error);
            }
        }
        predictionsContainer.innerHTML = predictionsHTML;
        addDynamicEventListeners();
    } catch (error) {
        console.error('Error loading predictions:', error);
        document.getElementById('predictions-container').innerHTML =
            '<div class="prediction-card">Erro ao carregar palpites. Tente atualizar a página.</div>';
    }
}



async function unifiedLaunchHandler() {
    // 1. OBTER ELEMENTOS E VERIFICAR CONDIÇÕES INICIAIS
    const launchButton = document.getElementById('launch-button');
    const roundFilter = document.getElementById('round-filter');
    const ronda = Number(roundFilter.value);

    if (!ronda) {
        alert("Por favor, selecione uma ronda para lançar.");
        return;
    }

    // 2. INICIAR EFEITO DE CARREGAMENTO VISUAL
    launchButton.disabled = true;
    isProcessingLaunch = true; // Flag para o aviso de 'beforeunload'
    launchButton.classList.add('button--loading');
    launchButton.innerHTML = `A Lançar... <i class="fas fa-spinner fa-spin spinner"></i>`;
    
    console.log(`--- INICIANDO LANÇAMENTO UNIFICADO PARA A RONDA ${ronda} ---`);

    try {
        const allAffectedUserIds = new Set();

        // 3. EXECUTAR A LÓGICA PRINCIPAL (ETAPA POR ETAPA)

        // ETAPA 1: Processar Palpites Normais
        console.log("==> Etapa 1: Processando Palpites Normais...");
        const palpitesAffectedUsers = await processNormalPalpites(ronda);
        palpitesAffectedUsers.forEach(id => allAffectedUserIds.add(id));
        console.log("==> Etapa 1: Concluída.");

        // ETAPA 2: Processar Mods de Jogo
        console.log("==> Etapa 2: Processando Mods de Jogo...");
        const modsAffectedUsers = await processGameMods(ronda);
        modsAffectedUsers.forEach(id => allAffectedUserIds.add(id));
        console.log("==> Etapa 2: Concluída.");
        
        // ETAPA FINAL: Recalcular Totais de Todos os Utilizadores Afetados
        if (allAffectedUserIds.size > 0) {
            console.log(`==> Etapa Final: Recalculando totais para ${allAffectedUserIds.size} utilizadores...`);
            // Busca a temporada a partir de um palpite da ronda para passar à função de recálculo
            const q = query(collection(db, "palpites"), where("ronda", "==", ronda), limit(1));
            const querySnapshot = await getDocs(q);
            if (!querySnapshot.empty) {
                const temporada = querySnapshot.docs[0].data().temporada;
                const temporadaKey = temporada.replace('/', '');
                await recalculateUserTotals(Array.from(allAffectedUserIds), temporadaKey);
            }
            console.log("==> Etapa Final: Concluída.");
        }

        // Feedback de sucesso ao utilizador
        alert(`Lançamento da ronda ${ronda} concluído com sucesso!`);

    } catch (error) {
        // 4. GESTÃO DE ERROS
        console.error("ERRO GERAL no lançamento unificado:", error);
        alert("Ocorreu um erro durante o lançamento. Verifique a consola para mais detalhes.");
    } finally {
        // 5. LIMPEZA E RESTAURAÇÃO DO BOTÃO
        // O bloco 'finally' executa SEMPRE, garantindo que o botão nunca fica preso.
        console.log(`--- LANÇAMENTO UNIFICADO FINALIZADO ---`);
        launchButton.disabled = false;
        isProcessingLaunch = false; // Desativa a flag de proteção de saída
        launchButton.classList.remove('button--loading');
        launchButton.innerHTML = 'Lançar';
    }
}

async function processNormalPalpites(ronda) {
    const affectedUserIds = new Set();
    
    // Busca os palpites da ronda diretamente da base de dados.
    // Isto é mais robusto do que depender dos dados carregados no ecrã.
    const palpitesQuery = query(collection(db, 'palpites'), where("ronda", "==", ronda));
    const palpitesSnapshot = await getDocs(palpitesQuery);
    
    if (palpitesSnapshot.empty) {
        console.log("Nenhum palpite normal encontrado para a ronda.");
        return affectedUserIds; // Retorna um set vazio
    }
    const allPalpitesDaRonda = palpitesSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));

    for (const palpite of allPalpitesDaRonda) {
        if (!palpite.userId || !palpite.jogoId || !palpite.temporada) {
            console.warn("Palpite com dados essenciais em falta, ignorado:", palpite.id);
            continue;
        }

        // --- INÍCIO DA SUA LÓGICA ORIGINAL DE CÁLCULO DE PONTOS ---
        let cardTotalPontosPossiveis = 0;
        let cardTotalPontosGanhos = 0;
        let hasAtLeastOnePalpite = false;
        let containsNeutro = false;

        for (let i = 1; i <= 10; i++) { // Assumindo um máximo de 10 palpites
            if (palpite.hasOwnProperty(`palpite${i}`)) {
                hasAtLeastOnePalpite = true;
                const pontosValue = palpite[`Palpite${i}PontosQuanto`] || 0;
                const status = palpite[`palpite${i}Status`] || 'neutro';

                if (status === 'acerto') {
                    cardTotalPontosGanhos += pontosValue;
                }
                if (status === 'neutro') {
                    containsNeutro = true;
                }
                cardTotalPontosPossiveis += pontosValue;
            }
        }
        // --- FIM DA SUA LÓGICA ORIGINAL DE CÁLCULO DE PONTOS ---
        
        if (hasAtLeastOnePalpite) {
            // 1. Atualiza o próprio documento do palpite com os totais e o status 'Analisado'
            const palpiteUpdateData = {
                "Analisado": !containsNeutro ? "Sim" : "Não",
                "TotalPontosGanhos": cardTotalPontosGanhos,
                "TotalPontosPossiveis": cardTotalPontosPossiveis
            };
            await updateDoc(doc(db, 'palpites', palpite.id), palpiteUpdateData);

            // 2. *** LÓGICA IDEMPOTENTE PARA CRIAR/ATUALIZAR O MOVIMENTO ***
            const temporadaKey = palpite.temporada.replace('/', '');
            const transacaoId = `palpite-${palpite.userId}-${palpite.jogoId}`;

            // Procura por um movimento que já tenha sido criado para este palpite
            const movQuery = query(collection(db, 'movimentos'), where("detalhes.transacaoId", "==", transacaoId));
            const movSnapshot = await getDocs(movQuery);

            const movimentoData = {
                userId: palpite.userId,
                para: palpite.userId,
                de: 'ADMIN_USER_ID', // Ou outra referência de sistema
                valorreal: cardTotalPontosGanhos,
                preco: cardTotalPontosGanhos,
                estado: "Palpite Paid",
                temporada: temporadaKey,
                nomeJogo: palpite.nomeJogo,
                detalhes: { transacaoId: transacaoId, jogoId: palpite.jogoId }
            };

            if (movSnapshot.empty) {
                // Se não existe, SÓ CRIA se o utilizador ganhou pontos (> 0)
                if (cardTotalPontosGanhos > 0) {
                    movimentoData.movimentoData = serverTimestamp();
                    await addDoc(collection(db, 'movimentos'), movimentoData);
                }
            } else {
                // Se já existe, ATUALIZA com o novo valor.
                // Isto corrige casos em que o árbitro muda de 'acerto' para 'falha' (valor vira 0)
                const docId = movSnapshot.docs[0].id;
                await updateDoc(doc(db, 'movimentos', docId), movimentoData);
            }
            
            // Adiciona o utilizador à lista de afetados para recalcular o seu total no final
            affectedUserIds.add(palpite.userId);
        }
    }
    
    return affectedUserIds;
}


async function processGameMods(ronda) {
    const affectedUserIds = new Set();
    
    const pModsQuery = query(collection(db, 'palpitesmods'), where("ronda", "==", ronda));
    const pModsSnapshot = await getDocs(pModsQuery);
    const allPalpitesMods = pModsSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));

    if (allPalpitesMods.length === 0) return affectedUserIds;

    const pOriginaisQuery = query(collection(db, 'palpites'), where("ronda", "==", ronda));
    const pOriginaisSnapshot = await getDocs(pOriginaisQuery);
    const allPalpitesDaRonda = pOriginaisSnapshot.docs.map(d => ({ id: d.id, ...d.data() }));
    
    const modsRules = {};

    const groupedByMod = allPalpitesMods.reduce((acc, p) => {
        acc[p.modId] = acc[p.modId] || [];
        acc[p.modId].push(p);
        return acc;
    }, {});

    for (const modId in groupedByMod) {
        if (!modsRules[modId]) {
            const modRef = doc(db, 'mods', modId);
            const modSnap = await getDoc(modRef);
            if (modSnap.exists()) {
                modsRules[modId] = modSnap.data();
            }
        }
        
        const modData = modsRules[modId];
        if (!modData) continue;

        if (modData.nomeMod === 'CRUSH BONES') {
            for (const pMod of groupedByMod[modId]) {
                const jogadorId = pMod.userId;
                const updatesForThisModDoc = {};

                for (const jogoId in pMod.selecoes) {
                    const aposta = pMod.selecoes[jogoId];
                    const alvoUserId = aposta.copiedFromUserId;
                    const palpiteAlvoTexto = aposta.palpiteSelecionado;
                    
                    const palpiteDoAlvo = allPalpitesDaRonda.find(p => p.userId === alvoUserId && p.jogoId === jogoId);
                    if (!palpiteDoAlvo) continue;

                    let statusDoAlvo = null;
                    for (let i = 1; i <= 10; i++) {
                        if (palpiteDoAlvo[`palpite${i}`] === palpiteAlvoTexto) {
                            statusDoAlvo = palpiteDoAlvo[`palpite${i}Status`];
                            break;
                        }
                    }

                    if (statusDoAlvo !== 'acerto' && statusDoAlvo !== 'falha') continue;

                    let pontosJogador = 0, pontosAlvo = 0;
                    if (statusDoAlvo === 'falha') {
                        pontosJogador = modData.regras.onAcerto.jogador;
                        pontosAlvo = modData.regras.onAcerto.alvo;
                    } else { // 'acerto'
                        pontosJogador = modData.regras.onFalha.jogador;
                        pontosAlvo = modData.regras.onFalha.alvo;
                    }

                    // --- INÍCIO DO BLOCO MODIFICADO ---
                    // Prepara a atualização para ambos os campos no documento 'palpitesmods'
                    const updatePathJogador = `selecoes.${jogoId}.pontosGanhosJogador`;
                    updatesForThisModDoc[updatePathJogador] = pontosJogador;
                    
                    // A LINHA NOVA ESTÁ AQUI:
                    const updatePathAlvo = `selecoes.${jogoId}.pontosGanhosJogadorAlvo`;
                    updatesForThisModDoc[updatePathAlvo] = pontosAlvo;
                    // --- FIM DO BLOCO MODIFICADO ---


                    const transacaoModId = `${jogadorId}-${alvoUserId}-${jogoId}`;
                    const movQuery = query(collection(db, 'movimentos'), where("detalhes.transacaoModId", "==", transacaoModId));
                    const movSnapshot = await getDocs(movQuery);
                    
                    const temporadaKey = pMod.temporada.replace('/', '');
                    const commonDetails = {
                        modId: modId, nomeMod: modData.nomeMod, jogoId: jogoId,
                        transacaoModId: transacaoModId, autorUserId: jogadorId,
                        alvoUserId: alvoUserId, palpiteAlvo: palpiteAlvoTexto
                    };

                    if (movSnapshot.empty) {
                        const movJogador = { userId: jogadorId, valorreal: pontosJogador, estado: "Mod Play", temporada: temporadaKey, ronda: ronda, movimentoData: serverTimestamp(), detalhes: commonDetails };
                        const movAlvo = { userId: alvoUserId, valorreal: pontosAlvo, estado: "Mod Play", temporada: temporadaKey, ronda: ronda, movimentoData: serverTimestamp(), detalhes: commonDetails };
                        await Promise.all([addDoc(collection(db, 'movimentos'), movJogador), addDoc(collection(db, 'movimentos'), movAlvo)]);
                    } else {
                        const updatePromises = movSnapshot.docs.map(docSnap => {
                            const movData = docSnap.data();
                            const novoValor = movData.userId === jogadorId ? pontosJogador : pontosAlvo;
                            return updateDoc(doc(db, 'movimentos', docSnap.id), { valorreal: novoValor, detalhes: commonDetails, ronda: ronda });
                        });
                        await Promise.all(updatePromises);
                    }
                    affectedUserIds.add(jogadorId);
                    affectedUserIds.add(alvoUserId);
                }

                if (Object.keys(updatesForThisModDoc).length > 0) {
                    await updateDoc(doc(db, 'palpitesmods', pMod.id), updatesForThisModDoc);
                    console.log(`Documento palpite mod ${pMod.id} atualizado com os resultados.`);
                }
            }
        }
    }
    return affectedUserIds;
}


async function recalculateUserTotals(userIds, temporadaKey) {
    const estadosQueValemPontos = ["Palpite Paid", "Mod Play"];

    for (const userId of userIds) {
        const userRef = doc(db, 'users', userId);
        const userUpdatePayload = {};

        // GCOINS (todos os movimentos)
        const gcoinsQuery = query(collection(db, 'movimentos'), where("userId", "==", userId), where("temporada", "==", temporadaKey));
        let totalGCoins = 0;
        const gcoinsSnapshot = await getDocs(gcoinsQuery);
        gcoinsSnapshot.forEach(doc => totalGCoins += (doc.data().valorreal || 0));
        userUpdatePayload[`${temporadaKey}GCoins`] = totalGCoins;

        // PONTOS (apenas estados válidos)
        const pontosQuery = query(collection(db, 'movimentos'), where("userId", "==", userId), where("temporada", "==", temporadaKey), where("estado", "in", estadosQueValemPontos));
        let totalPontos = 0;
        const pontosSnapshot = await getDocs(pontosQuery);
        pontosSnapshot.forEach(doc => totalPontos += (doc.data().valorreal || 0));
        userUpdatePayload[`${temporadaKey}Pontos`] = totalPontos;
        
        if (Object.keys(userUpdatePayload).length > 0) {
            await updateDoc(userRef, userUpdatePayload);
            console.log(`Utilizador ${userId} atualizado: Pontos=${totalPontos}, GCoins=${totalGCoins}`);
        }
    }
}


















     async function fetchTotalEligibleVoters() {
      let qualifiedGPlayers = [];
    try {
        const usersRef = collection(db, 'users');
        const q = query(usersRef, where("aceite", "==", "Yes"), where("natabela", "==", "Yes"));
        const querySnapshot = await getDocs(q);
        querySnapshot.forEach((doc) => {
            qualifiedGPlayers.push({
                id: doc.id, // O ID único do documento (ex: wOBhvgwz7g...)
                nometabela: doc.data().nometabela // O nome para exibir (ex: Gabriel)
            });
        });
        // Ordena a lista de jogadores pelo nome de tabela
        qualifiedGPlayers.sort((a, b) => a.nometabela.localeCompare(b.nometabela));

    } catch (error) {
    
            console.error("Erro ao obter a contagem total de votantes:", error);
            totalEligibleVoters = 0; 
        }
    }

    function addDynamicEventListeners() {
         document.querySelectorAll('.status-select').forEach(select => {
             select.replaceWith(select.cloneNode(true));
         });
         document.querySelectorAll('.points-input').forEach(input => {
             input.replaceWith(input.cloneNode(true));
         });
         document.querySelectorAll('.status-select').forEach(select => {
             select.addEventListener('change', async (e) => {
                const palpiteId = e.target.dataset.palpiteId;
                 const statusKey = e.target.dataset.statusKey;
                 const newStatus = e.target.value;
                 if (!palpiteId || !statusKey) return;
                 try {
                     const palpiteRef = doc(db, 'palpites', palpiteId);
                     await updateDoc(palpiteRef, { [statusKey]: newStatus });
                     e.target.className = `status-select ${newStatus}`;
                     const predictionNumberSpan = e.target.closest('.prediction-value')?.querySelector('.prediction-number');
                     if (predictionNumberSpan) {
                         predictionNumberSpan.className = `prediction-number ${newStatus}`;
                     }
                     const localPredictionIndex = allPredictions.findIndex(p => p.id === palpiteId);
                     if(localPredictionIndex > -1) allPredictions[localPredictionIndex][statusKey] = newStatus;
                 } catch (error) {
                     console.error('Error updating status:', error);
                     alert('Erro ao atualizar o status.');
                     const localPrediction = allPredictions.find(p => p.id === palpiteId);
                     if (localPrediction) {
                         e.target.value = localPrediction[statusKey] || 'neutro';
                         e.target.className = `status-select ${e.target.value}`;
                         const predictionNumberSpan = e.target.closest('.prediction-value')?.querySelector('.prediction-number');
                         if (predictionNumberSpan) {
                             predictionNumberSpan.className = `prediction-number ${e.target.value}`;
                         }
                     }
                 }
             });
         });
         document.querySelectorAll('.points-input').forEach(input => {
             input.addEventListener('change', async (e) => {
                 const palpiteId = e.target.dataset.palpiteId;
                 const pontosKey = e.target.dataset.pontosKey;
                 const value = e.target.value;
                 if (!palpiteId || !pontosKey) return;
                 const pointsValue = value ? parseInt(value) : 0;
                 if (value && (pointsValue < 0 || pointsValue > 999)) {
                     alert('Por favor, insira um número entre 0 e 999.');
                     const localPrediction = allPredictions.find(p => p.id === palpiteId);
                     e.target.value = localPrediction ? (localPrediction[pontosKey] || '') : '';
                     return;
                 }
                 try {
                     const palpiteRef = doc(db, 'palpites', palpiteId);
                     await updateDoc(palpiteRef, { [pontosKey]: pointsValue });
                     const localPredictionIndex = allPredictions.findIndex(p => p.id === palpiteId);
                     if(localPredictionIndex > -1) allPredictions[localPredictionIndex][pontosKey] = pointsValue;
                 } catch (error) {
                     console.error('Error updating points:', error);
                     alert('Erro ao atualizar os pontos.');
                     const localPrediction = allPredictions.find(p => p.id === palpiteId);
                     e.target.value = localPrediction ? (localPrediction[pontosKey] || '') : '';
                 }
             });
         });
     }

  document.getElementById('launch-button').addEventListener('click', unifiedLaunchHandler);
 

    function parsePopupTables() {
        const tables = document.querySelectorAll('#settings-popup #outputTables table');
        const tableDataMap = {};
        tables.forEach(table => {
            const subCategoriaOriginal = table.dataset.originalCategory;
            if (subCategoriaOriginal && !tableDataMap[subCategoriaOriginal]) {
                tableDataMap[subCategoriaOriginal] = {};
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length === 3) {
                        const opcao = cells[0].textContent.trim();
                        const scoreText = cells[2].querySelector('b') ? cells[2].querySelector('b').textContent.trim() : cells[2].textContent.trim();
                        const score = parseInt(scoreText, 10);
                        if (opcao && !isNaN(score)) {
                            tableDataMap[subCategoriaOriginal][opcao] = score;
                        }
                    }
                });
            }
        });
        return tableDataMap;
    }

    async function autoFillPoints() {
        const autoFillButton = document.getElementById('auto-fill-button');
        const rocketIcon = autoFillButton.querySelector('.fa-rocket');
        const loadingSpinner = autoFillButton.querySelector('.fa-spinner');
        autoFillButton.disabled = true;
        rocketIcon.style.display = 'none';
        loadingSpinner.style.display = 'inline-block';
        console.log("Auto-fill process started...");
        try {
            const popupTablesData = parsePopupTables();
            if (Object.keys(popupTablesData).length === 0) {
                alert("Nenhuma tabela de conversão encontrada no popup.\n\n1. Cole as odds na área de texto.\n2. Clique em 'Criar Tabela'.\n3. Tente preencher automaticamente novamente.");
                throw new Error("No conversion tables found in popup.");
            }
            const visiblePredictionElements = document.querySelectorAll('#predictions-container .prediction-card');
            if (visiblePredictionElements.length === 0) {
                alert("Nenhum palpite visível na página para preencher.\nVerifique os filtros de Ronda/Jogo/GPlayer.");
                throw new Error("No visible predictions to process.");
            }
            let updatesMade = 0;
            let notFoundCount = 0;
            let missingDataCount = 0;
            let saveErrors = 0;
            const savePromises = [];
            for (const cardElement of visiblePredictionElements) {
                const palpiteId = cardElement.dataset.predictionId;
                if (!palpiteId) continue;
                const palpiteData = allPredictions.find(p => p.id === palpiteId);
                if (!palpiteData) {
                    console.warn(`Dados locais para o palpite visível ${palpiteId} não encontrados.`);
                    missingDataCount++;
                    continue;
                }
                const numeroPalpites = palpiteData.numeroPalpites || 0;
                if (numeroPalpites === 0) continue;
                for (let i = 1; i <= numeroPalpites; i++) {
                    const indiceKey = `Palpite${i}IndiceIngles`;
                    const pontosInputSelector = `.points-input[data-palpite-id="${palpiteId}"][data-pontos-key="Palpite${i}PontosQuanto"]`;
                    const pontosInputElement = cardElement.querySelector(pontosInputSelector);
                    if (!pontosInputElement) {
                        continue;
                    }
                    if (palpiteData[indiceKey] && palpiteData[indiceKey].PalpiteSubCategoria && palpiteData[indiceKey].PalpiteCategoria3) {
                        const subCategoriaKey = palpiteData[indiceKey].PalpiteSubCategoria;
                        const opcaoKey = palpiteData[indiceKey].PalpiteCategoria3;
                        if (popupTablesData[subCategoriaKey] && popupTablesData[subCategoriaKey][opcaoKey] !== undefined) {
                            const score = popupTablesData[subCategoriaKey][opcaoKey];
                            if (pontosInputElement.value !== String(score)) {
                                pontosInputElement.value = score;
                                updatesMade++;
                                const pontosKey = `Palpite${i}PontosQuanto`;
                                const localPredictionIndex = allPredictions.findIndex(p => p.id === palpiteId);
                                if (localPredictionIndex > -1) {
                                    allPredictions[localPredictionIndex][pontosKey] = score;
                                }
                                const updateData = { [pontosKey]: score };
                                const palpiteRef = doc(db, 'palpites', palpiteId);
                                const savePromise = updateDoc(palpiteRef, updateData)
                                    .then(() => {
                                        console.log(`Auto-saved score ${score} for ${palpiteId}, field ${pontosKey}`);
                                    })
                                    .catch(error => {
                                        console.error(`Error auto-saving points for ${palpiteId}, field ${pontosKey}:`, error);
                                        saveErrors++;
                                    });
                                savePromises.push(savePromise);
                            }
                        } else {
                            notFoundCount++;
                        }
                    } else {
                        missingDataCount++;
                    }
                }
            }
            await Promise.all(savePromises);
            console.log(`Auto-fill process finished. Updates: ${updatesMade}, Not Found: ${notFoundCount}, Missing Data: ${missingDataCount}, Save Errors: ${saveErrors}.`);
            let alertMessage = `Preenchimento automático concluído!\n\nCaixas atualizadas e gravadas: ${updatesMade}`;
            if (notFoundCount > 0) alertMessage += `\nCombinações não encontradas nas tabelas: ${notFoundCount}`;
            if (missingDataCount > 0) alertMessage += `\nPalpites com dados em falta: ${missingDataCount}`;
            if (saveErrors > 0) alertMessage += `\nFalhas ao gravar automaticamente: ${saveErrors}`;
            alert(alertMessage);
        } catch (error) {
             console.error('Error during auto-fill process:', error);
             if (error.message !== "No conversion tables found in popup." && error.message !== "No visible predictions to process.") {
                 alert(`Ocorreu um erro durante o preenchimento automático:\n${error.message}`);
             }
        } finally {
             autoFillButton.disabled = false;
             rocketIcon.style.display = 'inline-block';
             loadingSpinner.style.display = 'none';
        }
     }

    const autoFillButton = document.getElementById('auto-fill-button');
     if (autoFillButton) {
         autoFillButton.addEventListener('click', autoFillPoints);
     } else {
         console.error("Botão de auto-preenchimento (foguetão) não encontrado!");
     }

    loadPredictions();
    fetchTotalEligibleVoters();
</script>




    <!-- == CONVERTER JAVASCRIPT START == -->
    <!-- (O script do conversor IIFE fica aqui, exatamente como fornecido na resposta anterior) -->
    <script>
    (function() { // Self-executing anonymous function for the converter

        // ========================================================================
        // === REPLACED DATA DEFINITIONS (FROM FILE 1) ===
        // ========================================================================

        const categories = [ /* Copied from File 1 */
         // 1. Resultado Final
         "Result", "Double Chance", "Draw No Bet",
         // 2. Golos (Excluindo "Total", "Asian Total")
         "Both Teams to Score", /*"Asian Total",*/ "Total Odd/Even", "1st Goal", "2nd Goal", "3rd Goal", "4th Goal", "5th Goal", "Last Goal", "Goal in Both Halves", "Both Halves Over 1.5", "Both Halves Under 1.5", "Both Halves Over 2.5", "Both Halves Under 2.5", "Both Teams to Score in Both Halves", "Total Goals", "Total Goals 0 - 1", "Total Goals 1 - 2", "Total Goals 1 - 3", "Total Goals 2 - 3", "Total Goals 2 - 4", "Total Goals 2 - 5", "Total Goals 2 - 6", "Total Goals 3 - 4", "Total Goals 3 - 5", "Total Goals 4 - 5", "Total Goals 4 - 6", "Scoring draw", "Only One Team to Score", "Both Teams to Score at Least 1 Half", "Race to 2 Goals", "Race to 3 Goals", "1st Goal to Score", "2nd Goal to Score", "Total", // Added Total here conceptually, though mapped elsewhere
         // 3. Handicap (Excluindo "Handicap", "Asian Handicap")
          "European Handicap (0:1)", "European Handicap (0:2)", "European Handicap (1:0)", "European Handicap (2:0)",
         // 4. Intervalo/Fim do Jogo (HT/FT)
         "Half time/Full time", "Half time/Full time - Home/Home", "Half time/Full time - Draw/Home", "Half time/Full time - Draw/Draw", "Half time/Full time - Draw/Away", "Half time/Full time - Away/Away", "Half time/Full time Double Chance",
         // 5. Resultado Exato (Placar)
         "Correct Score", "Match Score 1:0, 2:0 or 2:1", "Match Score 0:0, 1:0 or 2:0", "Match Score 1:0, 2:0 or 1:1", "Match Score 1:0, 2:0 or 3:0", "Match Score 2:0, 3:0 or 3:1", "Match Score 1:0, 0:0 or 0:1", "Match Score 0:1, 0:2 or 1:2", "Match Score 0:0, 0:1 or 0:2", "Match Score 0:1, 0:2 or 1:1", "Match Score 0:1, 0:2 or 0:3", "Match Score 0:2, 0:3 or 1:3",
         // 6. Específicos por Equipa
         "Total Team 1", "Total Team 2", "Total Goals Team 1", "Total Goals Team 2", "Team 1 to Score", "Team 2 to Score", "Goal in Both Halves: Team 1", "Goal in Both Halves: Team 2", "Team 1: Total Goals 0 - 1", "Team 1: Total Goals 1 - 2", "Team 1: Total Goals 1 - 3", "Team 1: Total Goals 1 - 4", "Team 1: Total Goals 2 - 3", "Team 1: Total Goals 2 - 4", "Team 1: Total Goals 3 - 4", "Team 1: Total Goals 3 - 6", "Team 2: Total Goals 0 - 1", "Team 2: Total Goals 1 - 2", "Team 2: Total Goals 1 - 3", "Team 2: Total Goals 1 - 4", "Team 2: Total Goals 2 - 3", "Team 2: Total Goals 2 - 4", "Team 2: Total Goals 3 - 4", "Team 2: Total Goals 3 - 6", "Each Team Over 1.5", "Each Team Under 1.5", "Team 1 to Score 2 Goals in a Row", "Team 1 to Score 3 Goals in a Row", "Team 2 to Score 2 Goals in a Row", "Team 2 to Score 3 Goals in a Row", "Win 1 at Least 1 Half", "Win 2 at Least 1 Half", "Win 1 in Both Halves", "Team 1 Highest Scoring Half", "Team 2 Highest Scoring Half",
         "Team 1 Score Its 1st Goal", "Team 1 Score Its 2nd Goal", "Team 2 to Score Its 1st Goal", "Team 2 to Score Its 2nd Goal",
         // 7. Mercados Combinados
         "Both Teams to Score and Total", "Result and Total", "Double Chance & Total", "Result and Both Teams to Score:", "Double Chance and Both Teams to Score", "Result or Total", "Result or Both Teams To Score:", "Total or Both Teams to Score:", "Team 1 Win 1st Half & Not Win Match", "Team 2 Win 1st Half & Not Win Match", "Team 1 to Score First & Win", "Team 1 to Score First & Not Win", "Team 2 to Score First & Win", "Team 2 to Score First & Not Win", "Team 1 to Win to Nil", "Team 2 to Win to Nil", "1st half Over (0.5) and 2nd half Over (1.5)", "1st half Over (1.5) and 2nd half Over (0.5)", "Total Over (3.5) and 1st half Over (1.5)", "Win1 and 1st half Over (1.5)", "Win2 and 1st half Over (1.5)", "Win1 and 1st half H1 (-1.5)", "Win2 and 1st half H2 (-1.5)", "H1 (-2.5) and 1st half Win1", "H2 (-2.5) and 1st half Win2", "H1 (-1.5) and 1st half Win1", "H2 (-1.5) and 1st half Win2", "Win1 and Team1 Over (1.5)", "Win2 and Team2 Over (1.5)", "Team 1 to Score First and", "Team 2 to Score First and", "Team 1 to Score First and Total", "Team 2 to Score First and Total", "Half time/Full time and Total", "Win1 and Total Goals 2 - 3", "Win2 and Total Goals 2 - 3", "1st Half/2nd Half Both Teams to Score", "1st Half Result or Both Teams To Score:", "2nd Half Result or Both Teams To Score:", "Half time/Full time and Both Teams to Score", "Penalty & Sending Off", "Penalty or Sending Off",
         // 8. Tempo (Timing)
         "Highest Scoring Half", "1st Goal Minute", "2nd Goal Minute", "Goal from 1 to 10 min.", "Goal from 1 to 15 min.", "Goal from 1 to 20 min.", "Goal from 1 to 25 min.", "Goal from 1 to 30 min.", "Goal from 1 to 35 min.", "Goal from 1 to 40 min.", "Goal from 46 to 60 min.", "Goal from 46 to 65 min.", "Goal from 46 to 70 min.", "Goal from 46 to 75 min.", "Goal from 46 to 80 min.", "Goal from 46 to 85 min.", "Goal from 76 to 90+ min.", "Result from 1 to 10 min.", "Result from 1 to 30 min.", "Result from 1 to 50 min.", "Result from 1 to 60 min.", "Result from 1 to 70 min", "Result from 1 to 75 min", "1-15 min.", "16-30 min.", "31-45+ min.", "46-60 min.", "61-75 min.", "76-90+ min.", "Total Goal Minutes",
         // 9. Por Parte (1ª Parte / 2ª Parte) (Excluindo Handicaps/Totals especiais)
         "1st Half: Goal", "2nd Half: Goal", "1st Half: Sending Off", "2nd Half: Sending Off", "1st Half: Penalty", "2nd Half: Penalty", "1st half: Both Teams to Score", "2nd half: Both Teams to Score", /*"1st half: Total",*/ "1st half: Total Team 1", "1st half: Total Team 2", /*"1st half: Asian Total",*/ "1st half: Total Even/Odd", /*"2nd half: Total",*/ "2nd half: Total Team 1", "2nd half: Total Team 2", /*"2nd half: Asian Total",*/ "2nd half: Total Even/Odd", /*"1st half: Handicap", "1st half: Asian Handicap", "2nd half: Handicap", "2nd half: Asian Handicap",*/ "1st half: Correct Score", "2nd half: Correct Score", "1st half: Result", "1st half: Double Chance", "1st half: Team 1 to Score", "1st half: Team 2 to Score", "1st half: Result and Total", "1st half: Result and Both Teams to Score:", "1st half: 1st Goal", "1st half: 2nd Goal", "1st half: 3rd Goal", "1st half: European Handicap (0:1)", "1st half: European Handicap (1:0)", "1st half: Total Goals 0 - 1", "1st half: Total Goals 1 - 2", "1st half: Total Goals 1 - 3", "1st half: Total Goals 2 - 3", "1st half: Total Goals 2 - 4", "1st half: Total Goals 2 - 5", "1st half: Total Goals 2 - 6", "1st half: Total Goals 3 - 4", "1st half: Total Goals 3 - 5", "1st half: Team 1: Total Goals 0 - 1", "1st half: Team 1: Total Goals 1 - 2", "1st half: Team 1: Total Goals 1 - 3", "1st half: Team 1: Total Goals 1 - 4", "1st half: Team 1: Total Goals 2 - 3", "1st half: Team 1: Total Goals 2 - 4", "1st half: Team 2: Total Goals 0 - 1", "1st half: Team 2: Total Goals 1 - 2", "1st half: Team 2: Total Goals 1 - 3", "1st half: Team 2: Total Goals 1 - 4", "1st half: Team 2: Total Goals 2 - 3", "1st half: Team 2: Total Goals 2 - 4", "1st half: Total Goals Team 1", "1st half: Total Goals Team 2", "1st half: Total Goals", "1st half: Team 1 to Win to Nil", "1st half: Team 2 to Win to Nil", "1st half: Last Goal", "2nd half: Result", "2nd half: Double Chance", "2nd half: Team 1 to Score", "2nd half: Team 2 to Score", "2nd half: 1st Goal", "2nd half: 2nd Goal", "2nd half: 3rd Goal", "2nd half: European Handicap (0:1)", "2nd half: European Handicap (1:0)", "2nd half: Total Goals 0 - 1", "2nd half: Total Goals 1 - 2", "2nd half: Total Goals 1 - 3", "2nd half: Total Goals 2 - 3", "2nd half: Total Goals 2 - 4", "2nd half: Total Goals 2 - 5", "2nd half: Total Goals 2 - 6", "2nd half: Total Goals 3 - 4", "2nd half: Total Goals 3 - 5", "2nd half: Team 1: Total Goals 0 - 1", "2nd half: Team 1: Total Goals 1 - 2", "2nd half: Team 1: Total Goals 1 - 3", "2nd half: Team 1: Total Goals 1 - 4", "2nd half: Team 1: Total Goals 2 - 3", "2nd half: Team 1: Total Goals 2 - 4", "2nd half: Team 2: Total Goals 0 - 1", "2nd half: Team 2: Total Goals 1 - 2", "2nd half: Team 2: Total Goals 1 - 3", "2nd half: Team 2: Total Goals 1 - 4", "2nd half: Team 2: Total Goals 2 - 3", "2nd half: Team 2: Total Goals 2 - 4", "2nd half: Total Goals Team 1", "2nd half: Total Goals Team 2", "2nd half: Total Goals", "2nd half: Team 1 to Win to Nil", "2nd half: Team 2 to Win to Nil", "2nd half: Last Goal", "1st half or match",
         // 10. Mercados Especiais / Eventos
         "Tie Breaker", "Penalty", "Sending Off", "Sending Off Team 1", "Sending Off Team 2", "1st to Happen:", "How is Scored 1st Goal", "Team 1 Winning Margin 1 Goal", "Team 1 Winning Margin 2 Goals", "Team 1 Winning Margin 1 or 2 Goals", "Team 1 Winning Margin 2 or 3 Goals", "Team 1 Winning Margin 2 or more Goals", "Team 1 Winning Margin 1 Goal or Draw", "Team 1 Winning Margin 2 Goals or Draw", "Team 2 Winning Margin 1 Goal", "Team 2 Winning Margin 2 Goals", "Team 2 Winning Margin 1 or 2 Goals", "Team 2 Winning Margin 2 or 3 Goals", "Team 2 Winning Margin 2 or more Goals", "Team 2 Winning Margin 1 Goal or Draw", "Team 2 Winning Margin 2 Goals or Draw", "Draw in at least one of the Halves", "Any Team Winning Margin 1", "Any Team Winning Margin 2", "Any Team Winning Margin 3", "Any Team Winning Margin 2 & more", "Any Team Winning Margin 3 & more", "Team 1 win from Behind", "Team 2 Win from Behind", "Own Goal", "Double", "1:1 During The Match", "2:0 or 0:2 During The Match", "2:0 During The Match", "0:2 During The Match", "To Miss A Penalty", "To Score A Penalty", "Red card in both teams",
         // 11. Cantos (Excluindo "Corners: Total", "Corners: Handicap")
         /*"Corners: Total",*/ "Corners: Total Team 1", "Corners: Total Team 2", "Corners: Total Even/Odd", "Corners: 1st Half: Total:", "Corners: 1st Half: Total Team 1", "Corners: 1st Half: Total Team 2", "Corners: 2nd Half: Total", "Corners: 2nd Half: Total Team 1", "Corners: 2nd Half: Total Team 2", "Corners: Total (3 way)", /*"Corners: Handicap",*/ "Corners: 1st Half: Handicap", "Corners: 2nd Half: Handicap", "Corners: Result", "Corners: 1st Half: Result", "Corners: 2nd Half: Result", "Corners: Highest Scoring Half", "Corners: 1st Corner", "Corners: Last Corner:", "Corners: 10 Minutes Corners (00:00-9:59)", "Corners: Race to Corners",
         // 12. Cartões Amarelos (Excluindo "Yellow Cards: Total", "Yellow Cards: Handicap")
         /*"Yellow Cards: Total",*/ "Yellow Cards: Total Team 1", "Yellow Cards: Total Team 2", "Yellow Cards: Total Odd/Even", "Yellow Cards: 1st Half: Total:", "Yellow Cards: 1st Half: Total Team 1", "Yellow Cards: 1st Half: Total Team 2", "Yellow Cards: 2nd Half: Total", /*"Yellow Cards: Handicap",*/ "Yellow Cards: 1st Half: Handicap", "Yellow Cards: 2nd Half: Handicap", "Yellow Cards: Result", "Yellow Cards: Double Chance", "Yellow Cards: 1st Half: Result", "Yellow Cards: 1st Half: Double Chance", "Yellow Cards: 2nd Half: Result", "Yellow Cards: 2nd Half: Double Chance", "Yellow Cards: Highest Scoring Half", "Yellow Cards: 1st Yellow Card Minute", "Yellow Cards: Both Teams to Receive Cards", "Yellow Cards: Both Teams to Receive 2 or More Cards",
         // 13. Remates à Baliza
         "Shots on target: Total", "Shots on target: Total Team 1", "Shots on target: Total Team 2", "Shots on target: Total Even/Odd", "Shots on target: 1st Half: Total:", "Shots on target: 1st Half: Total Team 1", "Shots on target: 1st Half: Total Team 2", "Shots on target: Handicap", "Shots on target: 1st Half: Handicap", "Shots on target: Result", "Shots on target: Double Chance", "Shots on target: 1st Half: Result", "Shots on target: 1st Half: Double Chance", "Shots on target: Highest Scoring Half",
         // 14. Faltas
         "Fouls: Total", "Fouls: Total Team 1", "Fouls: Total Team 2", "Fouls: Total Even/Odd", "Fouls: Handicap", "Fouls: Result", "Fouls: Double Chance", "Fouls: Highest Scoring Half",
         "Offsides: Total", "Offsides: Total Team 1", "Offsides: Total Team 2", "Offsides: Total Even/Odd", "Offsides: Handicap", "Offsides: Result", "Offsides: Double Chance",
         // 15. Remates Totais
         "Shots: Total", "Shots: Total Team 1", "Shots: Total Team 2", "Shots: Total Even/Odd", "Shots: 1st Half: Total Team 1", "Shots: 1st Half: Total Team 2", "Shots: Handicap", "Shots: 1st Half: Handicap", "Shots: Result", "Shots: Double Chance", "Shots: 1st Half: Result", "Shots: 1st Half: Double Chance", "Shots: Highest Scoring Half",
         // --- NOVAS Subcategorias "Specials:" ---
         "Specials: Total Headed Goals",
         "Specials: To Occur First - Corner or Goal:",
         "Specials: To Occur First - Throw in or Foul:",
         "Specials: 1st half 1X and Corners under 10.5 and Yellow Cards over 3.5:",
         "Specials: Over 9.5 corners & over 4.5 yellow cards:",
         "Specials: Over 9.5 corners & over 3.5 yellow cards:",
         "Specials: Win1, over 10.5 corners & over 3.5 yellow cards:",
         "Specials: Win1, over 9.5 corners & over 3.5 yellow cards:",
         "Specials: Win1, over 1.5 1st half goals & over 3.5 yellow cards:",
         "Specials: Over 1.5 1st half goals, over 3.5 yellow cards & over 10.5 corners",
         "Specials: Over 3.5 goals & over 10.5 corners:",
         "Specials: Over 2.5 goals & over 10.5 corners:",
         "Specials: Win1 & over 9.5 corners:",
         "Specials: Over 3.5 Goals, Over 9.5 Corners & Over 3.5 Yellow Card",
         "Specials: Under 3.5 goals, under 9.5 corners & under 3.5 yellow cards:",
         "Specials: Win1, corners win1 & yellow cards win1:",
         "Specials: Over 3.5 goals & under 10.5 corners:",
         "Specials: X2, yellow cards-win2 and corners over 9.5",
         "Specials: Win1 & over 3.5 yellow cards:",
         "Specials: Win1 & over 4.5 yellow cards:",
         "Specials: Win1 & over 10.5 corners:",
         "Specials: The medical team will appear on the field",
         "Specials: Goal from outside the penalty area:",
         "Specials: The goalkeeper will get a red card:",
         // 16. Jogadores
         "Players:" // Base for player markets
    ];

    const specialCategories = new Set([ /* Copied from File 1 */
        "Total", // Movida para Resultado Final no map, mas ainda especial para lógica
        "Asian Total",
        "Handicap",
        "Asian Handicap",
        "1st half: Total",
        "1st half: Asian Total",
        "1st half: Handicap",
        "1st half: Asian Handicap",
        "2nd half: Total",
        "2nd half: Asian Total",
        "2nd half: Handicap",
        "2nd half: Asian Handicap",
        "Corners: Total",
        "Corners: Handicap",
        "Yellow Cards: Total",
        "Yellow Cards: Handicap"
    ]);

    const categoryMap = { /* Copied from File 1 */
         // 1. Resultado Final
         "Result": "Resultado Final", "Double Chance": "Resultado Final", "Draw No Bet": "Resultado Final",
         // Total movido para Golos
         // 2. Golos
         "Total": "Golos", // <-- ALTERADO AQUI
         "Both Teams to Score": "Golos", "Asian Total": "Golos", "Total Odd/Even": "Golos", "1st Goal": "Golos", "2nd Goal": "Golos", "3rd Goal": "Golos", "4th Goal": "Golos", "5th Goal": "Golos", "Last Goal": "Golos", "Goal in Both Halves": "Golos", "Both Halves Over 1.5": "Golos", "Both Halves Under 1.5": "Golos", "Both Halves Over 2.5": "Golos", "Both Halves Under 2.5": "Golos", "Both Teams to Score in Both Halves": "Golos", "Total Goals": "Golos", "Total Goals 0 - 1": "Golos", "Total Goals 1 - 2": "Golos", "Total Goals 1 - 3": "Golos", "Total Goals 2 - 3": "Golos", "Total Goals 2 - 4": "Golos", "Total Goals 2 - 5": "Golos", "Total Goals 2 - 6": "Golos", "Total Goals 3 - 4": "Golos", "Total Goals 3 - 5": "Golos", "Total Goals 4 - 5": "Golos", "Total Goals 4 - 6": "Golos", "Scoring draw": "Golos", "Only One Team to Score": "Golos", "Both Teams to Score at Least 1 Half": "Golos", "Race to 2 Goals": "Golos", "Race to 3 Goals": "Golos", "1st Goal to Score": "Golos", "2nd Goal to Score": "Golos",
         // 3. Handicap
         "Handicap": "Handicap", "Asian Handicap": "Handicap", "European Handicap (0:1)": "Handicap", "European Handicap (0:2)": "Handicap", "European Handicap (1:0)": "Handicap", "European Handicap (2:0)": "Handicap",
         // 4. Intervalo/Fim do Jogo (HT/FT)
         "Half time/Full time": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Home/Home": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Draw/Home": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Draw/Draw": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Draw/Away": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time - Away/Away": "Intervalo/Fim do Jogo (HT/FT)", "Half time/Full time Double Chance": "Intervalo/Fim do Jogo (HT/FT)",
         // 5. Resultado Exato (Placar)
         "Correct Score": "Resultado Exato (Placar)", "Match Score 1:0, 2:0 or 2:1": "Resultado Exato (Placar)", "Match Score 0:0, 1:0 or 2:0": "Resultado Exato (Placar)", "Match Score 1:0, 2:0 or 1:1": "Resultado Exato (Placar)", "Match Score 1:0, 2:0 or 3:0": "Resultado Exato (Placar)", "Match Score 2:0, 3:0 or 3:1": "Resultado Exato (Placar)", "Match Score 1:0, 0:0 or 0:1": "Resultado Exato (Placar)", "Match Score 0:1, 0:2 or 1:2": "Resultado Exato (Placar)", "Match Score 0:0, 0:1 or 0:2": "Resultado Exato (Placar)", "Match Score 0:1, 0:2 or 1:1": "Resultado Exato (Placar)", "Match Score 0:1, 0:2 or 0:3": "Resultado Exato (Placar)", "Match Score 0:2, 0:3 or 1:3": "Resultado Exato (Placar)",
         // 6. Específicos por Equipa
         "Total Team 1": "Específicos por Equipa", "Total Team 2": "Específicos por Equipa", "Total Goals Team 1": "Específicos por Equipa", "Total Goals Team 2": "Específicos por Equipa", "Team 1 to Score": "Específicos por Equipa", "Team 2 to Score": "Específicos por Equipa", "Goal in Both Halves: Team 1": "Específicos por Equipa", "Goal in Both Halves: Team 2": "Específicos por Equipa", "Team 1: Total Goals 0 - 1": "Específicos por Equipa", "Team 1: Total Goals 1 - 2": "Específicos por Equipa", "Team 1: Total Goals 1 - 3": "Específicos por Equipa", "Team 1: Total Goals 1 - 4": "Específicos por Equipa", "Team 1: Total Goals 2 - 3": "Específicos por Equipa", "Team 1: Total Goals 2 - 4": "Específicos por Equipa", "Team 1: Total Goals 3 - 4": "Específicos por Equipa", "Team 1: Total Goals 3 - 6": "Específicos por Equipa", "Team 2: Total Goals 0 - 1": "Específicos por Equipa", "Team 2: Total Goals 1 - 2": "Específicos por Equipa", "Team 2: Total Goals 1 - 3": "Específicos por Equipa", "Team 2: Total Goals 1 - 4": "Específicos por Equipa", "Team 2: Total Goals 2 - 3": "Específicos por Equipa", "Team 2: Total Goals 2 - 4": "Específicos por Equipa", "Team 2: Total Goals 3 - 4": "Específicos por Equipa", "Team 2: Total Goals 3 - 6": "Específicos por Equipa", "Each Team Over 1.5": "Específicos por Equipa", "Each Team Under 1.5": "Específicos por Equipa", "Team 1 to Score 2 Goals in a Row": "Específicos por Equipa", "Team 1 to Score 3 Goals in a Row": "Específicos por Equipa", "Team 2 to Score 2 Goals in a Row": "Específicos por Equipa", "Team 2 to Score 3 Goals in a Row": "Específicos por Equipa", "Win 1 at Least 1 Half": "Específicos por Equipa", "Win 2 at Least 1 Half": "Específicos por Equipa", "Win 1 in Both Halves": "Específicos por Equipa", "Team 1 Highest Scoring Half": "Específicos por Equipa", "Team 2 Highest Scoring Half": "Específicos por Equipa",
         "Team 1 Score Its 1st Goal": "Específicos por Equipa", "Team 1 Score Its 2nd Goal": "Específicos por Equipa", "Team 2 to Score Its 1st Goal": "Específicos por Equipa", "Team 2 to Score Its 2nd Goal": "Específicos por Equipa",
         // 7. Mercados Combinados
         "Both Teams to Score and Total": "Mercados Combinados", "Result and Total": "Mercados Combinados", "Double Chance & Total": "Mercados Combinados", "Result and Both Teams to Score:": "Mercados Combinados", "Double Chance and Both Teams to Score": "Mercados Combinados", "Result or Total": "Mercados Combinados", "Result or Both Teams To Score:": "Mercados Combinados", "Total or Both Teams to Score:": "Mercados Combinados", "Team 1 Win 1st Half & Not Win Match": "Mercados Combinados", "Team 2 Win 1st Half & Not Win Match": "Mercados Combinados", "Team 1 to Score First & Win": "Mercados Combinados", "Team 1 to Score First & Not Win": "Mercados Combinados", "Team 2 to Score First & Win": "Mercados Combinados", "Team 2 to Score First & Not Win": "Mercados Combinados", "Team 1 to Win to Nil": "Mercados Combinados", "Team 2 to Win to Nil": "Mercados Combinados", "1st half Over (0.5) and 2nd half Over (1.5)": "Mercados Combinados", "1st half Over (1.5) and 2nd half Over (0.5)": "Mercados Combinados", "Total Over (3.5) and 1st half Over (1.5)": "Mercados Combinados", "Win1 and 1st half Over (1.5)": "Mercados Combinados", "Win2 and 1st half Over (1.5)": "Mercados Combinados", "Win1 and 1st half H1 (-1.5)": "Mercados Combinados", "Win2 and 1st half H2 (-1.5)": "Mercados Combinados", "H1 (-2.5) and 1st half Win1": "Mercados Combinados", "H2 (-2.5) and 1st half Win2": "Mercados Combinados", "H1 (-1.5) and 1st half Win1": "Mercados Combinados", "H2 (-1.5) and 1st half Win2": "Mercados Combinados", "Win1 and Team1 Over (1.5)": "Mercados Combinados", "Win2 and Team2 Over (1.5)": "Mercados Combinados", "Team 1 to Score First and": "Mercados Combinados", "Team 2 to Score First and": "Mercados Combinados", "Team 1 to Score First and Total": "Mercados Combinados", "Team 2 to Score First and Total": "Mercados Combinados", "Half time/Full time and Total": "Mercados Combinados", "Win1 and Total Goals 2 - 3": "Mercados Combinados", "Win2 and Total Goals 2 - 3": "Mercados Combinados", "1st Half/2nd Half Both Teams to Score": "Mercados Combinados", "1st Half Result or Both Teams To Score:": "Mercados Combinados", "2nd Half Result or Both Teams To Score:": "Mercados Combinados", "Half time/Full time and Both Teams to Score": "Mercados Combinados", "Penalty & Sending Off": "Mercados Combinados", "Penalty or Sending Off": "Mercados Combinados",
         "Specials: 1st half 1X and Corners under 10.5 and Yellow Cards over 3.5:": "Mercados Combinados", "Specials: Over 9.5 corners & over 4.5 yellow cards:": "Mercados Combinados", "Specials: Over 9.5 corners & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, over 10.5 corners & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, over 9.5 corners & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, over 1.5 1st half goals & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Over 1.5 1st half goals, over 3.5 yellow cards & over 10.5 corners": "Mercados Combinados", "Specials: Over 3.5 goals & over 10.5 corners:": "Mercados Combinados", "Specials: Over 2.5 goals & over 10.5 corners:": "Mercados Combinados", "Specials: Win1 & over 9.5 corners:": "Mercados Combinados", "Specials: Over 3.5 Goals, Over 9.5 Corners & Over 3.5 Yellow Card": "Mercados Combinados", "Specials: Under 3.5 goals, under 9.5 corners & under 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1, corners win1 & yellow cards win1:": "Mercados Combinados", "Specials: Over 3.5 goals & under 10.5 corners:": "Mercados Combinados", "Specials: X2, yellow cards-win2 and corners over 9.5": "Mercados Combinados", "Specials: Win1 & over 3.5 yellow cards:": "Mercados Combinados", "Specials: Win1 & over 4.5 yellow cards:": "Mercados Combinados", "Specials: Win1 & over 10.5 corners:": "Mercados Combinados",
         // 8. Tempo (Timing)
         "Highest Scoring Half": "Tempo (Timing)", "1st Goal Minute": "Tempo (Timing)", "2nd Goal Minute": "Tempo (Timing)", "Goal from 1 to 10 min.": "Tempo (Timing)", "Goal from 1 to 15 min.": "Tempo (Timing)", "Goal from 1 to 20 min.": "Tempo (Timing)", "Goal from 1 to 25 min.": "Tempo (Timing)", "Goal from 1 to 30 min.": "Tempo (Timing)", "Goal from 1 to 35 min.": "Tempo (Timing)", "Goal from 1 to 40 min.": "Tempo (Timing)", "Goal from 46 to 60 min.": "Tempo (Timing)", "Goal from 46 to 65 min.": "Tempo (Timing)", "Goal from 46 to 70 min.": "Tempo (Timing)", "Goal from 46 to 75 min.": "Tempo (Timing)", "Goal from 46 to 80 min.": "Tempo (Timing)", "Goal from 46 to 85 min.": "Tempo (Timing)", "Goal from 76 to 90+ min.": "Tempo (Timing)", "Result from 1 to 10 min.": "Tempo (Timing)", "Result from 1 to 30 min.": "Tempo (Timing)", "Result from 1 to 50 min.": "Tempo (Timing)", "Result from 1 to 60 min.": "Tempo (Timing)", "Result from 1 to 70 min": "Tempo (Timing)", "Result from 1 to 75 min": "Tempo (Timing)", "1-15 min.": "Tempo (Timing)", "16-30 min.": "Tempo (Timing)", "31-45+ min.": "Tempo (Timing)", "46-60 min.": "Tempo (Timing)", "61-75 min.": "Tempo (Timing)", "76-90+ min.": "Tempo (Timing)", "Total Goal Minutes": "Tempo (Timing)",
         // 9. Por Parte (1ª Parte / 2ª Parte)
         "1st Half: Goal": "Por Parte (1ª Parte / 2ª Parte)", "2nd Half: Goal": "Por Parte (1ª Parte / 2ª Parte)", "1st Half: Sending Off": "Por Parte (1ª Parte / 2ª Parte)", "2nd Half: Sending Off": "Por Parte (1ª Parte / 2ª Parte)", "1st Half: Penalty": "Por Parte (1ª Parte / 2ª Parte)", "2nd Half: Penalty": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Both Teams to Score": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Both Teams to Score": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Team 1": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Team 2": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Asian Total": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Even/Odd": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Team 1": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Team 2": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Asian Total": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Even/Odd": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Handicap": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Asian Handicap": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Handicap": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Asian Handicap": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Correct Score": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Correct Score": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Result": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Double Chance": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1 to Score": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2 to Score": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Result and Total": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Result and Both Teams to Score:": "Por Parte (1ª Parte / 2ª Parte)", "1st half: 1st Goal": "Por Parte (1ª Parte / 2ª Parte)", "1st half: 2nd Goal": "Por Parte (1ª Parte / 2ª Parte)", "1st half: 3rd Goal": "Por Parte (1ª Parte / 2ª Parte)", "1st half: European Handicap (0:1)": "Por Parte (1ª Parte / 2ª Parte)", "1st half: European Handicap (1:0)": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 0 - 1": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 1 - 2": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 1 - 3": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 2 - 3": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 2 - 4": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 2 - 5": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 2 - 6": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 3 - 4": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals 3 - 5": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1: Total Goals 0 - 1": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1: Total Goals 1 - 2": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1: Total Goals 1 - 3": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1: Total Goals 1 - 4": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1: Total Goals 2 - 3": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1: Total Goals 2 - 4": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2: Total Goals 0 - 1": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2: Total Goals 1 - 2": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2: Total Goals 1 - 3": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2: Total Goals 1 - 4": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2: Total Goals 2 - 3": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2: Total Goals 2 - 4": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals Team 1": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals Team 2": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Total Goals": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 1 to Win to Nil": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Team 2 to Win to Nil": "Por Parte (1ª Parte / 2ª Parte)", "1st half: Last Goal": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Result": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Double Chance": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1 to Score": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2 to Score": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: 1st Goal": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: 2nd Goal": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: 3rd Goal": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: European Handicap (0:1)": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: European Handicap (1:0)": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 0 - 1": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 1 - 2": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 1 - 3": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 2 - 3": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 2 - 4": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 2 - 5": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 2 - 6": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 3 - 4": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals 3 - 5": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1: Total Goals 0 - 1": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1: Total Goals 1 - 2": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1: Total Goals 1 - 3": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1: Total Goals 1 - 4": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1: Total Goals 2 - 3": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1: Total Goals 2 - 4": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2: Total Goals 0 - 1": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2: Total Goals 1 - 2": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2: Total Goals 1 - 3": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2: Total Goals 1 - 4": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2: Total Goals 2 - 3": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2: Total Goals 2 - 4": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals Team 1": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals Team 2": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Total Goals": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 1 to Win to Nil": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Team 2 to Win to Nil": "Por Parte (1ª Parte / 2ª Parte)", "2nd half: Last Goal": "Por Parte (1ª Parte / 2ª Parte)", "1st half or match": "Por Parte (1ª Parte / 2ª Parte)",
         // 10. Mercados Especiais / Eventos
         "Tie Breaker": "Mercados Especiais / Eventos", "Penalty": "Mercados Especiais / Eventos", "Sending Off": "Mercados Especiais / Eventos", "Sending Off Team 1": "Mercados Especiais / Eventos", "Sending Off Team 2": "Mercados Especiais / Eventos", "1st to Happen:": "Mercados Especiais / Eventos", "How is Scored 1st Goal": "Mercados Especiais / Eventos", "Team 1 Winning Margin 1 Goal": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 1 or 2 Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 or 3 Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 or more Goals": "Mercados Especiais / Eventos", "Team 1 Winning Margin 1 Goal or Draw": "Mercados Especiais / Eventos", "Team 1 Winning Margin 2 Goals or Draw": "Mercados Especiais / Eventos", "Team 2 Winning Margin 1 Goal": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 1 or 2 Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 or 3 Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 or more Goals": "Mercados Especiais / Eventos", "Team 2 Winning Margin 1 Goal or Draw": "Mercados Especiais / Eventos", "Team 2 Winning Margin 2 Goals or Draw": "Mercados Especiais / Eventos", "Draw in at least one of the Halves": "Mercados Especiais / Eventos", "Any Team Winning Margin 1": "Mercados Especiais / Eventos", "Any Team Winning Margin 2": "Mercados Especiais / Eventos", "Any Team Winning Margin 3": "Mercados Especiais / Eventos", "Any Team Winning Margin 2 & more": "Mercados Especiais / Eventos", "Any Team Winning Margin 3 & more": "Mercados Especiais / Eventos", "Team 1 win from Behind": "Mercados Especiais / Eventos", "Team 2 Win from Behind": "Mercados Especiais / Eventos", "Own Goal": "Mercados Especiais / Eventos", "Double": "Mercados Especiais / Eventos", "1:1 During The Match": "Mercados Especiais / Eventos", "2:0 or 0:2 During The Match": "Mercados Especiais / Eventos", "2:0 During The Match": "Mercados Especiais / Eventos", "0:2 During The Match": "Mercados Especiais / Eventos", "To Miss A Penalty": "Mercados Especiais / Eventos", "To Score A Penalty": "Mercados Especiais / Eventos", "Red card in both teams": "Mercados Especiais / Eventos",
         "Specials: Total Headed Goals": "Mercados Especiais / Eventos", "Specials: To Occur First - Corner or Goal:": "Mercados Especiais / Eventos", "Specials: To Occur First - Throw in or Foul:": "Mercados Especiais / Eventos", "Specials: The medical team will appear on the field": "Mercados Especiais / Eventos", "Specials: Goal from outside the penalty area:": "Mercados Especiais / Eventos", "Specials: The goalkeeper will get a red card:": "Mercados Especiais / Eventos",
         // 11. Cantos
         "Corners: Total": "Cantos", "Corners: Total Team 1": "Cantos", "Corners: Total Team 2": "Cantos", "Corners: Total Even/Odd": "Cantos", "Corners: 1st Half: Total:": "Cantos", "Corners: 1st Half: Total Team 1": "Cantos", "Corners: 1st Half: Total Team 2": "Cantos", "Corners: 2nd Half: Total": "Cantos", "Corners: 2nd Half: Total Team 1": "Cantos", "Corners: 2nd Half: Total Team 2": "Cantos", "Corners: Total (3 way)": "Cantos", "Corners: Handicap": "Cantos", "Corners: 1st Half: Handicap": "Cantos", "Corners: 2nd Half: Handicap": "Cantos", "Corners: Result": "Cantos", "Corners: 1st Half: Result": "Cantos", "Corners: 2nd Half: Result": "Cantos", "Corners: Highest Scoring Half": "Cantos", "Corners: 1st Corner": "Cantos", "Corners: Last Corner:": "Cantos", "Corners: 10 Minutes Corners (00:00-9:59)": "Cantos", "Corners: Race to Corners": "Cantos",
         // 12. Cartões Amarelos
         "Yellow Cards: Total": "Cartões Amarelos", "Yellow Cards: Total Team 1": "Cartões Amarelos", "Yellow Cards: Total Team 2": "Cartões Amarelos", "Yellow Cards: Total Odd/Even": "Cartões Amarelos", "Yellow Cards: 1st Half: Total:": "Cartões Amarelos", "Yellow Cards: 1st Half: Total Team 1": "Cartões Amarelos", "Yellow Cards: 1st Half: Total Team 2": "Cartões Amarelos", "Yellow Cards: 2nd Half: Total": "Cartões Amarelos", "Yellow Cards: Handicap": "Cartões Amarelos", "Yellow Cards: 1st Half: Handicap": "Cartões Amarelos", "Yellow Cards: 2nd Half: Handicap": "Cartões Amarelos", "Yellow Cards: Result": "Cartões Amarelos", "Yellow Cards: Double Chance": "Cartões Amarelos", "Yellow Cards: 1st Half: Result": "Cartões Amarelos", "Yellow Cards: 1st Half: Double Chance": "Cartões Amarelos", "Yellow Cards: 2nd Half: Result": "Cartões Amarelos", "Yellow Cards: 2nd Half: Double Chance": "Cartões Amarelos", "Yellow Cards: Highest Scoring Half": "Cartões Amarelos", "Yellow Cards: 1st Yellow Card Minute": "Cartões Amarelos", "Yellow Cards: Both Teams to Receive Cards": "Cartões Amarelos", "Yellow Cards: Both Teams to Receive 2 or More Cards": "Cartões Amarelos",
         // 13. Remates à Baliza
         "Shots on target: Total": "Remates à Baliza", "Shots on target: Total Team 1": "Remates à Baliza", "Shots on target: Total Team 2": "Remates à Baliza", "Shots on target: Total Even/Odd": "Remates à Baliza", "Shots on target: 1st Half: Total:": "Remates à Baliza", "Shots on target: 1st Half: Total Team 1": "Remates à Baliza", "Shots on target: 1st Half: Total Team 2": "Remates à Baliza", "Shots on target: Handicap": "Remates à Baliza", "Shots on target: 1st Half: Handicap": "Remates à Baliza", "Shots on target: Result": "Remates à Baliza", "Shots on target: Double Chance": "Remates à Baliza", "Shots on target: 1st Half: Result": "Remates à Baliza", "Shots on target: 1st Half: Double Chance": "Remates à Baliza", "Shots on target: Highest Scoring Half": "Remates à Baliza",
         // 14. Faltas
         "Fouls: Total": "Faltas", "Fouls: Total Team 1": "Faltas", "Fouls: Total Team 2": "Faltas", "Fouls: Total Even/Odd": "Faltas", "Fouls: Handicap": "Faltas", "Fouls: Result": "Faltas", "Fouls: Double Chance": "Faltas", "Fouls: Highest Scoring Half": "Faltas",
         "Offsides: Total": "Faltas", "Offsides: Total Team 1": "Faltas", "Offsides: Total Team 2": "Faltas", "Offsides: Total Even/Odd": "Faltas", "Offsides: Handicap": "Faltas", "Offsides: Result": "Faltas", "Offsides: Double Chance": "Faltas", // Note: Offsides mapped to Faltas here
         // 15. Remates Totais
         "Shots: Total": "Remates Totais", "Shots: Total Team 1": "Remates Totais", "Shots: Total Team 2": "Remates Totais", "Shots: Total Even/Odd": "Remates Totais", "Shots: 1st Half: Total Team 1": "Remates Totais", "Shots: 1st Half: Total Team 2": "Remates Totais", "Shots: Handicap": "Remates Totais", "Shots: 1st Half: Handicap": "Remates Totais", "Shots: Result": "Remates Totais", "Shots: Double Chance": "Remates Totais", "Shots: 1st Half: Result": "Remates Totais", "Shots: 1st Half: Double Chance": "Remates Totais", "Shots: Highest Scoring Half": "Remates Totais",
         // 16. Jogadores (Totais)
         "Players:": "Jogadores (Totais)", // Matches dropdown value
         // *** Pattern Mapping ***
         "Pattern: Team Scores Only One Half": "Específicos por Equipa"
         // IMPORTANT: Add mappings for categories 17-28 here if needed
    };

    const ignorePhrases = new Set([ /* Copied from File 1 (ensure your full list is here) */
        "Live Info", "Live TV", "Bet Slip", "Odds:", "TOTAL WIN", "Log in", "Handicap:Handicap 1 (-1)", "1 000", "LIVE TV IS UNAVAILABLE!",
        "Stake", "Multi System", "Single", "Place bet", "Place", "Log in to watch live matches by using your username and password."
        // Add any other phrases specific to your ignored items list
    ]);

    // --- CONSTANTES E REGEX ---
    const teamScoresOneHalfRegex = /^(.+)\s+to score in only one of halves$/i;
    const playersPrefix = "Players:";
    const playersCategory = "Jogadores (Totais)"; // Match the text used in the dropdown value for filter category 16

    // ========================================================================
    // === HELPER FUNCTIONS ===
    // ========================================================================

    function isOddNumber(str) {
         if (!str) return false;
         return /^\s*\d+(\.\d+)?\s*$/.test(str);
     }

     function classifySpecialBlock(header, pairs) {
         const numPairs = pairs.length;
          if (header.includes("Corners: Total") || header.includes("Yellow Cards: Total")) {
              return numPairs === 2 ? 'principal' : 'alternative';
         } else if (header.includes("Handicap") || header.includes("Total")) {
              return numPairs === 2 ? 'principal' : 'alternative';
         }
         return 'principal';
     }

      // *** MODIFIED: Accepts originalHeaderText and SETS BOTH data attributes ***
      function createCategoryTable(headerText, originalHeaderText) {
         const table = document.createElement('table');
         table.style.display = 'none'; // Initially hidden
         table.setAttribute('data-original-category', originalHeaderText);
         let mainFilterCategory = 'Categoria Desconhecida';
         if (originalHeaderText.startsWith(playersPrefix)) {
             mainFilterCategory = playersCategory;
         } else if (originalHeaderText === "Pattern: Team Scores Only One Half") {
             mainFilterCategory = categoryMap[originalHeaderText];
         } else {
             mainFilterCategory = categoryMap[originalHeaderText] || 'Categoria Desconhecida';
         }
         table.setAttribute('data-category', mainFilterCategory);
         const thead = document.createElement('thead');
         const headerRow = document.createElement('tr');
         const headerCell = document.createElement('th');
         headerCell.colSpan = 3;
         headerCell.textContent = headerText;
         headerRow.appendChild(headerCell);
         const subHeaderRow = document.createElement('tr');
         const optionTh = document.createElement('th'); optionTh.textContent = 'Opção'; optionTh.style.textAlign = 'left';
         const oddTh = document.createElement('th'); oddTh.textContent = 'Odd'; oddTh.style.textAlign = 'right';
         const scoreTh = document.createElement('th'); scoreTh.textContent = 'Score'; scoreTh.style.textAlign = 'right';
         subHeaderRow.appendChild(optionTh); subHeaderRow.appendChild(oddTh); subHeaderRow.appendChild(scoreTh);
         thead.appendChild(headerRow); thead.appendChild(subHeaderRow);
         table.appendChild(thead);
         const tbody = document.createElement('tbody'); table.appendChild(tbody);
         return table;
     }

     // ========================================================================
     // === addTableRow FUNCTION (MODIFIED with Linear Formula) ===
     // ========================================================================
     function addTableRow(table, optionText, oddValue) {
         const tbody = table.querySelector('tbody');
         if (!tbody) return;
         const row = document.createElement('tr');
         const textCell = document.createElement('td');
         textCell.textContent = optionText.trim();
         const numberCell = document.createElement('td');
         numberCell.textContent = oddValue.trim();
         numberCell.style.textAlign = 'right';
         const calculationCell = document.createElement('td');
         calculationCell.style.textAlign = 'right';

         const odd = parseFloat(oddValue.trim());
         let score; // Variável para guardar o score calculado

           // Verifica se a odd é um número válido e maior que zero
           if (!isNaN(odd) && odd > 0) {

// --- INÍCIO DA NOVA LÓGICA DE SCORE BASEADA EM FAIXAS DE ODDS ---
if (odd < 1.11) {
    score = 0;
} else if (odd <= 1.25) { // 1.11 a 1.25
    score = 1;
} else if (odd <= 1.39) { // 1.26 a 1.39
    score = 2;
} else if (odd <= 1.64) { // 1.40 a 1.64
    score = 3;
} else if (odd <= 1.92) { // 1.65 a 1.92
    score = 4;
} else if (odd <= 2.29) { // 1.93 a 2.29
    score = 5;
} else if (odd <= 2.95) { // 2.30 a 2.95
    score = 6;
} else if (odd <= 3.98) { // 2.96 a 3.98
    score = 7;
} else if (odd <= 6.69) { // 3.99 a 6.69
    score = 8;
} else if (odd <= 9.00) { // 6.70 a 9.00
    score = 9;
} else { // Acima de 9.00
    score = 10;
}
// --- FIM DA NOVA LÓGICA DE SCORE ---
const boldText = document.createElement('b');
             boldText.textContent = score; // Exibe o score final calculado
             calculationCell.appendChild(boldText);

         } else {
             // Se a odd não for um número válido ou for <= 0, exibe "-"
             calculationCell.textContent = "-";
         }

         row.appendChild(textCell);
         row.appendChild(numberCell);
         row.appendChild(calculationCell);
         tbody.appendChild(row);
     }
     // ========================================================================
     // === END of MODIFIED addTableRow ===
     // ========================================================================


    // --- FILTERING FUNCTIONS ---
    function applyTitleSearchToVisibleTables() {
        const searchInput = document.getElementById("searchSubcategoryInput"); if (!searchInput) return;
        const searchTerm = searchInput.value.toLowerCase().trim();
        // Seleciona apenas tabelas que NÃO estão com display: none explicitamente setado pelo filtro de categoria
        const visibleTables = document.querySelectorAll("#settings-popup #outputTables table:not([style*='display: none'])");
        visibleTables.forEach(table => {
            const headerCell = table.querySelector('thead th[colspan="3"]');
            let matchesSearch = true; // Assume que corresponde por padrão
            if (headerCell && searchTerm !== '') { // Só filtra se houver termo de pesquisa
                const headerText = headerCell.textContent.toLowerCase();
                matchesSearch = headerText.includes(searchTerm);
            }
            // Esconde se não corresponder à pesquisa E já estiver visível pelo filtro de categoria
            if (!matchesSearch) {
                table.style.display = 'none';
            }
            // Importante: Não mostramos a tabela aqui, pois o filtro de categoria tem precedência.
            // Se ela foi escondida pelo filtro de categoria, deve permanecer escondida.
        });
    }


     window.filterTables = function() {
         var selectedCategoryValue = document.getElementById("categoryFilter").value;
         var tables = document.querySelectorAll("#settings-popup #outputTables table");
         tables.forEach(function(table) {
             const tableFilterCategory = table.getAttribute('data-category');
             // Mostra a tabela se corresponder à categoria selecionada OU se "Todas" estiver selecionado
             if (selectedCategoryValue === 'all' || tableFilterCategory === selectedCategoryValue) {
                 table.style.display = ''; // Remove o display: none se houver
             }
             else {
                 table.style.display = 'none'; // Esconde se não corresponder
             }
         });
         // Aplica o filtro de título APÓS o filtro de categoria
         applyTitleSearchToVisibleTables();
     }

    // ========================================================================
    // === CORE CONVERTER FUNCTION (Uses the modified addTableRow) ===
    // ========================================================================
    window.convertToTable = function() {
        const convertButton = document.getElementById('create-table-button'); if (convertButton) convertButton.disabled = true;
        var inputText = document.getElementById("inputTextArea").value; var lines = inputText.split('\n');
        var outputDiv = document.getElementById("outputTables"); outputDiv.innerHTML = '';
        const searchInput = document.getElementById("searchSubcategoryInput"); if (searchInput) searchInput.value = ''; // Limpa a pesquisa
        let allParsedBlocks = []; let currentBlockData = null;

        // --- Pass 1: Parse ALL blocks ---
        for (const line of lines) {
            let trimmedLine = line.trim();
            if (ignorePhrases.has(trimmedLine) || ["Ù", "Ã", "Á", ""].includes(trimmedLine) || trimmedLine.length === 0) continue;
            let isHeader = false; let potentialHeader = null; let canonicalHeader = null; let mainCategory = null; let isSpecial = false; let isPatternMatch = false;
            const patternMatch = trimmedLine.match(teamScoresOneHalfRegex);
            if (patternMatch) { isHeader = true; potentialHeader = trimmedLine; canonicalHeader = "Pattern: Team Scores Only One Half"; isSpecial = false; isPatternMatch = true; }
            else if (trimmedLine.startsWith(playersPrefix)) { isHeader = true; potentialHeader = trimmedLine; canonicalHeader = potentialHeader; mainCategory = playersCategory; isSpecial = false; }
            else if (specialCategories.has(trimmedLine)) { isHeader = true; potentialHeader = trimmedLine; canonicalHeader = potentialHeader; isSpecial = true; }
            else if (categories.includes(trimmedLine)) { isHeader = true; potentialHeader = trimmedLine; canonicalHeader = potentialHeader; isSpecial = false; }

            if (isHeader) {
                if (currentBlockData && currentBlockData.pairs.length > 0) {
                     if (currentBlockData.isSpecial && !currentBlockData.isPatternMatch) currentBlockData.classification = classifySpecialBlock(currentBlockData.header, currentBlockData.pairs);
                     currentBlockData.mainCategory = categoryMap[currentBlockData.canonicalHeader] || "Categoria Desconhecida"; // Use canonical header for map lookup
                     if(currentBlockData.header.startsWith(playersPrefix)) currentBlockData.mainCategory = playersCategory; // Ensure player category override
                     if(currentBlockData.isPatternMatch) currentBlockData.mainCategory = categoryMap[currentBlockData.canonicalHeader]; // Ensure pattern category override
                     allParsedBlocks.push(currentBlockData);
                }
                currentBlockData = { header: potentialHeader, canonicalHeader: canonicalHeader, pairs: [], mainCategory: mainCategory, isSpecial: isSpecial, isPatternMatch: isPatternMatch, classification: 'standard', pendingOption: null };
            } else if (currentBlockData) {
                if (currentBlockData.pendingOption === null) { // Expecting an option
                    // Basic check to prevent assigning an odd as an option if accidentally pasted out of order
                    if (!isOddNumber(trimmedLine)) {
                       currentBlockData.pendingOption = trimmedLine;
                    } else {
                        // If an odd is found where an option was expected, discard the block or handle as error?
                        // For now, just ignore the odd number and wait for a proper option text.
                        // console.warn("Expected option text, found odd number:", trimmedLine, "Skipping line.");
                    }
                }
                else { // Expecting an odd
                    if (isOddNumber(trimmedLine)) {
                        currentBlockData.pairs.push([currentBlockData.pendingOption, trimmedLine]);
                        currentBlockData.pendingOption = null; // Reset for the next pair
                    }
                    else {
                        // Found another text line where an odd was expected.
                        // Assume the previous pendingOption was actually part of a multi-line option text.
                        // Append the new line to the previous option.
                        currentBlockData.pendingOption += " " + trimmedLine;
                        // Keep waiting for an odd number.
                    }
                }
            }
        }
        // Process the very last block if it exists and has pairs
        if (currentBlockData && currentBlockData.pairs.length > 0) {
             if (currentBlockData.isSpecial && !currentBlockData.isPatternMatch) currentBlockData.classification = classifySpecialBlock(currentBlockData.header, currentBlockData.pairs);
             currentBlockData.mainCategory = categoryMap[currentBlockData.canonicalHeader] || "Categoria Desconhecida"; // Use canonical header for map lookup
             if(currentBlockData.header.startsWith(playersPrefix)) currentBlockData.mainCategory = playersCategory; // Ensure player category override
             if(currentBlockData.isPatternMatch) currentBlockData.mainCategory = categoryMap[currentBlockData.canonicalHeader]; // Ensure pattern category override
             allParsedBlocks.push(currentBlockData);
        }

        // --- Pass 2: Filter and Render ---
        let renderedNormal = new Set(); let renderedSpecialPrincipal = new Set(); let renderedSpecialAlternative = new Set(); let renderedTeamScoreOneHalfHeaders = new Set();
        for (const block of allParsedBlocks) {
            const { header, canonicalHeader, pairs, mainCategory, isSpecial, isPatternMatch, classification } = block;
             if (!mainCategory || mainCategory === 'Categoria Desconhecida') {
                 // console.warn("Skipping block with unknown/missing main category:", header);
                 continue;
             };
            let displayHeader = header;
             if (header.startsWith(playersPrefix)) { displayHeader = header.substring(playersPrefix.length).trim(); if (!displayHeader) displayHeader = "Jogador - Geral"; }
            let table = null;
            const uniqueBlockIdentifier = canonicalHeader; // Use canonical for tracking rendered blocks

            if (isPatternMatch) {
                if (!renderedTeamScoreOneHalfHeaders.has(uniqueBlockIdentifier)) {
                    renderedTeamScoreOneHalfHeaders.add(uniqueBlockIdentifier);
                    table = createCategoryTable(displayHeader, header); // Pass original header for data attribute
                    pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                    outputDiv.appendChild(table);
                 }
             }
            else if (!isSpecial) { // Standard, non-special blocks
                 if (!renderedNormal.has(uniqueBlockIdentifier)) {
                     renderedNormal.add(uniqueBlockIdentifier);
                     table = createCategoryTable(displayHeader, header); // Pass original header for data attribute
                     pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                     outputDiv.appendChild(table);
                 }
            }
            else { // Special blocks (Total, Handicap, etc.)
                if (classification === 'principal') {
                    if (!renderedSpecialPrincipal.has(uniqueBlockIdentifier)) {
                        renderedSpecialPrincipal.add(uniqueBlockIdentifier);
                        table = createCategoryTable(displayHeader, header); // Pass original header
                        pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                        outputDiv.appendChild(table);
                    }
                } else if (classification === 'alternative') {
                     // Only render alternatives if the principal hasn't been rendered yet for that canonical header
                     if (!renderedSpecialPrincipal.has(uniqueBlockIdentifier) && !renderedSpecialAlternative.has(uniqueBlockIdentifier)) {
                         renderedSpecialAlternative.add(uniqueBlockIdentifier);
                         // Maybe add "(Alt.)" or similar to display header?
                         table = createCategoryTable(displayHeader + " (Alternativo)", header); // Pass original header
                         pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                         outputDiv.appendChild(table);
                     }
                }
                // Note: 'standard' classification for special blocks shouldn't happen with current logic, but treat as principal if it did.
                 else if (!renderedSpecialPrincipal.has(uniqueBlockIdentifier)) {
                     renderedSpecialPrincipal.add(uniqueBlockIdentifier);
                     table = createCategoryTable(displayHeader, header); // Pass original header
                     pairs.forEach(pair => addTableRow(table, pair[0], pair[1]));
                     outputDiv.appendChild(table);
                 }
            }
        }
        window.filterTables(); // Apply initial filter (which now includes the title search)
        const searchInputForTitles = document.getElementById("searchSubcategoryInput");
        if (searchInputForTitles) {
            // Ensure the event listener is correctly attached for filtering by title
             searchInputForTitles.removeEventListener('input', window.filterTables); // Remove previous if any
             searchInputForTitles.addEventListener('input', window.filterTables); // Add the listener
        }
        if (convertButton) convertButton.disabled = false; // Re-enable button
    } // End of convertToTable function

})(); // End of converter's IIFE
</script>
    <!-- == CONVERTER JAVASCRIPT END == -->

</body>
</html>
