<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mercado - Ggames</title>
        <link rel="icon" type="image/png" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTl6Ljabwgx-VXdZz8FcAoygQprujSsCoXc32Y_iU0FjYVPu1B6MffWwp8gcCVuV8TWn39FRk9OIe1nc-esubVJYmdLsTptAoR9GyqNuw4R5MBaeaoWXTc3JaqH2YVNtEmfReQqohvQKvHiI0XwE5na2ty2B9Bt4oELxYv2BaZ7R3UmeylpiVEiIbiLnCB/s320/soccer-ball-png.webp">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }

        .bottom-menu {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: #ffffff;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
    padding: 12px 0;
    display: flex;
    justify-content: center;
    gap: 32px;
    align-items: center;
    z-index: 1000;
}

.menu-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-decoration: none;
    color: #666;
    transition: color 0.3s ease;
}

.menu-item:hover, .menu-item.active {
    color: #333;
}

.menu-item i {
    font-size: 24px;
    margin-bottom: 4px;
}

.empire-icon {
    font-size: 42px;
    color: #2176ff;
    transform: translateY(-3px);
    filter: drop-shadow(0 0 8px rgba(33, 118, 255, 0.4));
    transition: all 0.3s ease;
}

.empire-icon:hover {
    color: #0056d6;
    transform: translateY(-8px);
    filter: drop-shadow(0 0 12px rgba(33, 118, 255, 0.6));
}

        .content {
            padding: 20px;
            margin-bottom: 160px;
            display: none; /* Hide content initially */
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .market-section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 24px;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #2176ff;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-title::after {
            content: '▼';
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .section-title.collapsed::after {
            transform: rotate(-90deg);
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 12px;
            padding: 6px;
            max-height: 1000px; /* Adjust as needed */
            overflow: hidden;
            transition: max-height 0.5s ease-out, padding 0.5s ease-out, margin 0.5s ease-out;
        }


        .players-grid.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: -10px;
            overflow: hidden;
        }


        .player-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 180px;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 2px solid transparent; /* Prevent layout shift */
        }

        /* Style for card loading effect */
        .player-card.card-loading {
            transform: scale(1.03);
            box-shadow: 0 6px 18px rgba(33, 118, 255, 0.35);
            border-color: #2176ff;
            z-index: 10;
        }


        .country-flag {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            z-index: 2;
        }

        .player-card:hover {
            /* Slightly different effect on hover, less intense than loading */
            transform: translateY(-3px) scale(1.01);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        /* Ensure loading effect overrides hover transform */
        .player-card.card-loading:hover {
            transform: scale(1.03); /* Maintain loading scale */
        }


        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            z-index: 0;
        }

        .player-image {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 50%;
            margin-bottom: 8px;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1;
        }

        .player-name {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 4px;
            color: #2c3e50;
            margin-top: 8px;
        }

        .player-club {
            font-size: 11px;
            color: #7f8c8d;
            margin-bottom: 8px;
            font-weight: 500;
            text-align: center;
            width: 100%;
        }

        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 8px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            text-align: center;
            width: 100%;
        }

        .stat-label {
            font-size: 10px;
            color: #666;
        }

        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: #2c3e50;
        }

        .stat-value.price,
        .stat-column:last-child .stat-label {
            color: #28a745;
        }

        .buy-button {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .player-card.gold::before { background: linear-gradient(135deg, rgba(255, 215, 0, 0.8) 0%, rgba(255, 237, 74, 0.8) 100%); }
        .player-card.silver::before { background: linear-gradient(135deg, rgba(192, 192, 192, 0.8) 0%, rgba(232, 232, 232, 0.8) 100%); }
        .player-card.bronze::before { background: linear-gradient(135deg, rgba(205, 127, 50, 0.8) 0%, rgba(233, 150, 122, 0.8) 100%); }
        .player-card.platinum::before { background: linear-gradient(135deg, rgba(169, 176, 209, 0.8) 0%, rgba(157, 157, 196, 0.8) 100%); }

        .buy-button.available {
            background: linear-gradient(135deg, #2176ff 0%, #0056d6 100%);
            color: white;
        }
        .buy-button.available:hover:not(:disabled) {
            background: linear-gradient(135deg, #0056d6 0%, #003ba3 100%);
            transform: translateY(-2px);
        }

        .buy-button.purchased {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            color: white;
            cursor: not-allowed;
        }
        .buy-button:disabled { /* General disabled style */
            opacity: 0.7;
            cursor: not-allowed;
        }


        /* Loading Screen Styles */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Above content but below popup */
        }

        .loading-percentage { margin-top: 15px; font-size: 18px; font-weight: bold; color: #2176ff; }
        .progress-bar-container { width: 200px; height: 10px; background-color: #e0e0e0; border-radius: 5px; margin-top: 10px; overflow: hidden; }
        .progress-bar { height: 100%; width: 0%; background: linear-gradient(135deg, #2176ff 0%, #0056d6 100%); border-radius: 5px; transition: width 0.3s ease-in-out; }
        .loading-spinner { border: 16px solid #f3f3f3; border-top: 16px solid #3498db; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }


        /* Popup Styles */
        .popup-overlay {
            display: none; /* Initially hidden */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000; /* Highest */
            justify-content: center; align-items: center;
            opacity: 0; /* Start transparent for fade-in */
            transition: opacity 0.3s ease; /* Fade transition */
        }
        .popup-overlay.active { display: flex; opacity: 1; /* Fade in */ }

        .popup-content {
            background: white; padding: 24px; border-radius: 12px;
            width: 90%; max-width: 400px; position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            transform: translateY(-20px); /* Start slightly up */
            opacity: 0; /* Start transparent */
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .popup-overlay.active .popup-content {
            transform: translateY(0); /* Move down to final position */
            opacity: 1; /* Fade in */
        }

        .popup-button.purchased { background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%); color: white; cursor: not-allowed; }
        .popup-header { text-align: center; margin-bottom: 20px; position: relative; }
        .popup-country-flag { position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; border-radius: 50%; object-fit: cover; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); z-index: 2; }
        .popup-player-image { width: 120px; height: 120px; border-radius: 50%; margin: 0 auto 16px; display: block; border: 3px solid #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .popup-player-name { font-size: 24px; font-weight: 700; color: #2c3e50; margin-bottom: 8px; }
        .popup-player-club { font-size: 16px; color: #7f8c8d; margin-bottom: 20px; }
        .popup-stats { background: #f8f9fa; border-radius: 8px; padding: 16px; margin-bottom: 24px; position: relative; /* Needed for message positioning */ }
        .popup-stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #e9ecef; }
        .popup-stat-row:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
        .popup-stat-label { font-size: 14px; color: #6c757d; }
        .popup-stat-value { font-size: 16px; font-weight: 600; color: #2c3e50; }
        .popup-buttons { display: flex; gap: 12px; margin-top: 15px; /* Add margin if messages appear above */ }
        .popup-button { flex: 1; padding: 12px; border: none; border-radius: 6px; font-weight: 600; font-size: 14px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; }
        .popup-button.buy { background: #28a745; color: white; }
        .popup-button.buy:hover:not(:disabled) { background: #218838; }
        .popup-button.exit { background: #dc3545; color: white; }
        .popup-button.exit:hover { background: #c82333; }
        .popup-button:disabled { opacity: 0.65; cursor: not-allowed; }


        /* Section Toggles */
        .toggle-all-button {
            position: relative; width: 120px; height: 36px; border-radius: 18px;
            background-color: #f0f0f0; border: 2px solid #ddd; cursor: pointer;
            transition: all 0.3s ease; margin-bottom: 20px; padding: 0;
            display: flex; justify-content: space-between; align-items: center;
            overflow: hidden; margin-left: auto; /* Align to the right */
        }
        .toggle-all-button span { padding: 0 12px; font-size: 14px; font-weight: 600; transition: color 0.3s ease; z-index: 1; pointer-events: none; }
        .toggle-all-button::before {
            content: ''; position: absolute; width: 60px; height: calc(100% - 4px);
            border-radius: 16px; background-color: #4CAF50; /* Green for 'Abre' */
            top: 2px; left: 2px;
            transition: transform 0.3s ease, background-color 0.3s ease; z-index: 0;
        }
        .toggle-all-button.active::before {
            transform: translateX(calc(100% - 4px)); /* Move right */
            background-color: #dc3545; /* Red for 'Fecha' */
        }
        .toggle-all-button span.active { color: white; }
        .toggle-all-button span:not(.active) { color: #666; }


        /* General & Utility */
         .player-info { width: 100%; text-align: center; }
         .no-players-message { text-align: center; margin-top: 30px; color: #666; font-style: italic; }

        /* Popup Messages */
        .error-message, .success-message {
            text-align: center; font-weight: bold; margin: 10px 0 -5px 0; /* Appear between stats and buttons */
            padding: 8px; border-radius: 4px; font-size: 0.9em;
        }
        .error-message { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; }
        .success-message { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb; }

    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-percentage">0%</div>
        <div class="progress-bar-container">
            <div class="progress-bar"></div>
        </div>
    </div>

    <!-- Popup Overlay -->
    <div class="popup-overlay" id="playerPopup">
        <div class="popup-content">
            <div class="popup-header">
                <img src="" alt="" class="popup-player-image" id="popupPlayerImage">
                <img src="" alt="" class="popup-country-flag" id="popupCountryFlag">
                <div class="popup-player-name" id="popupPlayerName"></div>
                <div class="popup-player-club" id="popupPlayerClub"></div>
            </div>
            <div class="popup-stats">
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Overall</div>
                    <div class="popup-stat-value" id="popupPlayerOverall"></div>
                </div>
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Preço</div>
                    <div class="popup-stat-value" id="popupPlayerPrice"></div>
                </div>
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Posição</div>
                    <div class="popup-stat-value" id="popupPlayerPosicao"></div>
                </div>
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Casta</div>
                    <div class="popup-stat-value" id="popupPlayerCasta"></div>
                </div>
                 <!-- Messages will be inserted here by JS -->
            </div>
            <div class="popup-buttons">
                <button class="popup-button buy" id="popupBuyButton">Comprar</button>
                <button class="popup-button exit" id="popupExitButton">Sair</button>
            </div>
        </div>
    </div>

  <div class="content">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h1>Mercado</h1>
        <a id="transaction-button-link" href="bank.html" class="transaction-button" style="padding: 8px 16px; background: linear-gradient(135deg, #2176ff, #0056d6); color: white; text-decoration: none; border-radius: 18px; font-weight: 600; font-size: 14px; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px; box-shadow: 0 2px 4px rgba(33, 118, 255, 0.2); transform: translateY(0);">
            <i class="fas fa-dollar-sign" style="font-size: 16px;"></i>Transações
        </a>
    </div>

    <div style="display: flex; justify-content: flex-end; margin-bottom: 20px;">
       <button id="toggleAllSections" class="toggle-all-button active">
    <span class="toggle-open">Abre</span>
    <span class="toggle-close active">Fecha</span>
</button>
    </div>

        <div class="market-section" id="guarda-redes-section">
            <h2 class="section-title collapsed">GUARDA-REDES</h2>
            <div class="players-grid collapsed" id="guarda-redes-grid"></div>
        </div>

        <div class="market-section" id="defesas-section">
            <h2 class="section-title collapsed">DEFESAS</h2>
            <div class="players-grid collapsed" id="defesas-grid"></div>
        </div>

        <div class="market-section" id="medios-section">
            <h2 class="section-title collapsed">MÉDIOS</h2>
            <div class="players-grid collapsed" id="medios-grid"></div>
        </div>

        <div class="market-section" id="avancados-section">
            <h2 class="section-title collapsed">AVANÇADOS</h2>
            <div class="players-grid collapsed" id="avancados-grid"></div>
        </div>
        <!-- Message for no players will be added here by JS -->
    </div>

    <nav class="bottom-menu">
        <a id="menu-item-1x" href="1x.html" class="menu-item"> <i class="fas fa-home"></i> </a>
        <a id="menu-item-market" href="market.html" class="menu-item active"> <i class="fas fa-shopping-cart"></i> </a>
        <a id="menu-item-team" href="team.html" class="menu-item"> <i class="fas fa-users"></i> </a>
        <a id="menu-item-empire" href="empire.html" class="menu-item"> <i class="fas fa-landmark empire-icon"></i> </a>
        <a id="menu-item-rankings" href="rankings.html" class="menu-item"> <i class="fas fa-list"></i> </a>
        <a id="menu-item-profile" href="profile.html" class="menu-item"> <i class="fas fa-user"></i> </a>
    </nav>

    <script src="config.js"></script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, collection, getDocs, doc, getDoc, updateDoc, Timestamp, addDoc, query, where, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";        import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

             const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // --- DOM Elements ---
        const loadingScreen = document.getElementById('loading-screen');
        const content = document.querySelector('.content');

        // --- Global State ---
        let currentUserEstatuto = null;

        // --- Helper Functions ---

        /**
         * Fetches the user's 'estatuto' from Firestore.
         * @param {string} userId - The Firebase Authentication user ID.
         * @returns {Promise<string|null>} The user's 'estatuto' or null if not found/accepted/error.
         */
        async function getUserEstatuto(userId) {
            if (!userId) return null;
            const userDocRef = doc(db, 'users', userId);
            try {
                const docSnap = await getDoc(userDocRef);
                if (docSnap.exists() && docSnap.data()?.aceite === "Yes") { // Optional chaining
                    return docSnap.data().estatuto;
                } else {
                    // User not found or not accepted
                    return null;
                }
            } catch (error) {
                console.error("Error fetching user status:", error);
                return null;
            }
        }

        /**
         * Fetches a username from Firestore based on user ID.
         * @param {string} userId - The user ID to look up.
         * @returns {Promise<string>} The username or the original user ID as fallback.
         */
     async function getUsername(userId) {
    if (!userId) return userId; // Return ID if null/empty
    const userDoc = doc(db, 'users', userId);
    try {
        const docSnap = await getDoc(userDoc);
        if (docSnap.exists()) {
            // MODIFICAÇÃO: Alterado de 'nomeDeUsuario' para 'nometabela'
            return docSnap.data()?.nometabela || userId; 
        } else {
            // console.warn(`Username not found for userId: ${userId}`); // Optional warning
            return userId;
        }
    } catch (error) {
        console.error(`Error fetching username for userId ${userId}:`, error);
        return userId;
    }
}

        /**
         * Removes any existing success or error messages from the popup.
         */
        function clearPopupMessages() {
            const popupContent = document.querySelector('.popup-content');
            if (!popupContent) return;
            const existingError = popupContent.querySelector('.error-message');
            const existingSuccess = popupContent.querySelector('.success-message');
            if (existingError) existingError.remove();
            if (existingSuccess) existingSuccess.remove();
        }

        /**
         * Displays an error message within the popup content area.
         * @param {HTMLElement} popupContent - The popup's content element.
         * @param {string} message - The error message to display.
         */
        function displayErrorMessage(popupContent, message) {
            if (!popupContent) return;
            clearPopupMessages();
            const errorElement = document.createElement('div');
            errorElement.className = 'error-message';
            errorElement.textContent = message;
            const statsSection = popupContent.querySelector('.popup-stats');
            if (statsSection) {
                statsSection.insertAdjacentElement('afterend', errorElement);
            } else {
                popupContent.appendChild(errorElement);
            }
        }

        /**
         * Displays a success message within the popup content area.
         * @param {HTMLElement} popupContent - The popup's content element.
         * @param {string} message - The success message to display.
         */
        function displaySuccessMessage(popupContent, message) {
            if (!popupContent) return;
            clearPopupMessages();
            const successElement = document.createElement('div');
            successElement.className = 'success-message';
            successElement.textContent = message;
            const statsSection = popupContent.querySelector('.popup-stats');
            if (statsSection) {
                statsSection.insertAdjacentElement('afterend', successElement);
            } else {
                popupContent.appendChild(successElement);
            }
        }

        /**
         * Determines the CSS class based on player tier ('casta').
         * @param {string} casta - The player's tier string.
         * @returns {string} The corresponding CSS class name ('gold', 'silver', etc.).
         */
        function getTierClass(casta) {
            switch (casta) {
                case 'Jogador Ouro': return 'gold';
                case 'Jogador Prata': return 'silver';
                case 'Jogador Bronze': return 'bronze';
                case 'Jogador Platina': return 'platinum';
                default: return '';
            }
        }

        /**
         * Finds the most recent 'YYYYMMDDGCoins' field in user data.
         * @param {object} userData - The user's data object from Firestore.
         * @returns {string|null} The key of the latest GCoins field or null.
         */
        function findLatestGcoinsField(userData) {
            let latestSeason = 0;
            let latestGcoinsField = null;
            if (!userData) return null;

            for (const key in userData) {
                if (key.match(/^\d{8}GCoins$/)) {
                    const season = parseInt(key.slice(0, 8), 10);
                    if (!isNaN(season) && season >= latestSeason) {
                        latestSeason = season;
                        latestGcoinsField = key;
                    }
                }
            }
            if (!latestGcoinsField) {
                console.warn("Could not determine the latest GCoins field for user.");
            }
            return latestGcoinsField;
        }

        // --- Core Logic Functions ---

        /**
         * Creates a player card element with data and event listeners.
         * @param {object} player - The player data object from Firestore.
         * @returns {Promise<HTMLElement>} The created card element.
         */
        async function createPlayerCard(player) {
            const card = document.createElement('div');
            card.className = `player-card ${getTierClass(player.casta)}`;
            card.dataset.playerId = player.id;

            let paisImagem = '';
            if (player.paisId) {
                try {
                    const paisDoc = await getDoc(doc(db, 'paises', player.paisId));
                    paisImagem = paisDoc.exists() ? paisDoc.data()?.imagem || '' : '';
                } catch (error) {
                    console.warn(`Could not fetch country data for ID: ${player.paisId}`, error);
                }
            }

            let initialButtonText = 'Comprar';
            let initialButtonClass = 'available';
            let initialButtonDisabled = false;
            if (player.compradopor) {
                initialButtonClass = 'purchased';
                initialButtonDisabled = true;
                initialButtonText = `Comprado por ${player.compradopor}`; // Temp ID
                getUsername(player.compradopor).then(username => {
                    const buttonElement = card.querySelector('.buy-button');
                    if (buttonElement) buttonElement.textContent = `Comprado por ${username || player.compradopor}`;
                }).catch(err => console.error("Error fetching initial card username:", err));
            }

            card.innerHTML = `
                ${paisImagem ? `<img src="${paisImagem}" alt="Country flag" class="country-flag">` : ''}
                <img src="${player.imagem || ''}" alt="${player.nome || 'Player'}" class="player-image">
                <div class="player-info">
                    <div class="player-name">${player.nome || '-'}</div>
                    <div class="player-club">${player.clube || '-'}</div>
                    <div class="player-stats">
                        <div class="stat-column">
                            <div class="stat-label">Overall:</div>
                            <div class="stat-value">${player.overall || '-'}</div>
                        </div>
                        <div class="stat-column">
                            <div class="stat-value price">${player.preco || 0}</div>
                            <div class="stat-label">gCoins</div>
                        </div>
                    </div>
                    <button class="buy-button ${initialButtonClass}" ${initialButtonDisabled ? 'disabled' : ''}>
                        ${initialButtonText}
                    </button>
                </div>
            `;
            const buyButtonCard = card.querySelector('.buy-button');

            const playerDocRef = doc(db, 'jogadores', player.id);
            const unsubscribeCard = onSnapshot(playerDocRef, async (docSnapshot) => {
                if (!buyButtonCard) return;

                if (docSnapshot.exists()) {
                    const updatedPlayer = docSnapshot.data();
                    const compradorUserId = updatedPlayer?.compradopor; // Optional chaining
                    if (compradorUserId) {
                        const compradorUsernameCard = await getUsername(compradorUserId);
                        buyButtonCard.textContent = `Comprado por ${compradorUsernameCard || compradorUserId}`;
                        buyButtonCard.classList.add('purchased');
                        buyButtonCard.classList.remove('available');
                        buyButtonCard.disabled = true;
                    } else {
                        buyButtonCard.textContent = 'Comprar';
                        buyButtonCard.classList.remove('purchased');
                        buyButtonCard.classList.add('available');
                        buyButtonCard.disabled = false;
                    }
                } else {
                    console.warn(`Player card listener: Document ${player.id} does not exist. Removing card.`);
                    if (unsubscribeCard && typeof unsubscribeCard === 'function') {
                        try { unsubscribeCard(); } catch (e) { /* ignore */ }
                    }
                    card.remove();
                }
            }, (error) => {
                console.error(`Error in player card listener for ${player.id}:`, error);
                if (buyButtonCard) { buyButtonCard.textContent = 'Erro'; buyButtonCard.disabled = true; }
            });

            // Store listener cleanup function using WeakRef might be better, but dataset is simpler for now
            card.dataset.unsubscribeCardListener = unsubscribeCard;

            // --- Card Click Listener (Handles Popup Opening) ---
            card.addEventListener('click', async (event) => {
                const clickedButton = event.target.closest('.buy-button');
                if (clickedButton?.classList.contains('purchased')) {
                    // Clicked "Comprado por..." button on card, do nothing.
                    return;
                }
                // Proceed to open popup if click was not on 'purchased' button.

                card.classList.add('card-loading'); // Start effect

                const popup = document.getElementById('playerPopup');
                if (!popup) { console.error("Popup element not found!"); card.classList.remove('card-loading'); return; }

                // Cleanup previous listener safely
                const existingUnsubscribeRef = popup.dataset.unsubscribePopupListener;
                if (existingUnsubscribeRef) {
                     // Assuming the listener function itself is stored (less safe than storing ID)
                     // If this causes issues, switch to storing/retrieving the unsubscribe function itself
                     const existingUnsubscribe = window[existingUnsubscribeRef]; // Example if stored globally (not recommended)
                     if (existingUnsubscribe && typeof existingUnsubscribe === 'function') {
                        try { existingUnsubscribe(); } catch (e) { console.error("Error detaching previous popup listener:", e); }
                     }
                }
                delete popup.dataset.unsubscribePopupListener; // Remove old reference regardless
                clearPopupMessages();

                // --- Select Popup Elements (with checks) ---
                const popupImage = document.getElementById('popupPlayerImage');
                const popupName = document.getElementById('popupPlayerName');
                const popupClub = document.getElementById('popupPlayerClub');
                const popupOverall = document.getElementById('popupPlayerOverall');
                const popupPrice = document.getElementById('popupPlayerPrice');
                const popupCasta = document.getElementById('popupPlayerCasta');
                const popupBuyButton = document.getElementById('popupBuyButton');
                const popupCountryFlag = document.getElementById('popupCountryFlag');
                const popupPlayerPosicaoElement = document.getElementById('popupPlayerPosicao');
                const playerPopupContent = document.querySelector('.popup-content');

                if (!popupImage || !popupName || !popupClub || !popupOverall || !popupPrice || !popupCasta || !popupBuyButton || !popupCountryFlag || !popupPlayerPosicaoElement || !playerPopupContent) {
                    console.error("One or more essential popup elements were not found!");
                    card.classList.remove('card-loading');
                    alert("Erro ao carregar o popup do jogador.");
                    return;
                }

                try {
                    const playerDocRefPopup = doc(db, 'jogadores', player.id);
                    const freshPlayerSnap = await getDoc(playerDocRefPopup);
                    if (!freshPlayerSnap.exists()) {
                        console.error("Player data not found for popup.");
                        card.classList.remove('card-loading');
                        alert("Detalhes do jogador não encontrados.");
                        return;
                    }
                    const currentPlayerPopupData = freshPlayerSnap.data();

                    let popupPaisImagem = '';
                    if (currentPlayerPopupData?.paisId) {
                        try {
                            const popupPaisDoc = await getDoc(doc(db, 'paises', currentPlayerPopupData.paisId));
                            popupPaisImagem = popupPaisDoc.exists() ? popupPaisDoc.data()?.imagem || '' : '';
                        } catch (error) {
                            console.warn(`Could not fetch country data for popup (ID: ${currentPlayerPopupData.paisId})`, error);
                        }
                    }

                    // --- Populate Popup ---
                    popupImage.src = currentPlayerPopupData?.imagem || '';
                    popupImage.alt = currentPlayerPopupData?.nome || 'Player Image';
                    popupName.textContent = currentPlayerPopupData?.nome || 'Nome Indisponível';
                    popupClub.textContent = currentPlayerPopupData?.clube || 'Clube Indisponível';
                    popupOverall.textContent = currentPlayerPopupData?.overall || '-';
                    popupPrice.textContent = `${currentPlayerPopupData?.preco || 0} gCoins`;
                    popupPlayerPosicaoElement.textContent = currentPlayerPopupData?.posicao || '-';
                    popupCasta.textContent = currentPlayerPopupData?.casta || '-';
                    popupCountryFlag.style.display = popupPaisImagem ? 'block' : 'none';
                    if(popupPaisImagem) popupCountryFlag.src = popupPaisImagem;
                    popupCountryFlag.alt = 'Country flag';

                    // --- Popup Listener (Real-time button state) ---
                    const unsubscribePopupListener = onSnapshot(playerDocRefPopup, async (docSnapshot) => {
                        if (!popupBuyButton) return;
                        if (docSnapshot.exists()) {
                            const updatedPlayerForPopup = docSnapshot.data();
                            const compradorUserIdPopup = updatedPlayerForPopup?.compradopor;
                            if (compradorUserIdPopup) {
                                const compradorUsernamePopup = await getUsername(compradorUserIdPopup);
                                popupBuyButton.disabled = true;
                                popupBuyButton.textContent = `Comprado por ${compradorUsernamePopup || compradorUserIdPopup}`;
                                popupBuyButton.classList.add('purchased'); popupBuyButton.classList.remove('buy');
                                popupBuyButton.style.cursor = 'not-allowed';
                            } else {
                                popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar';
                                popupBuyButton.classList.remove('purchased'); popupBuyButton.classList.add('buy');
                                popupBuyButton.style.cursor = 'pointer';
                            }
                        } else {
                           console.warn(`Popup listener: Document ${player.id} no longer exists.`);
                           popupBuyButton.disabled = true; popupBuyButton.textContent = 'Jogador Indisponível';
                           popupBuyButton.classList.add('purchased'); popupBuyButton.classList.remove('buy');
                        }
                    }, (error) => {
                        console.error(`Error in popup listener for ${player.id}:`, error);
                        if (popupBuyButton) { popupBuyButton.disabled = true; popupBuyButton.textContent = 'Erro'; }
                    });
                    // Storing the actual function reference is more direct
                    popup.dataset.unsubscribePopupListener = unsubscribePopupListener;


                    // --- Popup Buy Button Action ---
                  popupBuyButton.onclick = async () => {
    clearPopupMessages();
    popupBuyButton.disabled = true; popupBuyButton.textContent = 'Verificando...';

    try {
        const checkPlayerSnap = await getDoc(playerDocRefPopup);
        if (!checkPlayerSnap.exists()) {
            displayErrorMessage(playerPopupContent, "Este jogador já não está disponível.");
            popupBuyButton.disabled = true; return;
        }
        const checkPlayerData = checkPlayerSnap.data();
        checkPlayerData.id = checkPlayerSnap.id;

        // ... (todas as suas outras verificações de fundos, mercado, etc. permanecem iguais) ...
        if (checkPlayerData.compradopor) {
            const compradorUsername = await getUsername(checkPlayerData.compradopor);
            displayErrorMessage(playerPopupContent, `Este jogador já foi comprado por ${compradorUsername || checkPlayerData.compradopor}.`);
            popupBuyButton.textContent = `Comprado por ${compradorUsername || checkPlayerData.compradopor}`;
            popupBuyButton.classList.add('purchased'); popupBuyButton.classList.remove('buy');
            popupBuyButton.disabled = true; return;
        }
        if (checkPlayerData.marketTimes?.abertura && checkPlayerData.marketTimes?.fechamento) {
            const aberturaDate = checkPlayerData.marketTimes.abertura.toDate ? checkPlayerData.marketTimes.abertura.toDate() : new Date(checkPlayerData.marketTimes.abertura);
            const fechamentoDate = checkPlayerData.marketTimes.fechamento.toDate ? checkPlayerData.marketTimes.fechamento.toDate() : new Date(checkPlayerData.marketTimes.fechamento);
            if (isNaN(aberturaDate.getTime()) || isNaN(fechamentoDate.getTime())) {
                displayErrorMessage(playerPopupContent, "Datas de mercado inválidas.");
                popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar'; return;
            }
            if (!(new Date() >= aberturaDate && new Date() <= fechamentoDate)) {
                displayErrorMessage(playerPopupContent, "O mercado para este jogador está fechado.");
                popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar'; return;
            }
        } else {
            displayErrorMessage(playerPopupContent, "O Mercado está fechado para este Jogador.");
            popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar'; return;
        }
        if (!auth.currentUser) {
            displayErrorMessage(playerPopupContent, "Utilizador não autenticado.");
            popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar'; return;
        }
        const userRef = doc(db, 'users', auth.currentUser.uid);
        const userSnap = await getDoc(userRef);
        if (!userSnap.exists()) {
            displayErrorMessage(playerPopupContent, "Erro ao verificar os seus fundos.");
            popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar'; return;
        }
        const userData = userSnap.data();
        const playerPrice = checkPlayerData.preco || 0;
        const gCoinsField = findLatestGcoinsField(userData);
        const userGcoins = (gCoinsField && typeof userData?.[gCoinsField] === 'number') ? userData[gCoinsField] : 0;
        if (userGcoins < playerPrice) {
            displayErrorMessage(playerPopupContent, "Fundos insuficientes.");
            popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar'; return;
        }
        if (!gCoinsField) {
            displayErrorMessage(playerPopupContent, "Não foi possível determinar a época para a transação.");
            popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar'; return;
        }


        // --- INÍCIO DA MODIFICAÇÃO PARA DIAGNÓSTICO ---
        popupBuyButton.textContent = 'Processando...';
        const currentSeason = gCoinsField.replace('GCoins', '');

        // ETAPA 1: Atualizar o jogador
        try {
            const dadosParaAtualizar = {
                compradopor: auth.currentUser.uid,
                dataCompra: Timestamp.now()
            };
            console.log("A enviar para o Firestore:", dadosParaAtualizar);
            await updateDoc(playerDocRefPopup, dadosParaAtualizar);
         

        } catch (error) {
            console.error("ERRO CRÍTICO AO ATUALIZAR O JOGADOR:", error);
            displayErrorMessage(playerPopupContent, "Falha na Etapa 1: Atualizar jogador.");
            popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar';
            return; // Pára a execução aqui se falhar
        }

        // ETAPA 2: Criar o movimento
        try {
            const movimentoData = {
                userId: auth.currentUser.uid, jogadorId: checkPlayerData.id,
                posicao: checkPlayerData.posicao, preco: playerPrice,
                estado: "Comprado", valorreal: -playerPrice,
                de: auth.currentUser.uid, para: null, mediapontos: null,
                movimentoData: Timestamp.now(), temporada: currentSeason, tipo: "Mercado"
            };
            await addDoc(collection(db, 'movimentos'), movimentoData);
           

        } catch (error) {
            console.error("ERRO CRÍTICO AO CRIAR O MOVIMENTO:", error);
            // ESTE É O ERRO QUE EU SUSPEITO QUE ESTÁ A ACONTECER
            displayErrorMessage(playerPopupContent, "Falha na Etapa 2: Registar movimento.");
            // TODO: Idealmente, aqui deveria haver uma lógica para reverter a compra do jogador.
            popupBuyButton.disabled = false; popupBuyButton.textContent = 'Tentar Novamente';
            return; // Pára a execução aqui
        }
        
        // ETAPA 3: Atualizar o saldo do utilizador
        const movimentosRef = collection(db, 'movimentos');
        const q = query(movimentosRef, where('userId', '==', auth.currentUser.uid), where('temporada', '==', currentSeason));
        const movimentosSnap = await getDocs(q);
        let totalValorReal = 0;
        movimentosSnap.forEach((movDoc) => {
            totalValorReal += movDoc.data()?.valorreal || 0;
        });
        await updateDoc(userRef, { [gCoinsField]: totalValorReal });

        displaySuccessMessage(playerPopupContent, "Jogador comprado com sucesso!");
        // --- FIM DA MODIFICAÇÃO ---

    } catch (geralError) {
         // Este catch agora só apanha erros nas verificações iniciais
        console.error("Erro geral na verificação antes da compra:", geralError);
        displayErrorMessage(playerPopupContent, "Ocorreu um erro inesperado. Tente novamente.");
        popupBuyButton.disabled = false; popupBuyButton.textContent = 'Comprar';
    }
};





                    // --- Show Popup After Delay ---
                    setTimeout(() => {
                        card.classList.remove('card-loading'); // End effect
                        popup.classList.add('active');
                    }, 500);

                } catch (error) {
                    console.error("Error preparing player popup:", error);
                    card.classList.remove('card-loading'); // End effect on error
                    alert("Erro ao carregar detalhes do jogador.");
                }
            }); // End of card.addEventListener('click')

            return card;
        } // End of createPlayerCard


        /**
         * Loads player data from Firestore and populates the market grids.
         */
        async function loadPlayers() {
            let playersLoadedCount = 0;
            let totalMarketPlayers = 0;
            const progressStart = 40;
            const progressForPlayers = 55;

            try {
                updateLoadingProgress(5);
                const jogadoresRef = collection(db, 'jogadores');
                const q = query(jogadoresRef, where('noMercado', '==', true));
                const snapshot = await getDocs(q);
                updateLoadingProgress(10);

                const playersGrids = {
                    'Guarda-Redes': document.getElementById('guarda-redes-grid'),
                    'Defesa': document.getElementById('defesas-grid'),
                    'Médio': document.getElementById('medios-grid'),
                    'Avançado': document.getElementById('avancados-grid')
                };
                Object.values(playersGrids).forEach(grid => { if(grid) grid.innerHTML = ''; });

                totalMarketPlayers = snapshot.docs.length;
                const marketContent = document.querySelector('.content'); // Get content area once
                const existingMsg = marketContent?.querySelector('.no-players-message'); // Check for existing message

                if (totalMarketPlayers === 0) {
                    if (marketContent && !existingMsg) { // Add message only if not already there
                       const noPlayersMsg = document.createElement('p');
                       noPlayersMsg.textContent = "Nenhum jogador no mercado neste momento.";
                       noPlayersMsg.className = 'no-players-message';
                       noPlayersMsg.style.textAlign = 'center'; noPlayersMsg.style.marginTop = '30px';
                       marketContent.appendChild(noPlayersMsg);
                    }
                    updateLoadingProgress(0, progressStart + progressForPlayers);
                    return;
                } else {
                    if (existingMsg) existingMsg.remove(); // Remove message if players found
                }

                // Create cards concurrently
                const cardCreationPromises = snapshot.docs.map(doc => {
                    const player = { ...doc.data(), id: doc.id }; // Combine data and id
                    const grid = playersGrids[player.posicao];
                    if (grid) {
                        return createPlayerCard(player)
                                 .then(card => ({ grid, card })) // Return successful pair
                                 .catch(cardError => {
                                     console.error(`Failed to create card for player ${player.id}:`, cardError);
                                     return null; // Return null on card creation error
                                 });
                    } else {
                        console.warn(`No grid found for position: ${player.posicao}`);
                        return Promise.resolve(null); // Resolve immediately as null
                    }
                });

                // Wait for all card creations and append them
                const results = await Promise.all(cardCreationPromises);
                results.forEach(result => {
                    if (result?.card && result?.grid) {
                         result.grid.appendChild(result.card);
                    }
                    playersLoadedCount++; // Increment count regardless of success for progress calc
                    const currentPlayerProgress = progressStart + Math.floor((playersLoadedCount / totalMarketPlayers) * progressForPlayers);
                    updateLoadingProgress(0, currentPlayerProgress);
                 });


               updateSectionCounts(); // <-- 1. Chame a função de contagem primeiro
                setupSectionToggles(); //

            } catch (error) {
                console.error("Error loading players:", error);
                updateLoadingProgress(0, 100); // Ensure loading screen hides on error
            } finally {
                if (loadingProgress < 100) updateLoadingProgress(0, 100); // Ensure 100%
            }
        }







        /**
         * Sets up event listeners for section title toggles and the main toggle button.
         */
      function setupSectionToggles() {
            const toggleButton = document.getElementById('toggleAllSections');
            if (!toggleButton) return;

            const openSpan = toggleButton.querySelector('.toggle-open');
            const closeSpan = toggleButton.querySelector('.toggle-close');

            // Função que ATUALIZA o estado do botão
            const updateToggleButtonState = () => {
                const allTitles = document.querySelectorAll('.section-title');
                if (allTitles.length === 0) return; 

                const allCollapsed = Array.from(allTitles).every(t => t.classList.contains('collapsed'));
                const collapseState = allCollapsed; 

                toggleButton.classList.toggle('active', collapseState);
                if (openSpan) openSpan.classList.toggle('active', !collapseState);
                if (closeSpan) closeSpan.classList.toggle('active', collapseState);
            };

            // Função que ABRE/FECHA as secções
            function toggleAllSections(collapse) {
                document.querySelectorAll('.section-title').forEach(title => {
                    const grid = title.parentElement?.querySelector('.players-grid');
                    if (grid) {
                        title.classList.toggle('collapsed', collapse);
                        grid.classList.toggle('collapsed', collapse);
                    }
                });
                updateToggleButtonState(); // Esta chamada aqui está correta
            }

            if (!toggleButton.dataset.listenerAttached) {
                toggleButton.addEventListener('click', () => {
                    const shouldCollapse = !toggleButton.classList.contains('active');
                    toggleAllSections(shouldCollapse);
                });
                toggleButton.dataset.listenerAttached = 'true';
            }

            document.querySelectorAll('.section-title').forEach(title => {
                if (!title.dataset.listenerAttached) {
                    title.addEventListener('click', () => {
                        const grid = title.parentElement?.querySelector('.players-grid');
                        if (grid) {
                            const isCollapsing = !title.classList.contains('collapsed');
                            title.classList.toggle('collapsed', isCollapsing);
                            grid.classList.toggle('collapsed', isCollapsing);
                            updateToggleButtonState(); // Atualiza o botão principal
                        }
                    });
                    title.dataset.listenerAttached = 'true';
                }
            });

            // CORRETO: Chame a função aqui para definir o estado inicial UMA VEZ.
            toggleAllSections(true); 
        }

        // --- Loading Progress ---
        let loadingProgress = 0;
        const loadingPercentageElement = document.querySelector('.loading-percentage');
        const progressBar = document.querySelector('.progress-bar');
        let hideLoadingTimerId = null; // Stores the timeout ID

        /**
         * Updates loading progress, hides screen after delay at 100%.
         */
        function updateLoadingProgress(increment = 0, absoluteValue = null) {
            if (typeof hideLoadingTimerId === 'number' && loadingProgress >= 100) return;

            if (absoluteValue !== null) loadingProgress = absoluteValue;
            else loadingProgress += increment;
            loadingProgress = Math.max(0, Math.min(100, loadingProgress));

            const displayPercentage = Math.floor(loadingProgress);
            if (loadingPercentageElement) loadingPercentageElement.textContent = `${displayPercentage}%`;
            if (progressBar) progressBar.style.width = `${loadingProgress}%`;

            if (loadingProgress >= 100 && typeof hideLoadingTimerId !== 'number') {
                hideLoadingTimerId = window.setTimeout(() => {
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    if (content) content.style.display = 'block';
                }, 1500);
            }
        }


        // --- Menu Management ---

        /**
         * Loads menu visibility settings from Firestore.
         */
        async function loadMenuSettings() {
            try {
                const menuSettingsDocRef = doc(db, 'paineis', 'paineis menu');
                const docSnap = await getDoc(menuSettingsDocRef);
                if (docSnap.exists()) return docSnap.data();
                console.warn("Menu settings document ('paineis/paineis menu') not found."); return null;
            } catch (error) {
                console.error('Erro ao carregar configurações do menu:', error); return null;
            }
        }

        /**
         * Checks page access based on status and menu settings. Redirects if denied.
         */
        function checkPageAccess(userEstatuto, menuSettings) {
            const marketSetting = menuSettings?.market || 'off';
            if (marketSetting !== 'on' && userEstatuto !== 'ruler') {
                if (loadingScreen) loadingScreen.style.display = 'none';
                window.location.href = '404.html'; return false;
            }
            return true;
        }




function updateSectionCounts() {
            // Um mapa que liga o ID da secção ao seu texto base
            const sections = {
                'guarda-redes-section': 'GUARDA-REDES',
                'defesas-section': 'DEFESAS',
                'medios-section': 'MÉDIOS',
                'avancados-section': 'AVANÇADOS'
            };

            // Itera sobre cada entrada do mapa
            for (const [sectionId, baseTitle] of Object.entries(sections)) {
                const sectionElement = document.getElementById(sectionId);
                if (sectionElement) {
                    const titleElement = sectionElement.querySelector('.section-title');
                    const gridElement = sectionElement.querySelector('.players-grid');
                    
                    if (titleElement && gridElement) {
                        // Conta quantos '.player-card' existem dentro da grelha da secção
                        const count = gridElement.querySelectorAll('.player-card').length;
                        // Atualiza o texto do título para incluir a contagem
                        titleElement.textContent = `${baseTitle} (${count})`;
                    }
                }
            }
        }




        
        /**
         * Updates visibility of menu items based on settings.
         */
        function updateMenuVisibility(menuSettings) {
            if (!menuSettings) { console.warn("Cannot update menu visibility, settings missing."); return; }

            const menuItemsMap = {
                '1x': document.getElementById('menu-item-1x'),
                'bank': document.getElementById('transaction-button-link'),
                'empire': document.getElementById('menu-item-empire'),
                'market': document.getElementById('menu-item-market'),
                'profile': document.getElementById('menu-item-profile'),
                'rankings': document.getElementById('menu-item-rankings'),
                'team': document.getElementById('menu-item-team')
            };

            let visibleCount = 0;
            for (const [key, element] of Object.entries(menuItemsMap)) {
                if (element) {
                    const isOff = menuSettings.hasOwnProperty(key) && menuSettings[key] === 'off';
                    element.style.display = isOff ? 'none' : ''; // CSS handles default display

                    if (!isOff) {
                         // Ensure correct display type if needed (flex for these)
                        if (key === 'bank' || element.classList.contains('menu-item')) {
                             element.style.display = 'flex';
                        }
                        visibleCount++;
                    }
                } else { console.warn(`Menu element for key '${key}' not found.`); }
            }

            const bottomMenu = document.querySelector('.bottom-menu');
            if (bottomMenu) {
                const visibleMenuItems = bottomMenu.querySelectorAll('.menu-item:not([style*="display: none"])');
                bottomMenu.style.justifyContent = (visibleMenuItems.length <= 4) ? 'space-around' : 'center';
            }
        }

        // --- Initialization and Auth Handling ---

       onAuthStateChanged(auth, async (user) => {
    try {
        if (user) {
            updateLoadingProgress(10); // Auth checked
            currentUserEstatuto = await getUserEstatuto(user.uid);
            updateLoadingProgress(10); // Status fetched

            // NOVO CÓDIGO A ADICIONAR AQUI
            try {
                const userDocRef = doc(db, 'users', user.uid);
                await updateDoc(userDocRef, {
                    ultimoacesso: serverTimestamp()
                });
            } catch (error) {
                console.error("Erro ao atualizar o campo ultimoacesso: ", error);
            }
            // FIM DO NOVO CÓDIGO

            if (currentUserEstatuto !== null) {
                const menuSettings = await loadMenuSettings();
                        updateLoadingProgress(10); // Settings loaded

                        if (!checkPageAccess(currentUserEstatuto, menuSettings)) return; // Redirects
                        updateLoadingProgress(10); // Access checked (Total 40%)

                        updateMenuVisibility(menuSettings);
                        await loadPlayers(); // Handles progress from 40% up
                    } else {
                        // Logged in but not accepted or error
                        if (loadingScreen) loadingScreen.style.display = 'none';
                        window.location.href = '404.html'; return;
                    }
                } else {
                    // No user
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    window.location.href = '404.html'; return;
                }
                updateLoadingProgress(0, 100); // Ensure 100% eventually

            } catch (error) {
                console.error("Critical error during initial load:", error);
                if (loadingScreen) loadingScreen.style.display = 'none';
                alert("Ocorreu um erro grave ao carregar a página.");
                window.location.href = '404.html';
            }
        });

        // --- Event Listeners Setup ---

        document.addEventListener('DOMContentLoaded', () => {
            const popup = document.getElementById('playerPopup');
            const exitButton = document.getElementById('popupExitButton');

            const closePopup = () => {
                if (popup) {
                    popup.classList.remove('active');
                    const unsubscribeFunc = popup.dataset.unsubscribePopupListener;
                    // Now directly storing the function, call it
                    if (unsubscribeFunc && typeof unsubscribeFunc === 'function') {
                        try { unsubscribeFunc(); } catch(e){ console.error("Error detaching listener on close:", e); }
                    }
                    delete popup.dataset.unsubscribePopupListener; // Clean attribute
                    clearPopupMessages();
                }
            };

            if (exitButton) exitButton.addEventListener('click', closePopup);
            if (popup) popup.addEventListener('click', (e) => { if (e.target === popup) closePopup(); });
        });

        // Cleanup listeners on page unload
        window.addEventListener('beforeunload', () => {
            // Card listeners
            document.querySelectorAll('.player-card[data-unsubscribe-card-listener]').forEach(card => {
                 const unsubscribeCardFunc = card.dataset.unsubscribeCardListener;
                 if (unsubscribeCardFunc && typeof unsubscribeCardFunc === 'function') {
                     try { unsubscribeCardFunc(); } catch(e) { /* ignore */ }
                 }
                 delete card.dataset.unsubscribeCardListener;
            });
            // Popup listener
            const popup = document.getElementById('playerPopup');
            if (popup?.dataset?.unsubscribePopupListener) {
                const unsubscribePopupFunc = popup.dataset.unsubscribePopupListener;
                if (unsubscribePopupFunc && typeof unsubscribePopupFunc === 'function') {
                    try { unsubscribePopupFunc(); } catch(e) { /* ignore */ }
                }
                 delete popup.dataset.unsubscribePopupListener;
            }
        });

    </script>

</body>
</html>
