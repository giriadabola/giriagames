<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mercado - Ggames</title>
        <link rel="icon" type="image/png" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTl6Ljabwgx-VXdZz8FcAoygQprujSsCoXc32Y_iU0FjYVPu1B6MffWwp8gcCVuV8TWn39FRk9OIe1nc-esubVJYmdLsTptAoR9GyqNuw4R5MBaeaoWXTc3JaqH2YVNtEmfReQqohvQKvHiI0XwE5na2ty2B9Bt4oELxYv2BaZ7R3UmeylpiVEiIbiLnCB/s320/soccer-ball-png.webp">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }


        .content {
            padding: 20px;
            margin-bottom: 160px;
            display: none; /* Hide content initially */
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .market-section {
            margin-bottom: 40px;
        }

        .section-title {
            font-size: 24px;
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #2176ff;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-title::after {
            content: '▼';
            font-size: 16px;
            transition: transform 0.3s ease;
        }

        .section-title.collapsed::after {
            transform: rotate(-90deg);
        }

   .players-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
    gap: 12px;
    padding: 6px;
    max-height: 10000px; /* <-- VALOR MUITO ALTO PARA A ANIMAÇÃO FUNCIONAR */
    overflow: hidden;    /* <-- MANTÉM-SE PARA A ANIMAÇÃO DE COLAPSO */
    transition: max-height 0.5s ease-out, padding 0.5s ease-out, margin 0.5s ease-out;
}


        .players-grid.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            margin-top: -10px;
            overflow: hidden;
        }


        .player-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 180px;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out;
            border: 2px solid transparent; /* Prevent layout shift */
        }

        /* Style for card loading effect */
        .player-card.card-loading {
            transform: scale(1.03);
            box-shadow: 0 6px 18px rgba(33, 118, 255, 0.35);
            border-color: #2176ff;
            z-index: 10;
        }


        .country-flag {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            object-fit: cover;
            border: 1px solid #fff;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            z-index: 2;
        }

        .player-card:hover {
            /* Slightly different effect on hover, less intense than loading */
            transform: translateY(-3px) scale(1.01);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        /* Ensure loading effect overrides hover transform */
        .player-card.card-loading:hover {
            transform: scale(1.03); /* Maintain loading scale */
        }


        .player-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 80px;
            z-index: 0;
        }

        .player-image {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 50%;
            margin-bottom: 8px;
            border: 2px solid #fff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            z-index: 1;
        }

        .player-name {
            font-size: 14px;
            font-weight: 700;
            margin-bottom: 4px;
            color: #2c3e50;
            margin-top: 8px;
        }

        .player-club {
            font-size: 11px;
            color: #7f8c8d;
            margin-bottom: 8px;
            font-weight: 500;
            text-align: center;
            width: 100%;
        }

        .player-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 8px;
            padding: 6px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 4px;
            text-align: center;
            width: 100%;
        }

        .stat-label {
            font-size: 10px;
            color: #666;
        }

        .stat-value {
            font-size: 14px;
            font-weight: 700;
            color: #2c3e50;
        }

        .stat-value.price,
        .stat-column:last-child .stat-label {
            color: #28a745;
        }

        .buy-button {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .player-card.gold::before { background: linear-gradient(135deg, rgba(255, 215, 0, 0.8) 0%, rgba(255, 237, 74, 0.8) 100%); }
        .player-card.silver::before { background: linear-gradient(135deg, rgba(192, 192, 192, 0.8) 0%, rgba(232, 232, 232, 0.8) 100%); }
        .player-card.bronze::before { background: linear-gradient(135deg, rgba(205, 127, 50, 0.8) 0%, rgba(233, 150, 122, 0.8) 100%); }
        .player-card.platinum::before { background: linear-gradient(135deg, rgba(169, 176, 209, 0.8) 0%, rgba(157, 157, 196, 0.8) 100%); }

        .buy-button.available {
            background: linear-gradient(135deg, #2176ff 0%, #0056d6 100%);
            color: white;
        }
        .buy-button.available:hover:not(:disabled) {
            background: linear-gradient(135deg, #0056d6 0%, #003ba3 100%);
            transform: translateY(-2px);
        }

        .buy-button.purchased {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
            color: white;
            cursor: not-allowed;
        }
        .buy-button:disabled { /* General disabled style */
            opacity: 0.7;
            cursor: not-allowed;
        }


        /* Loading Screen Styles */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1001; /* Above content but below popup */
        }

        .loading-percentage { margin-top: 15px; font-size: 18px; font-weight: bold; color: #2176ff; }
        .progress-bar-container { width: 200px; height: 10px; background-color: #e0e0e0; border-radius: 5px; margin-top: 10px; overflow: hidden; }
        .progress-bar { height: 100%; width: 0%; background: linear-gradient(135deg, #2176ff 0%, #0056d6 100%); border-radius: 5px; transition: width 0.3s ease-in-out; }
        .loading-spinner { border: 16px solid #f3f3f3; border-top: 16px solid #3498db; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }


        /* Popup Styles */
        .popup-overlay {
            display: none; /* Initially hidden */
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 2000; /* Highest */
            justify-content: center; align-items: center;
            opacity: 0; /* Start transparent for fade-in */
            transition: opacity 0.3s ease; /* Fade transition */
        }
        .popup-overlay.active { display: flex; opacity: 1; /* Fade in */ }

        .popup-content {
            background: white; padding: 24px; border-radius: 12px;
            width: 90%; max-width: 400px; position: relative;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
            transform: translateY(-20px); /* Start slightly up */
            opacity: 0; /* Start transparent */
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .popup-overlay.active .popup-content {
            transform: translateY(0); /* Move down to final position */
            opacity: 1; /* Fade in */
        }

        .popup-button.purchased { background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%); color: white; cursor: not-allowed; }
        .popup-header { text-align: center; margin-bottom: 20px; position: relative; }
        .popup-country-flag { position: absolute; top: 8px; right: 8px; width: 24px; height: 24px; border-radius: 50%; object-fit: cover; border: 2px solid #fff; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); z-index: 2; }
        .popup-player-image { width: 120px; height: 120px; border-radius: 50%; margin: 0 auto 16px; display: block; border: 3px solid #fff; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); }
        .popup-player-name { font-size: 24px; font-weight: 700; color: #2c3e50; margin-bottom: 8px; }
        .popup-player-club { font-size: 16px; color: #7f8c8d; margin-bottom: 20px; }
        .popup-stats { background: #f8f9fa; border-radius: 8px; padding: 16px; margin-bottom: 24px; position: relative; /* Needed for message positioning */ }
        .popup-stat-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid #e9ecef; }
        .popup-stat-row:last-child { margin-bottom: 0; padding-bottom: 0; border-bottom: none; }
        .popup-stat-label { font-size: 14px; color: #6c757d; }
        .popup-stat-value { font-size: 16px; font-weight: 600; color: #2c3e50; }
        .popup-buttons { display: flex; gap: 12px; margin-top: 15px; /* Add margin if messages appear above */ }
        .popup-button { flex: 1; padding: 12px; border: none; border-radius: 6px; font-weight: 600; font-size: 14px; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; }
        .popup-button.buy { background: #28a745; color: white; }
        .popup-button.buy:hover:not(:disabled) { background: #218838; }
        .popup-button.exit { background: #dc3545; color: white; }
        .popup-button.exit:hover { background: #c82333; }
        .popup-button:disabled { opacity: 0.65; cursor: not-allowed; }


        /* Section Toggles */
        .toggle-all-button {
            position: relative; width: 120px; height: 36px; border-radius: 18px;
            background-color: #f0f0f0; border: 2px solid #ddd; cursor: pointer;
            transition: all 0.3s ease; margin-bottom: 20px; padding: 0;
            display: flex; justify-content: space-between; align-items: center;
            overflow: hidden; margin-left: auto; /* Align to the right */
        }
        .toggle-all-button span { padding: 0 12px; font-size: 14px; font-weight: 600; transition: color 0.3s ease; z-index: 1; pointer-events: none; }
        .toggle-all-button::before {
            content: ''; position: absolute; width: 60px; height: calc(100% - 4px);
            border-radius: 16px; background-color: #4CAF50; /* Green for 'Abre' */
            top: 2px; left: 2px;
            transition: transform 0.3s ease, background-color 0.3s ease; z-index: 0;
        }
        .toggle-all-button.active::before {
            transform: translateX(calc(100% - 4px)); /* Move right */
            background-color: #dc3545; /* Red for 'Fecha' */
        }
        .toggle-all-button span.active { color: white; }
        .toggle-all-button span:not(.active) { color: #666; }


        /* General & Utility */
         .player-info { width: 100%; text-align: center; }
         .no-players-message { text-align: center; margin-top: 30px; color: #666; font-style: italic; }

        /* Popup Messages */
        .error-message, .success-message {
            text-align: center; font-weight: bold; margin: 10px 0 -5px 0; /* Appear between stats and buttons */
            padding: 8px; border-radius: 4px; font-size: 0.9em;
        }
        .error-message { color: #721c24; background-color: #f8d7da; border: 1px solid #f5c6cb; }
        .success-message { color: #155724; background-color: #d4edda; border: 1px solid #c3e6cb; }

        .pickcard-style {
    background: white;
    border-radius: 8px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 15px;
    max-width: 350px;
    margin-left: auto;
    margin-right: auto;
    border-left: 5px solid #2176ff;
    transition: transform 0.2s ease;
}
.pickcard-style:hover {
    transform: translateY(-2px);
}

.pickcard-style i {
    font-size: 28px;
    color: #2176ff;
}

#countdown-label {
    font-size: 14px;
    color: #666;
    margin-bottom: 4px;
}

#countdown-timer {
    font-size: 22px;
    font-weight: 700;
    color: #333;
    letter-spacing: 2px;
}

#countdown-timer.open {
    color: #28a745; /* Verde quando o mercado está aberto */
}

/* Estilo para a lista de horários no popup */
#upcomingSchedulesList .schedule-item {
    background-color: #f8f9fa;
    border: 1px solid #e9ecef;
    border-radius: 6px;
    padding: 12px;
    margin-bottom: 10px;
}

#upcomingSchedulesList .schedule-item p {
    margin: 0;
    padding: 2px 0;
    font-size: 14px;
    color: #333;
}

.header-container {
    display: flex;          /* Ativa o Flexbox */
    align-items: center;    /* Alinha os itens verticalmente ao centro */
    flex-wrap: wrap;        /* PERMITE que os itens quebrem para a linha de baixo */
    gap: 16px 24px;         /* Espaçamento vertical e horizontal entre os itens */
    margin-bottom: 20px;
}

.header-right-controls {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-left: auto; /* MÁGICA: Empurra este grupo para a direita em telas grandes */
    flex-wrap: wrap;   /* Permite que o botão e o timer também quebrem de linha se necessário */
}


/* Media Query: Aplica estas regras quando a tela for de 768px ou MENOR */
@media (max-width: 768px) {
    .header-container {
        justify-content: center; /* Centraliza tudo quando os itens quebram de linha */
        text-align: center;
    }

    .header-right-controls {
        margin-left: 0;         /* Remove a margem automática para permitir a centralização */
        justify-content: center; /* Garante que os controles fiquem centralizados */
        width: 100%;            /* Ocupa toda a largura para uma centralização consistente */
    }
}

    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="loading-percentage">0%</div>
        <div class="progress-bar-container">
            <div class="progress-bar"></div>
        </div>
    </div>

    <!-- Popup Overlay para Detalhes do Jogador -->
    <div class="popup-overlay" id="playerPopup">
        <div class="popup-content">
            <div class="popup-header">
                <img src="" alt="" class="popup-player-image" id="popupPlayerImage">
                <img src="" alt="" class="popup-country-flag" id="popupCountryFlag">
                <div class="popup-player-name" id="popupPlayerName"></div>
                <div class="popup-player-club" id="popupPlayerClub"></div>
            </div>
            <div class="popup-stats">
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Overall</div>
                    <div class="popup-stat-value" id="popupPlayerOverall"></div>
                </div>
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Preço</div>
                    <div class="popup-stat-value" id="popupPlayerPrice"></div>
                </div>
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Posição</div>
                    <div class="popup-stat-value" id="popupPlayerPosicao"></div>
                </div>
                <div class="popup-stat-row">
                    <div class="popup-stat-label">Casta</div>
                    <div class="popup-stat-value" id="popupPlayerCasta"></div>
                </div>
                 <!-- Messages will be inserted here by JS -->
            </div>
            <div class="popup-buttons">
                <button class="popup-button buy" id="popupBuyButton">Comprar</button>
                <button class="popup-button exit" id="popupExitButton">Sair</button>
            </div>
        </div>
    </div>

    <!-- Popup para ver as próximas janelas de transferências -->
    <div class="popup-overlay" id="schedulesPopup">
        <div class="popup-content">
            <h2 style="text-align: center; margin-bottom: 20px;">Próximas Aberturas</h2>
            <div id="upcomingSchedulesList" style="max-height: 300px; overflow-y: auto;">
                <!-- A lista será preenchida pelo JavaScript -->
            </div>
            <div class="popup-buttons" style="margin-top: 20px;">
                <button class="popup-button exit" id="closeSchedulesPopup">Fechar</button>
            </div>
        </div>
    </div>

  <div class="content">
    
    <!-- Este é o nosso contentor principal com Flexbox e classes CSS -->
    <div class="header-container">
        
        <!-- Elemento da Esquerda -->
        <h1>Mercado</h1>

        <!-- Contentor para agrupar os elementos da Direita -->
        <div class="header-right-controls">
            
            <!-- Cronómetro -->
            <div id="countdown-container" class="pickcard-style" style="display: none; cursor: pointer;">
                <i class="fas fa-hourglass-start"></i>
                <div>
                    <div id="countdown-label">Próxima Janela Abre Em:</div>
                    <div id="countdown-timer">--:--:--:--</div>
                </div>
            </div>

            <!-- Botão de Transações -->
            <a id="transaction-button-link" href="bank.html" class="transaction-button" style="padding: 8px 16px; background: linear-gradient(135deg, #2176ff, #0056d6); color: white; text-decoration: none; border-radius: 18px; font-weight: 600; font-size: 14px; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px; box-shadow: 0 2px 4px rgba(33, 118, 255, 0.2); transform: translateY(0);">
                <i class="fas fa-dollar-sign" style="font-size: 16px;"></i>Transações
            </a>

        </div>
    </div>

    <div style="display: flex; justify-content: flex-end; margin-bottom: 20px;">
       <button id="toggleAllSections" class="toggle-all-button active">
          <span class="toggle-open">Abre</span>
          <span class="toggle-close active">Fecha</span>
       </button>
    </div>

        <div class="market-section" id="guarda-redes-section">
            <h2 class="section-title collapsed">GUARDA-REDES</h2>
            <div class="players-grid collapsed" id="guarda-redes-grid"></div>
        </div>

        <div class="market-section" id="defesas-section">
            <h2 class="section-title collapsed">DEFESAS</h2>
            <div class="players-grid collapsed" id="defesas-grid"></div>
        </div>

        <div class="market-section" id="medios-section">
            <h2 class="section-title collapsed">MÉDIOS</h2>
            <div class="players-grid collapsed" id="medios-grid"></div>
        </div>

        <div class="market-section" id="avancados-section">
            <h2 class="section-title collapsed">AVANÇADOS</h2>
            <div class="players-grid collapsed" id="avancados-grid"></div>
        </div>
        <!-- Message for no players will be added here by JS -->
    </div>


    <script src="config.js"></script>
    <script type="module">
     import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, collection, getDocs, doc, getDoc, updateDoc, Timestamp, addDoc, query, where, onSnapshot, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);

// --- DOM Elements ---
const loadingScreen = document.getElementById('loading-screen');
const content = document.querySelector('.content');

// --- Global State ---
let currentUserEstatuto = null;
let countdownInterval; // Variável global para controlar o cronómetro

// --- Helper Functions ---

/**
 * Fetches the user's 'estatuto' from Firestore.
 * @param {string} userId - The Firebase Authentication user ID.
 * @returns {Promise<string|null>} The user's 'estatuto' or null if not found/accepted/error.
 */
async function getUserEstatuto(userId) {
    if (!userId) return null;
    const userDocRef = doc(db, 'users', userId);
    try {
        const docSnap = await getDoc(userDocRef);
        if (docSnap.exists() && docSnap.data()?.aceite === "Yes") {
            return docSnap.data().estatuto;
        } else {
            return null;
        }
    } catch (error) {
        console.error("Error fetching user status:", error);
        return null;
    }
}

/**
 * Fetches a username from Firestore based on user ID.
 * @param {string} userId - The user ID to look up.
 * @returns {Promise<string>} The username or the original user ID as fallback.
 */
async function getUsername(userId) {
    if (!userId) return userId;
    const userDoc = doc(db, 'users', userId);
    try {
        const docSnap = await getDoc(userDoc);
        if (docSnap.exists()) {
            return docSnap.data()?.nometabela || userId;
        } else {
            return userId;
        }
    } catch (error) {
        console.error(`Error fetching username for userId ${userId}:`, error);
        return userId;
    }
}

/**
 * Removes any existing success or error messages from the popup.
 */
function clearPopupMessages() {
    const popupContent = document.querySelector('.popup-content');
    if (!popupContent) return;
    const existingError = popupContent.querySelector('.error-message');
    const existingSuccess = popupContent.querySelector('.success-message');
    if (existingError) existingError.remove();
    if (existingSuccess) existingSuccess.remove();
}

/**
 * Displays an error message within the popup content area.
 * @param {HTMLElement} popupContent - The popup's content element.
 * @param {string} message - The error message to display.
 */
function displayErrorMessage(popupContent, message) {
    if (!popupContent) return;
    clearPopupMessages();
    const errorElement = document.createElement('div');
    errorElement.className = 'error-message';
    errorElement.textContent = message;
    const statsSection = popupContent.querySelector('.popup-stats');
    if (statsSection) {
        statsSection.insertAdjacentElement('afterend', errorElement);
    } else {
        popupContent.appendChild(errorElement);
    }
}

/**
 * Displays a success message within the popup content area.
 * @param {HTMLElement} popupContent - The popup's content element.
 * @param {string} message - The success message to display.
 */
function displaySuccessMessage(popupContent, message) {
    if (!popupContent) return;
    clearPopupMessages();
    const successElement = document.createElement('div');
    successElement.className = 'success-message';
    successElement.textContent = message;
    const statsSection = popupContent.querySelector('.popup-stats');
    if (statsSection) {
        statsSection.insertAdjacentElement('afterend', successElement);
    } else {
        popupContent.appendChild(successElement);
    }
}

/**
 * Determines the CSS class based on player tier ('casta').
 * @param {string} casta - The player's tier string.
 * @returns {string} The corresponding CSS class name ('gold', 'silver', etc.).
 */
function getTierClass(casta) {
    switch (casta) {
        case 'Jogador Ouro': return 'gold';
        case 'Jogador Prata': return 'silver';
        case 'Jogador Bronze': return 'bronze';
        case 'Jogador Platina': return 'platinum';
        default: return '';
    }
}

/**
 * Finds the most recent 'YYYYMMDDGCoins' field in user data.
 * @param {object} userData - The user's data object from Firestore.
 * @returns {string|null} The key of the latest GCoins field or null.
 */
function findLatestGcoinsField(userData) {
    let latestSeason = 0;
    let latestGcoinsField = null;
    if (!userData) return null;

    for (const key in userData) {
        if (key.match(/^\d{8}GCoins$/)) {
            const season = parseInt(key.slice(0, 8), 10);
            if (!isNaN(season) && season >= latestSeason) {
                latestSeason = season;
                latestGcoinsField = key;
            }
        }
    }
    if (!latestGcoinsField) {
        console.warn("Could not determine the latest GCoins field for user.");
    }
    return latestGcoinsField;
}

// --- Core Logic Functions ---

/**
 * Creates a player card element with data and event listeners.
 * @param {object} player - The player data object from Firestore.
 * @returns {Promise<HTMLElement>} The created card element.
 */
async function createPlayerCard(player) {
    const card = document.createElement('div');
    card.className = `player-card ${getTierClass(player.casta)}`;
    card.dataset.playerId = player.id;

    let paisImagem = '';
    if (player.paisId) {
        try {
            const paisDoc = await getDoc(doc(db, 'paises', player.paisId));
            paisImagem = paisDoc.exists() ? paisDoc.data()?.imagem || '' : '';
        } catch (error) {
            console.warn(`Could not fetch country data for ID: ${player.paisId}`, error);
        }
    }

    let initialButtonText = 'Comprar';
    let initialButtonClass = 'available';
    let initialButtonDisabled = false;
    if (player.compradopor) {
        initialButtonClass = 'purchased';
        initialButtonDisabled = true;
        initialButtonText = `Comprado por ${player.compradopor}`; // Temp ID
        getUsername(player.compradopor).then(username => {
            const buttonElement = card.querySelector('.buy-button');
            if (buttonElement) buttonElement.textContent = `Comprado por ${username || player.compradopor}`;
        }).catch(err => console.error("Error fetching initial card username:", err));
    }

    card.innerHTML = `
        ${paisImagem ? `<img src="${paisImagem}" alt="Country flag" class="country-flag">` : ''}
        <img src="${player.imagem || ''}" alt="${player.nome || 'Player'}" class="player-image">
        <div class="player-info">
            <div class="player-name">${player.nome || '-'}</div>
            <div class="player-club">${player.clube || '-'}</div>
            <div class="player-stats">
                <div class="stat-column">
                    <div class="stat-label">Overall:</div>
                    <div class="stat-value">${player.overall || '-'}</div>
                </div>
                <div class="stat-column">
                    <div class="stat-value price">${player.preco || 0}</div>
                    <div class="stat-label">gCoins</div>
                </div>
            </div>
            <button class="buy-button ${initialButtonClass}" ${initialButtonDisabled ? 'disabled' : ''}>
                ${initialButtonText}
            </button>
        </div>
    `;
    const buyButtonCard = card.querySelector('.buy-button');

    const playerDocRef = doc(db, 'jogadores', player.id);
    const unsubscribeCard = onSnapshot(playerDocRef, async (docSnapshot) => {
        if (!buyButtonCard) return;

        if (docSnapshot.exists()) {
            const updatedPlayer = docSnapshot.data();
            const compradorUserId = updatedPlayer?.compradopor;
            if (compradorUserId) {
                const compradorUsernameCard = await getUsername(compradorUserId);
                buyButtonCard.textContent = `Comprado por ${compradorUsernameCard || compradorUserId}`;
                buyButtonCard.classList.add('purchased');
                buyButtonCard.classList.remove('available');
                buyButtonCard.disabled = true;
            } else {
                buyButtonCard.textContent = 'Comprar';
                buyButtonCard.classList.remove('purchased');
                buyButtonCard.classList.add('available');
                buyButtonCard.disabled = false;
            }
        } else {
            console.warn(`Player card listener: Document ${player.id} does not exist. Removing card.`);
            if (unsubscribeCard && typeof unsubscribeCard === 'function') {
                try {
                    unsubscribeCard();
                } catch (e) { /* ignore */ }
            }
            card.remove();
        }
    }, (error) => {
        console.error(`Error in player card listener for ${player.id}:`, error);
        if (buyButtonCard) {
            buyButtonCard.textContent = 'Erro';
            buyButtonCard.disabled = true;
        }
    });

    card.dataset.unsubscribeCardListener = unsubscribeCard;

    card.addEventListener('click', async (event) => {
        const clickedButton = event.target.closest('.buy-button');
        if (clickedButton?.classList.contains('purchased')) {
            return;
        }

        card.classList.add('card-loading');

        const popup = document.getElementById('playerPopup');
        if (!popup) {
            console.error("Popup element not found!");
            card.classList.remove('card-loading');
            return;
        }

        const existingUnsubscribeRef = popup.dataset.unsubscribePopupListener;
        if (existingUnsubscribeRef) {
            const existingUnsubscribe = window[existingUnsubscribeRef];
            if (existingUnsubscribe && typeof existingUnsubscribe === 'function') {
                try {
                    existingUnsubscribe();
                } catch (e) {
                    console.error("Error detaching previous popup listener:", e);
                }
            }
        }
        delete popup.dataset.unsubscribePopupListener;
        clearPopupMessages();

        const popupImage = document.getElementById('popupPlayerImage');
        const popupName = document.getElementById('popupPlayerName');
        const popupClub = document.getElementById('popupPlayerClub');
        const popupOverall = document.getElementById('popupPlayerOverall');
        const popupPrice = document.getElementById('popupPlayerPrice');
        const popupCasta = document.getElementById('popupPlayerCasta');
        const popupBuyButton = document.getElementById('popupBuyButton');
        const popupCountryFlag = document.getElementById('popupCountryFlag');
        const popupPlayerPosicaoElement = document.getElementById('popupPlayerPosicao');
        const playerPopupContent = document.querySelector('.popup-content');

        if (!popupImage || !popupName || !popupClub || !popupOverall || !popupPrice || !popupCasta || !popupBuyButton || !popupCountryFlag || !popupPlayerPosicaoElement || !playerPopupContent) {
            console.error("One or more essential popup elements were not found!");
            card.classList.remove('card-loading');
            alert("Erro ao carregar o popup do jogador.");
            return;
        }

        try {
            const playerDocRefPopup = doc(db, 'jogadores', player.id);
            const freshPlayerSnap = await getDoc(playerDocRefPopup);
            if (!freshPlayerSnap.exists()) {
                console.error("Player data not found for popup.");
                card.classList.remove('card-loading');
                alert("Detalhes do jogador não encontrados.");
                return;
            }
            const currentPlayerPopupData = freshPlayerSnap.data();

            let popupPaisImagem = '';
            if (currentPlayerPopupData?.paisId) {
                try {
                    const popupPaisDoc = await getDoc(doc(db, 'paises', currentPlayerPopupData.paisId));
                    popupPaisImagem = popupPaisDoc.exists() ? popupPaisDoc.data()?.imagem || '' : '';
                } catch (error) {
                    console.warn(`Could not fetch country data for popup (ID: ${currentPlayerPopupData.paisId})`, error);
                }
            }

            popupImage.src = currentPlayerPopupData?.imagem || '';
            popupImage.alt = currentPlayerPopupData?.nome || 'Player Image';
            popupName.textContent = currentPlayerPopupData?.nome || 'Nome Indisponível';
            popupClub.textContent = currentPlayerPopupData?.clube || 'Clube Indisponível';
            popupOverall.textContent = currentPlayerPopupData?.overall || '-';
            popupPrice.textContent = `${currentPlayerPopupData?.preco || 0} gCoins`;
            popupPlayerPosicaoElement.textContent = currentPlayerPopupData?.posicao || '-';
            popupCasta.textContent = currentPlayerPopupData?.casta || '-';
            popupCountryFlag.style.display = popupPaisImagem ? 'block' : 'none';
            if (popupPaisImagem) popupCountryFlag.src = popupPaisImagem;
            popupCountryFlag.alt = 'Country flag';

            const unsubscribePopupListener = onSnapshot(playerDocRefPopup, async (docSnapshot) => {
                if (!popupBuyButton) return;
                if (docSnapshot.exists()) {
                    const updatedPlayerForPopup = docSnapshot.data();
                    const compradorUserIdPopup = updatedPlayerForPopup?.compradopor;
                    if (compradorUserIdPopup) {
                        const compradorUsernamePopup = await getUsername(compradorUserIdPopup);
                        popupBuyButton.disabled = true;
                        popupBuyButton.textContent = `Comprado por ${compradorUsernamePopup || compradorUserIdPopup}`;
                        popupBuyButton.classList.add('purchased');
                        popupBuyButton.classList.remove('buy');
                        popupBuyButton.style.cursor = 'not-allowed';
                    } else {
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        popupBuyButton.classList.remove('purchased');
                        popupBuyButton.classList.add('buy');
                        popupBuyButton.style.cursor = 'pointer';
                    }
                } else {
                    console.warn(`Popup listener: Document ${player.id} no longer exists.`);
                    popupBuyButton.disabled = true;
                    popupBuyButton.textContent = 'Jogador Indisponível';
                    popupBuyButton.classList.add('purchased');
                    popupBuyButton.classList.remove('buy');
                }
            }, (error) => {
                console.error(`Error in popup listener for ${player.id}:`, error);
                if (popupBuyButton) {
                    popupBuyButton.disabled = true;
                    popupBuyButton.textContent = 'Erro';
                }
            });
            popup.dataset.unsubscribePopupListener = unsubscribePopupListener;

            popupBuyButton.onclick = async () => {
                clearPopupMessages();
                popupBuyButton.disabled = true;
                popupBuyButton.textContent = 'Verificando...';

                try {
                    const checkPlayerSnap = await getDoc(playerDocRefPopup);
                    if (!checkPlayerSnap.exists()) {
                        displayErrorMessage(playerPopupContent, "Este jogador já não está disponível.");
                        popupBuyButton.disabled = true;
                        return;
                    }
                    const checkPlayerData = checkPlayerSnap.data();
                    checkPlayerData.id = checkPlayerSnap.id;

                    if (checkPlayerData.compradopor) {
                        const compradorUsername = await getUsername(checkPlayerData.compradopor);
                        displayErrorMessage(playerPopupContent, `Este jogador já foi comprado por ${compradorUsername || checkPlayerData.compradopor}.`);
                        popupBuyButton.textContent = `Comprado por ${compradorUsername || checkPlayerData.compradopor}`;
                        popupBuyButton.classList.add('purchased');
                        popupBuyButton.classList.remove('buy');
                        popupBuyButton.disabled = true;
                        return;
                    }

                    const schedulesRef = collection(db, 'paineis', 'Banca', 'horarioMercado');
                    const schedulesSnapshot = await getDocs(schedulesRef);

                    if (schedulesSnapshot.empty) {
                        displayErrorMessage(playerPopupContent, "O mercado está globalmente fechado. Nenhuma janela de transferências está ativa.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        return;
                    }

                    const agora = new Date();
                    let isMarketCurrentlyOpen = false;

                    schedulesSnapshot.forEach(doc => {
                        const schedule = doc.data();
                        const abertura = schedule.abertura.toDate();
                        const fechamento = schedule.fechamento.toDate();
                        if (agora >= abertura && agora <= fechamento) {
                            isMarketCurrentlyOpen = true;
                        }
                    });

                    if (!isMarketCurrentlyOpen) {
                        displayErrorMessage(playerPopupContent, "O mercado está fechado. Por favor, aguarde pela próxima janela de transferências.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        return;
                    }

                    if (!auth.currentUser) {
                        displayErrorMessage(playerPopupContent, "Utilizador não autenticado.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        return;
                    }
                    const userRef = doc(db, 'users', auth.currentUser.uid);
                    const userSnap = await getDoc(userRef);
                    if (!userSnap.exists()) {
                        displayErrorMessage(playerPopupContent, "Erro ao verificar os seus fundos.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        return;
                    }
                    const userData = userSnap.data();
                    const playerPrice = checkPlayerData.preco || 0;
                    const gCoinsField = findLatestGcoinsField(userData);
                    const userGcoins = (gCoinsField && typeof userData?.[gCoinsField] === 'number') ? userData[gCoinsField] : 0;
                    if (userGcoins < playerPrice) {
                        displayErrorMessage(playerPopupContent, "Fundos insuficientes.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        return;
                    }
                    if (!gCoinsField) {
                        displayErrorMessage(playerPopupContent, "Não foi possível determinar a época para a transação.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        return;
                    }

                    popupBuyButton.textContent = 'Processando...';
                    const currentSeason = gCoinsField.replace('GCoins', '');

                    try {
                        await updateDoc(playerDocRefPopup, {
                            compradopor: auth.currentUser.uid,
                            dataCompra: Timestamp.now()
                        });
                    } catch (error) {
                        console.error("ERRO CRÍTICO AO ATUALIZAR O JOGADOR:", error);
                        displayErrorMessage(playerPopupContent, "Falha na Etapa 1: Atualizar jogador.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Comprar';
                        return;
                    }

                    try {
                        await addDoc(collection(db, 'movimentos'), {
                            userId: auth.currentUser.uid,
                            jogadorId: checkPlayerData.id,
                            posicao: checkPlayerData.posicao,
                            preco: playerPrice,
                            estado: "Comprado",
                            valorreal: -playerPrice,
                            de: auth.currentUser.uid,
                            para: null,
                            mediapontos: null,
                            movimentoData: Timestamp.now(),
                            temporada: currentSeason,
                            tipo: "Mercado"
                        });
                    } catch (error) {
                        console.error("ERRO CRÍTICO AO CRIAR O MOVIMENTO:", error);
                        displayErrorMessage(playerPopupContent, "Falha na Etapa 2: Registar movimento.");
                        popupBuyButton.disabled = false;
                        popupBuyButton.textContent = 'Tentar Novamente';
                        return;
                    }

                    const movimentosRef = collection(db, 'movimentos');
                    const q = query(movimentosRef, where('userId', '==', auth.currentUser.uid), where('temporada', '==', currentSeason));
                    const movimentosSnap = await getDocs(q);
                    let totalValorReal = 0;
                    movimentosSnap.forEach((movDoc) => {
                        totalValorReal += movDoc.data()?.valorreal || 0;
                    });
                    await updateDoc(userRef, {
                        [gCoinsField]: totalValorReal
                    });

                    displaySuccessMessage(playerPopupContent, "Jogador comprado com sucesso!");

                } catch (geralError) {
                    console.error("Erro geral na verificação antes da compra:", geralError);
                    displayErrorMessage(playerPopupContent, "Ocorreu um erro inesperado. Tente novamente.");
                    popupBuyButton.disabled = false;
                    popupBuyButton.textContent = 'Comprar';
                }
            };

            setTimeout(() => {
                card.classList.remove('card-loading');
                popup.classList.add('active');
            }, 500);

        } catch (error) {
            console.error("Error preparing player popup:", error);
            card.classList.remove('card-loading');
            alert("Erro ao carregar detalhes do jogador.");
        }
    });

    return card;
}


/**
 * Loads player data from Firestore and populates the market grids.
 */
async function loadPlayers() {
    let playersLoadedCount = 0;
    let totalMarketPlayers = 0;
    const progressStart = 40;
    const progressForPlayers = 55;

    try {
        updateLoadingProgress(5);
        const jogadoresRef = collection(db, 'jogadores');
        const q = query(jogadoresRef, where('noMercado', '==', true));
        const snapshot = await getDocs(q);
        updateLoadingProgress(10);

        const castaOrder = {
            'Jogador Platina': 4,
            'Jogador Ouro': 3,
            'Jogador Prata': 2,
            'Jogador Bronze': 1
        };

        const sortedDocs = snapshot.docs.sort((a, b) => {
            const playerA = a.data();
            const playerB = b.data();
            const rankA = castaOrder[playerA.casta] || 0;
            const rankB = castaOrder[playerB.casta] || 0;
            if (rankA !== rankB) {
                return rankB - rankA;
            }
            const overallA = playerA.overall || 0;
            const overallB = playerB.overall || 0;
            return overallB - overallA;
        });

        const playersGrids = {
            'Guarda-Redes': document.getElementById('guarda-redes-grid'),
            'Defesa': document.getElementById('defesas-grid'),
            'Médio': document.getElementById('medios-grid'),
            'Avançado': document.getElementById('avancados-grid')
        };
        Object.values(playersGrids).forEach(grid => {
            if (grid) grid.innerHTML = '';
        });

        totalMarketPlayers = sortedDocs.length;
        const marketContent = document.querySelector('.content');
        const existingMsg = marketContent?.querySelector('.no-players-message');

        if (totalMarketPlayers === 0) {
            if (marketContent && !existingMsg) {
                const noPlayersMsg = document.createElement('p');
                noPlayersMsg.textContent = "Nenhum jogador no mercado neste momento.";
                noPlayersMsg.className = 'no-players-message';
                noPlayersMsg.style.textAlign = 'center';
                noPlayersMsg.style.marginTop = '30px';
                marketContent.appendChild(noPlayersMsg);
            }
            updateLoadingProgress(0, progressStart + progressForPlayers);
            return;
        } else {
            if (existingMsg) existingMsg.remove();
        }

        const cardCreationPromises = sortedDocs.map(doc => {
            const player = { ...doc.data(),
                id: doc.id
            };
            const grid = playersGrids[player.posicao];
            if (grid) {
                return createPlayerCard(player)
                    .then(card => ({
                        grid,
                        card
                    }))
                    .catch(cardError => {
                        console.error(`Failed to create card for player ${player.id}:`, cardError);
                        return null;
                    });
            } else {
                console.warn(`No grid found for position: ${player.posicao}`);
                return Promise.resolve(null);
            }
        });

        const results = await Promise.all(cardCreationPromises);
        results.forEach(result => {
            if (result?.card && result?.grid) {
                result.grid.appendChild(result.card);
            }
            playersLoadedCount++;
            const currentPlayerProgress = progressStart + Math.floor((playersLoadedCount / totalMarketPlayers) * progressForPlayers);
            updateLoadingProgress(0, currentPlayerProgress);
        });

        updateSectionCounts();
        setupSectionToggles();

    } catch (error) {
        console.error("Error loading players:", error);
        updateLoadingProgress(0, 100);
    } finally {
        if (loadingProgress < 100) updateLoadingProgress(0, 100);
    }
}

/**
 * Sets up event listeners for section title toggles and the main toggle button.
 */
function setupSectionToggles() {
    const toggleButton = document.getElementById('toggleAllSections');
    if (!toggleButton) return;

    const openSpan = toggleButton.querySelector('.toggle-open');
    const closeSpan = toggleButton.querySelector('.toggle-close');

    const updateToggleButtonState = () => {
        const allTitles = document.querySelectorAll('.section-title');
        if (allTitles.length === 0) return;
        const allCollapsed = Array.from(allTitles).every(t => t.classList.contains('collapsed'));
        toggleButton.classList.toggle('active', allCollapsed);
        if (openSpan) openSpan.classList.toggle('active', !allCollapsed);
        if (closeSpan) closeSpan.classList.toggle('active', allCollapsed);
    };

    function toggleAllSections(collapse) {
        document.querySelectorAll('.section-title').forEach(title => {
            const grid = title.parentElement?.querySelector('.players-grid');
            if (grid) {
                title.classList.toggle('collapsed', collapse);
                grid.classList.toggle('collapsed', collapse);
            }
        });
        updateToggleButtonState();
    }

    if (!toggleButton.dataset.listenerAttached) {
        toggleButton.addEventListener('click', () => {
            const shouldCollapse = !toggleButton.classList.contains('active');
            toggleAllSections(shouldCollapse);
        });
        toggleButton.dataset.listenerAttached = 'true';
    }

    document.querySelectorAll('.section-title').forEach(title => {
        if (!title.dataset.listenerAttached) {
            title.addEventListener('click', () => {
                const grid = title.parentElement?.querySelector('.players-grid');
                if (grid) {
                    const isCollapsing = !title.classList.contains('collapsed');
                    title.classList.toggle('collapsed', isCollapsing);
                    grid.classList.toggle('collapsed', isCollapsing);
                    updateToggleButtonState();
                }
            });
            title.dataset.listenerAttached = 'true';
        }
    });

    toggleAllSections(true);
}

/**
 * Updates the market countdown timer and popup.
 */
async function initializeMarketCountdown() {
    const container = document.getElementById('countdown-container');
    const labelEl = document.getElementById('countdown-label');
    const timerEl = document.getElementById('countdown-timer');
    const schedulesListEl = document.getElementById('upcomingSchedulesList');

    if (countdownInterval) clearInterval(countdownInterval);

    try {
        const schedulesRef = collection(db, 'paineis', 'Banca', 'horarioMercado');
        const snapshot = await getDocs(schedulesRef);

        if (snapshot.empty) {
            container.style.display = 'none';
            return;
        }

        const agora = new Date();
        const futureWindows = [];
        let currentWindow = null;

        snapshot.forEach(doc => {
            const schedule = doc.data();
            const abertura = schedule.abertura.toDate();
            const fechamento = schedule.fechamento.toDate();

            if (agora >= abertura && agora <= fechamento) {
                currentWindow = schedule;
            } else if (abertura > agora) {
                futureWindows.push(schedule);
            }
        });

        futureWindows.sort((a, b) => a.abertura.toDate() - b.abertura.toDate());

      if (futureWindows.length > 0) {
            // Opções para formatar a data e hora para "DD/MM/AAAA HH:MM"
            const dateFormatOptions = {
                day: '2-digit', 
                month: '2-digit', 
                year: 'numeric',
                hour: '2-digit', 
                minute: '2-digit' 
            };

            schedulesListEl.innerHTML = futureWindows.map(win => {
                // Formata as datas de abertura e fechamento
                const aberturaFormatada = win.abertura.toDate().toLocaleString('pt-PT', dateFormatOptions);
                const fechamentoFormatado = win.fechamento.toDate().toLocaleString('pt-PT', dateFormatOptions);
                
                // Pega a descrição do campo 'observacoes' e capitaliza a primeira letra
                const tituloMercado = win.observacoes.charAt(0).toUpperCase() + win.observacoes.slice(1);

                return `
                    <div class="schedule-item">
                        <p style="font-size: 16px; font-weight: bold; color: #2176ff; margin-bottom: 8px;">
                           Mercado: ${tituloMercado}
                        </p>
                        <p><strong>Abre:</strong> ${aberturaFormatada.replace(',', ' às')}</p>
                        <p><strong>Fecha:</strong> ${fechamentoFormatado.replace(',', ' às')}</p>
                    </div>
                `;
            }).join('');
        } else {
            schedulesListEl.innerHTML = '<p>Não há mais janelas de mercado agendadas.</p>';
        }

        if (currentWindow) {
            labelEl.textContent = 'O Mercado está:';
            timerEl.textContent = 'ABERTO';
            timerEl.classList.add('open');
            container.style.display = 'flex';
        } else if (futureWindows.length > 0) {
            const nextMarket = futureWindows[0];
            labelEl.textContent = 'Próximo Mercado Abre Em:';
            timerEl.classList.remove('open');
            container.style.display = 'flex';

            countdownInterval = setInterval(() => {
                const now = new Date().getTime();
                const distance = nextMarket.abertura.toDate().getTime() - now;

                if (distance < 0) {
                    clearInterval(countdownInterval);
                    timerEl.textContent = 'ABRINDO...';
                    setTimeout(initializeMarketCountdown, 2000);
                    return;
                }

                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                timerEl.textContent =
                    `${String(days).padStart(2, '0')}:${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            }, 1000);
        } else {
            container.style.display = 'none';
        }

    } catch (error) {
        console.error("Erro ao inicializar o cronómetro do mercado:", error);
        container.style.display = 'none';
    }
}

// --- Loading Progress ---
let loadingProgress = 0;
const loadingPercentageElement = document.querySelector('.loading-percentage');
const progressBar = document.querySelector('.progress-bar');
let hideLoadingTimerId = null;

/**
 * Updates loading progress, hides screen after delay at 100%.
 */
function updateLoadingProgress(increment = 0, absoluteValue = null) {
    if (typeof hideLoadingTimerId === 'number' && loadingProgress >= 100) return;

    if (absoluteValue !== null) loadingProgress = absoluteValue;
    else loadingProgress += increment;
    loadingProgress = Math.max(0, Math.min(100, loadingProgress));

    const displayPercentage = Math.floor(loadingProgress);
    if (loadingPercentageElement) loadingPercentageElement.textContent = `${displayPercentage}%`;
    if (progressBar) progressBar.style.width = `${loadingProgress}%`;

    if (loadingProgress >= 100 && typeof hideLoadingTimerId !== 'number') {
        hideLoadingTimerId = window.setTimeout(() => {
            if (loadingScreen) loadingScreen.style.display = 'none';
            if (content) content.style.display = 'block';
        }, 1500);
    }
}


// --- Menu Management ---

/**
 * Loads menu visibility settings from Firestore.
 */
async function loadMenuSettings() {
    try {
        const menuSettingsDocRef = doc(db, 'paineis', 'paineis menu');
        const docSnap = await getDoc(menuSettingsDocRef);
        if (docSnap.exists()) return docSnap.data();
        console.warn("Menu settings document ('paineis/paineis menu') not found.");
        return null;
    } catch (error) {
        console.error('Erro ao carregar configurações do menu:', error);
        return null;
    }
}

/**
 * Checks page access based on status and menu settings. Redirects if denied.
 */
function checkPageAccess(userEstatuto, menuSettings) {
    const marketSetting = menuSettings?.market || 'off';
    if (marketSetting !== 'on' && userEstatuto !== 'ruler') {
        if (loadingScreen) loadingScreen.style.display = 'none';
        window.location.href = '404.html';
        return false;
    }
    return true;
}

/**
 * Updates the player counts in the section titles.
 */
function updateSectionCounts() {
    const sections = {
        'guarda-redes-section': 'GUARDA-REDES',
        'defesas-section': 'DEFESAS',
        'medios-section': 'MÉDIOS',
        'avancados-section': 'AVANÇADOS'
    };

    for (const [sectionId, baseTitle] of Object.entries(sections)) {
        const sectionElement = document.getElementById(sectionId);
        if (sectionElement) {
            const titleElement = sectionElement.querySelector('.section-title');
            const gridElement = sectionElement.querySelector('.players-grid');

            if (titleElement && gridElement) {
                const count = gridElement.querySelectorAll('.player-card').length;
                titleElement.textContent = `${baseTitle} (${count})`;
            }
        }
    }
}

/**
 * Updates visibility of menu items based on settings.
 */
function updateMenuVisibility(menuSettings) {
    if (!menuSettings) {
        console.warn("Cannot update menu visibility, settings missing.");
        return;
    }

    const menuItemsMap = {
        '1x': document.getElementById('menu-item-1x'),
        'bank': document.getElementById('transaction-button-link'),
        'empire': document.getElementById('menu-item-empire'),
        'market': document.getElementById('menu-item-market'),
        'profile': document.getElementById('menu-item-profile'),
        'rankings': document.getElementById('menu-item-rankings'),
        'team': document.getElementById('menu-item-team')
    };

    for (const [key, element] of Object.entries(menuItemsMap)) {
        if (element) {
            const isOff = menuSettings.hasOwnProperty(key) && menuSettings[key] === 'off';
            element.style.display = isOff ? 'none' : '';

            if (!isOff) {
                if (key === 'bank' || element.classList.contains('menu-item')) {
                    element.style.display = 'flex';
                }
            }
        } else {
            console.warn(`Menu element for key '${key}' not found.`);
        }
    }

    const bottomMenu = document.querySelector('.bottom-menu');
    if (bottomMenu) {
        const visibleMenuItems = bottomMenu.querySelectorAll('.menu-item:not([style*="display: none"])');
        bottomMenu.style.justifyContent = (visibleMenuItems.length <= 4) ? 'space-around' : 'center';
    }
}

// --- Initialization and Auth Handling ---

onAuthStateChanged(auth, async (user) => {
    try {
        if (user) {
            updateLoadingProgress(10);
            currentUserEstatuto = await getUserEstatuto(user.uid);
            updateLoadingProgress(10);

            try {
                const userDocRef = doc(db, 'users', user.uid);
                await updateDoc(userDocRef, {
                    ultimoacesso: serverTimestamp()
                });
            } catch (error) {
                console.error("Erro ao atualizar o campo ultimoacesso: ", error);
            }

            if (currentUserEstatuto !== null) {
                const menuSettings = await loadMenuSettings();
                updateLoadingProgress(10);

                if (!checkPageAccess(currentUserEstatuto, menuSettings)) return;
                updateLoadingProgress(10);

                const transactionButton = document.getElementById('transaction-button-link');
                if (transactionButton && menuSettings?.bank === 'off') {
                    transactionButton.style.display = 'none';
                }

                if (window.updateMenuVisibility) {
                    window.updateMenuVisibility(menuSettings);
                }

                initializeMarketCountdown();

                await loadPlayers();

            } else {
                if (loadingScreen) loadingScreen.style.display = 'none';
                window.location.href = '404.html';
                return;
            }
        } else {
            if (loadingScreen) loadingScreen.style.display = 'none';
            window.location.href = '404.html';
            return;
        }
        updateLoadingProgress(0, 100);

    } catch (error) {
        console.error("Erro crítico durante o carregamento inicial:", error);
        if (loadingScreen) loadingScreen.style.display = 'none';
        alert("Ocorreu um erro grave ao carregar a página.");
        window.location.href = '404.html';
    }
});

// --- Event Listeners Setup ---

document.addEventListener('DOMContentLoaded', () => {
    // Player popup logic
    const popup = document.getElementById('playerPopup');
    const exitButton = document.getElementById('popupExitButton');

    const closePopup = () => {
        if (popup) {
            popup.classList.remove('active');
            const unsubscribeFunc = popup.dataset.unsubscribePopupListener;
            if (unsubscribeFunc && typeof unsubscribeFunc === 'function') {
                try {
                    unsubscribeFunc();
                } catch (e) {
                    console.error("Error detaching listener on close:", e);
                }
            }
            delete popup.dataset.unsubscribePopupListener;
            clearPopupMessages();
        }
    };

    if (exitButton) exitButton.addEventListener('click', closePopup);
    if (popup) popup.addEventListener('click', (e) => {
        if (e.target === popup) closePopup();
    });

    // Schedules popup logic
    const countdownContainer = document.getElementById('countdown-container');
    const schedulesPopup = document.getElementById('schedulesPopup');
    const closeSchedulesPopup = document.getElementById('closeSchedulesPopup');

    countdownContainer.addEventListener('click', () => {
        schedulesPopup.classList.add('active');
    });

    closeSchedulesPopup.addEventListener('click', () => {
        schedulesPopup.classList.remove('active');
    });

    schedulesPopup.addEventListener('click', (e) => {
        if (e.target === schedulesPopup) {
            schedulesPopup.classList.remove('active');
        }
    });
});

window.addEventListener('beforeunload', () => {
    document.querySelectorAll('.player-card[data-unsubscribe-card-listener]').forEach(card => {
        const unsubscribeCardFunc = card.dataset.unsubscribeCardListener;
        if (unsubscribeCardFunc && typeof unsubscribeCardFunc === 'function') {
            try {
                unsubscribeCardFunc();
            } catch (e) { /* ignore */ }
        }
        delete card.dataset.unsubscribeCardListener;
    });

    const popup = document.getElementById('playerPopup');
    if (popup?.dataset?.unsubscribePopupListener) {
        const unsubscribePopupFunc = popup.dataset.unsubscribePopupListener;
        if (unsubscribePopupFunc && typeof unsubscribePopupFunc === 'function') {
            try {
                unsubscribePopupFunc();
            } catch (e) { /* ignore */ }
        }
        delete popup.dataset.unsubscribePopupListener;
    }
});
    </script>
<script src="menu-component.js"></script> 
</body>
</html>
