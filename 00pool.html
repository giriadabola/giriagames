<!DOCTYPE html>
<html lang="pt">
<head>
  <meta charset="UTF-8">
  <title>Confirmação de Disponibilidade</title>
  <style>
    /* --- CSS Completo AJUSTADO para UMA COLUNA --- */
    * { box-sizing: border-box; }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background: linear-gradient(to right, #e0eafc, #cfdef3);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-bottom: 40px;
    }

    header {
      background: #2d89ef;
      color: white;
      width: 100%;
      padding: 20px 0;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    h1 { margin: 0; font-size: 2em; font-weight: 600; }

    /* Containers */
    #selecao-container, #cards-container {
      margin-top: 40px; width: 100%; max-width: 900px; padding: 0 20px;
      display: flex; flex-direction: column; align-items: center;
    }
    #cards-container { align-items: flex-start; }

    /* Seleção de Nome */
    #selecao-container h2 { color: #333; margin-bottom: 15px; }
    select#nomeSelect { padding: 12px 15px; border-radius: 8px; border: 1px solid #ccc; font-size: 1em; margin-bottom: 20px; width: 100%; max-width: 350px; background-color: white; cursor: pointer; }
    select#nomeSelect:disabled { background-color: #e9ecef; cursor: not-allowed; }

    /* Grupo Semana */
    .grupo-semana { margin-bottom: 40px; width: 100%; }
    .semana-titulo { font-size: 1.2em; font-weight: 600; margin-bottom: 20px; color: #1a4a7a; border-bottom: 2px solid #a0c4f0; padding-bottom: 8px; text-align: left; }

    /* Grid Principal da Semana - ALTERADO */
    .cards-grid {
      display: grid;
      /* --- FORÇA UMA ÚNICA COLUNA --- */
      grid-template-columns: 1fr;
      gap: 25px; /* Espaço vertical entre os dias/grupos de dia */
    }

    /* Agrupador de Cards do Mesmo Dia */
    .dia-agrupado {
      display: flex; /* Mantém flex para alinhar cards internos lado a lado */
      flex-wrap: wrap; /* Permite quebrar linha DENTRO do dia se necessário (telas estreitas) */
      gap: 15px; /* Espaço ENTRE os cards no mesmo dia */
      width: 100%; /* Ocupa a largura da coluna única do grid */
      /* Opcional: Estilos visuais para o grupo */
      /* border: 1px dashed #a0c4f0; */
      /* padding: 10px; */
      /* border-radius: 12px; */
      /* background-color: rgba(255, 255, 255, 0.3); */
    }

    /* Cards Dentro do Agrupador Diário */
    .dia-agrupado > .card {
       flex: 1 1 auto; /* Permite crescer/encolher */
       min-width: 0; /* Permite encolher abaixo do conteúdo */
       /* Definir uma base talvez? Ou deixar auto? Testar. */
       /* flex-basis: 250px; */
       /* Outros estilos do card */
       background: white; border-radius: 16px; padding: 20px; /* Padding menor pode ajudar */
       box-shadow: 0 4px 10px rgba(45, 137, 239, 0.1);
       border: 2px solid transparent; position: relative;
       display: flex; flex-direction: column; align-items: center; text-align: center;
       transition: transform 0.25s ease, box-shadow 0.25s ease, background-color 0.3s ease;
       margin: 0; /* Remover margens */
    }
    /* Ajustes opcionais no conteúdo DENTRO do card agrupado */
    .dia-agrupado > .card .dia-semana { font-size: 1.4em; margin-bottom: 15px;}
    .dia-agrupado > .card .data-pequena { font-size: 0.8em; margin-bottom: 5px;}
    .dia-agrupado > .card .btn-confirmar { padding: 10px 15px; font-size: 0.9em;}


    /* Estilo do Card Individual (dias com 1 evento) */
    .cards-grid > .card { /* Seletor mais específico */
       /* Estilos originais */
       background: white; border-radius: 16px; padding: 25px;
       box-shadow: 0 8px 20px rgba(45, 137, 239, 0.15);
       display: flex; flex-direction: column; align-items: center; text-align: center;
       transition: transform 0.25s ease, box-shadow 0.25s ease, background-color 0.3s ease;
       border: 2px solid transparent; position: relative;
    }

    /* Resto dos estilos (card:hover, card.confirmado, conteúdo, botões, etc.) */
     .card:hover { transform: translateY(-5px); box-shadow: 0 12px 25px rgba(45, 137, 239, 0.2); }
     .card.confirmado { background-color: #e0f8e7; border: 2px solid #28a745; }
     .card.confirmado .dia-semana { color: #1c7430; }
     .card.confirmado .btn-confirmar { background-color: #6c757d; cursor: pointer; opacity: 0.9; }
     .card.confirmado .btn-confirmar:hover { background-color: #5a6268; }
     .data-pequena { font-size: 0.9em; color: #555; margin-bottom: 8px; }
     .dia-semana { font-size: 1.6em; font-weight: bold; margin-bottom: 25px; color: #2d89ef; text-transform: capitalize; }
     .btn-confirmar, .btn-continuar, .btn-voltar { padding: 12px 25px; background: #2d89ef; color: white; border: none; border-radius: 10px; font-size: 1em; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease, opacity 0.2s ease; margin-top: auto; }
     .btn-confirmar:hover, .btn-continuar:hover, .btn-voltar:hover { background-color: #1b5dbf; }
     .btn-confirmar:active, .btn-continuar:active, .btn-voltar:active { transform: scale(0.98); }
     .btn-confirmar:disabled { cursor: not-allowed; opacity: 0.6; }
     .btn-voltar { background-color: #6c757d; margin-bottom: 30px; align-self: flex-start; }
     .btn-voltar:hover { background-color: #5a6268; }
     #boasVindas { width: 100%; text-align: left; font-size: 1.5em; color: #333; margin-bottom: 30px; }
     .hidden { display: none !important; }
     .emoji-burst { position: absolute; font-size: 24px; pointer-events: none; z-index: 1000; }
     .loading-spinner { position: absolute; top: 10px; right: 10px; width: 20px; height: 20px; border: 3px solid rgba(45, 137, 239, 0.3); border-radius: 50%; border-top-color: #2d89ef; animation: spin 1s ease-in-out infinite; z-index: 5; }
     @keyframes spin { to { transform: rotate(360deg); } }
    /* --- Fim do CSS --- */
  </style>
</head>
<body>

<header>
  <h1>Confirme sua disponibilidade</h1>
</header>

<!-- Seleção de nome -->
<div id="selecao-container">
  <h2>Escolha seu nome:</h2>
  <select id="nomeSelect" disabled>
    <option value="">-- Carregando nomes... --</option>
  </select>
  <br>
  <button class="btn-continuar" onclick="continuar()">Continuar</button>
</div>

<!-- Cards de disponibilidade -->
<div id="cards-container" class="hidden">
  <button class="btn-voltar" onclick="voltar()">⬅️ Trocar nome</button>
  <h2 id="boasVindas"></h2>
  <div id="cards-grupos">
    <!-- Grupos de semanas e cards/grupos de dias serão carregados aqui via JS -->
  </div>
</div>

<!-- Add Firebase SDKs using Modules -->
<script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getFirestore, collection, addDoc, serverTimestamp, query, where, getDocs, limit, deleteDoc, doc } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

  // Your web app's Firebase configuration (MAKE SURE THESE ARE YOUR REAL VALUES!)
  const firebaseConfig = {
    apiKey: "AIzaSyCxUQTIg1cebw6FSzIH2w05ETgi9sj6dcU",
  authDomain: "daytime-a0fa5.firebaseapp.com",
  projectId: "daytime-a0fa5",
  storageBucket: "daytime-a0fa5.firebasestorage.app",
  messagingSenderId: "217848316066",
  appId: "1:217848316066:web:fad68b3fd59ece761997fb"
  };

  // Initialize Firebase
  let app;
  let db;
  try {
      app = initializeApp(firebaseConfig);
      db = getFirestore(app);
      console.log("Firebase initialized successfully.");
  } catch (error) {
      console.error("Firebase initialization failed:", error);
      alert("Erro ao conectar com a base de dados. A funcionalidade pode não funcionar.");
      // Disable UI elements if needed
      const nomeSelect = document.getElementById("nomeSelect");
      if(nomeSelect) { nomeSelect.innerHTML = '<option value="">-- Erro --</option>'; nomeSelect.disabled = true; }
      const continuarBtn = document.querySelector(".btn-continuar");
      if(continuarBtn) continuarBtn.disabled = true;
  }

  // --- Global Variables ---
  let usuarioAtual = "";
  let userConfirmations = new Set(); // Cache APENAS para o estado VISUAL da SESSÃO ATUAL (keys são dataOriginal 'YYYY-MM-DD')
  let availableEventos = []; // Cache dos eventos disponíveis (objetos processados)


  // --- Date Formatting and Grouping Helpers ---
   function processEventDateData(eventoDataFromFirestore) {
      if (!eventoDataFromFirestore || !eventoDataFromFirestore.dataOriginal) {
          console.error("Invalid event data received:", eventoDataFromFirestore);
          return null;
      }
      const dataStr = eventoDataFromFirestore.dataOriginal;
      const parts = dataStr.split('-');
      if (parts.length !== 3) {
          console.error("Invalid dataOriginal format:", dataStr);
          return null;
      }
       try {
          const dateObjectUTC = new Date(Date.UTC(parts[0], parts[1] - 1, parts[2]));
          const optionsDataExtenso = { day: 'numeric', month: 'long', year: 'numeric', timeZone: 'UTC' };
          const dataExtenso = dateObjectUTC.toLocaleDateString('pt-PT', optionsDataExtenso);
          // Return object includes ALL original fields plus derived ones
          return {
              ...eventoDataFromFirestore, // Inclui ano, dia, mes, diasemana, horario, etc.
              data: dateObjectUTC,
              dataExtenso: dataExtenso
          };
      } catch (e) {
          console.error(`Error processing date string ${dataStr}:`, e);
          return null;
      }
   }

  function getSemanaRange(data) { // Expects a Date object (UTC)
    if (!(data instanceof Date) || isNaN(data)) {
        console.error("getSemanaRange received invalid Date:", data);
        return { display: "Semana inválida", key: "invalid-" + Date.now() };
    }
    const diaDaSemana = data.getUTCDay();
    const diffParaSegunda = diaDaSemana === 0 ? -6 : 1 - diaDaSemana;
    const inicioSemana = new Date(data);
    inicioSemana.setUTCDate(data.getUTCDate() + diffParaSegunda);
    const fimSemana = new Date(inicioSemana);
    fimSemana.setUTCDate(inicioSemana.getUTCDate() + 6);
    const inicioDia = inicioSemana.getUTCDate();
    const fimDia = fimSemana.getUTCDate();
    const mesInicio = inicioSemana.toLocaleDateString('pt-PT', { month: 'long', timeZone: 'UTC' });
    const mesFim = fimSemana.toLocaleDateString('pt-PT', { month: 'long', timeZone: 'UTC' });
    const anoInicio = inicioSemana.getUTCFullYear();
    const anoFim = fimSemana.getUTCFullYear();
    let rangeStr = `Semana de ${inicioDia}`;
    if (mesInicio !== mesFim) rangeStr += ` de ${mesInicio}`;
    if (anoInicio !== anoFim) rangeStr += ` de ${anoInicio}`;
    rangeStr += ` a ${fimDia} de ${mesFim}`;
    if (anoInicio === anoFim || mesInicio !== mesFim) rangeStr += ` de ${anoFim}`;
    const sortKey = `${anoInicio}-${String(inicioSemana.getUTCMonth() + 1).padStart(2, '0')}-${String(inicioDia).padStart(2, '0')}`;
    return { display: rangeStr, key: sortKey };
  }

  // --- Fetch EVENT DATES from Firestore and Filter ---
  async function fetchAndFilterEventosData() {
      if (!db) {
          console.error("[fetchEventosData] Firestore DB not initialized.");
          return [];
      }
      console.log("[fetchEventosData] Fetching event dates from 'eventosData'...");
      availableEventos = [];

      const today = new Date();
      const todayMidnightUTC = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
      console.log(`[fetchEventosData] Comparing against date (UTC midnight): ${todayMidnightUTC.toISOString()}`);

      try {
          const eventosCol = collection(db, "eventosData");
          const querySnapshot = await getDocs(eventosCol);
          console.log(`[fetchEventosData] Found ${querySnapshot.size} total documents in 'eventosData'.`);

          const fetchedEventos = [];
          querySnapshot.forEach((doc) => {
              const firestoreData = doc.data();
              const processedData = processEventDateData(firestoreData);

              if (processedData && processedData.data) {
                  if (processedData.data >= todayMidnightUTC) {
                      console.log(`[fetchEventosData] Including event: ${processedData.dataOriginal}`);
                      fetchedEventos.push(processedData);
                  } else {
                      console.log(`[fetchEventosData] Excluding past event: ${processedData.dataOriginal}`);
                  }
              } else {
                  console.warn(`[fetchEventosData] Skipping document ${doc.id} due to processing error or invalid date.`);
              }
          });

          fetchedEventos.sort((a, b) => a.data - b.data);
          availableEventos = fetchedEventos;
          console.log(`[fetchEventosData] Finished. ${availableEventos.length} valid future/present events found and cached.`);

      } catch (error) {
          console.error("[fetchEventosData] ERROR fetching event dates:", error);
          alert("Erro ao carregar as datas dos eventos. Verifique a console e as regras do Firestore.");
          availableEventos = [];
      }
      return availableEventos;
  }


  // --- CORE APPLICATION LOGIC ---

  // Fetch Names from Firestore
  async function preencherDropdown() {
      const select = document.getElementById("nomeSelect");
      select.innerHTML = '<option value="">-- Carregando nomes... --</option>';
      select.disabled = true;
      console.log("[preencherDropdown] Starting.");
      if (!db) { console.error("[preencherDropdown] Firestore DB not initialized."); select.innerHTML = '<option value="">-- Erro DB --</option>'; return; }
      console.log("[preencherDropdown] DB available. Fetching 'pessoas'...");
      try {
          const pessoasCol = collection(db, "pessoas");
          const querySnapshot = await getDocs(pessoasCol);
          console.log(`[preencherDropdown] Found ${querySnapshot.size} docs in 'pessoas'.`);
          const nomes = [];
          querySnapshot.forEach((doc) => {
              if (doc.data() && typeof doc.data().nome === 'string' && doc.data().nome.trim() !== '') {
                   nomes.push(doc.data().nome.trim());
              } else { console.warn(`[preencherDropdown] Doc ${doc.id} missing valid 'nome' field.`); }
          });
          console.log(`[preencherDropdown] Found ${nomes.length} valid names.`);
          nomes.sort((a, b) => a.localeCompare(b));
          select.innerHTML = '<option value="">-- Selecione seu nome --</option>';
          if (nomes.length > 0) {
              nomes.forEach(nome => { const opt = document.createElement("option"); opt.value = nome; opt.textContent = nome; select.appendChild(opt); });
              select.disabled = false; console.log("[preencherDropdown] Dropdown populated and enabled.");
          } else { console.warn("[preencherDropdown] No names found."); select.innerHTML = '<option value="">-- Nenhum nome --</option>'; }
      } catch (error) { console.error("[preencherDropdown] ERROR fetching names:", error); select.innerHTML = '<option value="">-- Erro --</option>'; alert("Erro ao carregar nomes."); }
      finally { console.log("[preencherDropdown] Finished."); }
  }

  async function continuar() {
    const nome = document.getElementById("nomeSelect").value;
    if (!nome) { alert("Por favor, selecione seu nome."); return; }
    if (!db) { alert("Erro de conexão com a base de dados."); return; }

    usuarioAtual = nome;
    userConfirmations.clear(); // Clear visual session cache

    document.getElementById("selecao-container").classList.add("hidden");
    document.getElementById("cards-container").classList.remove("hidden");
    document.getElementById("boasVindas").textContent = `Olá, ${nome}! Carregando datas...`;
    document.getElementById("cards-grupos").innerHTML = '<div style="text-align:center; padding: 20px;">A carregar datas...</div>';

    // REMOVED loadUserConfirmations() call here
    const eventosParaMostrar = await fetchAndFilterEventosData(); // Get events

    document.getElementById("boasVindas").textContent = `Olá, ${nome}! Selecione os dias que você está disponível:`;
    if (eventosParaMostrar.length > 0) {
        // Render cards with empty session confirmations (all start unchecked)
        renderCardsAgrupados(eventosParaMostrar);
    } else {
        document.getElementById("cards-grupos").innerHTML = '<div style="text-align:center; padding: 20px;">Não há datas futuras disponíveis para confirmação no momento.</div>';
        console.log("No future/present events found to display.");
    }
  }

  function voltar() {
    usuarioAtual = "";
    userConfirmations.clear(); // Clear visual session cache
    availableEventos = []; // Clear event cache

    document.getElementById("cards-container").classList.add("hidden");
    document.getElementById("selecao-container").classList.remove("hidden");

    document.getElementById("nomeSelect").value = "";
    document.getElementById("cards-grupos").innerHTML = "";
  }

  // --- Helper function to create a single card element ---
  function createCardElement(ev) {
      // Verifica o cache da SESSÃO para o estado visual inicial
      const confirmado = userConfirmations.has(ev.dataOriginal);
      const card = document.createElement("div");
      card.className = "card";
      if (confirmado) {
          card.classList.add("confirmado");
      }

      const dataPequenaDiv = document.createElement("div");
      dataPequenaDiv.className = "data-pequena";
      dataPequenaDiv.textContent = ev.dataExtenso;

      const diaSemanaDiv = document.createElement("div");
      diaSemanaDiv.className = "dia-semana";
      if (ev.horario && ev.horario.trim() !== '') {
          diaSemanaDiv.textContent = `${ev.diasemana} | ${ev.horario}`; // Combina dia e horário
      } else {
          diaSemanaDiv.textContent = ev.diasemana; // Mostra só o dia
      }

      const btnConfirmar = document.createElement("button");
      btnConfirmar.className = "btn-confirmar";
      btnConfirmar.textContent = confirmado ? "Confirmado!" : "Eu posso";
      btnConfirmar.onclick = () => confirmar(ev, btnConfirmar); // Passa o evento completo

      card.appendChild(dataPequenaDiv);
      card.appendChild(diaSemanaDiv);
      card.appendChild(btnConfirmar);
      return card; // Retorna o elemento card criado
  }


  // --- Rendering Logic (Groups cards by day for layout) ---
  function renderCardsAgrupados(eventos) {
      const container = document.getElementById("cards-grupos");
      container.innerHTML = "";
      console.log(`[renderCardsAgrupados] Rendering ${eventos.length} events. Session confirmations:`, Array.from(userConfirmations));

      if (eventos.length === 0) {
           container.innerHTML = '<div style="text-align:center; padding: 20px;">Não há datas futuras disponíveis.</div>';
           return;
      }

      // 1. Agrupar eventos por Semana
      const gruposPorSemana = {};
      eventos.forEach(ev => {
          if (!ev || !ev.data) { console.warn("Skipping invalid event object during week grouping:", ev); return; }
          try {
              const semanaInfo = getSemanaRange(ev.data);
              if (!gruposPorSemana[semanaInfo.key]) {
                  gruposPorSemana[semanaInfo.key] = { display: semanaInfo.display, eventos: [] };
              }
              gruposPorSemana[semanaInfo.key].eventos.push(ev);
          } catch (e) {
              console.error(`Error processing event for week grouping: ${ev.dataOriginal}`, e);
          }
      });

      const semanasOrdenadas = Object.keys(gruposPorSemana).sort();

      // 2. Iterar por cada Semana
      semanasOrdenadas.forEach(semanaKey => {
          const semanaGrupo = gruposPorSemana[semanaKey];
          const grupoDiv = document.createElement("div");
          grupoDiv.className = "grupo-semana";

          const titulo = document.createElement("div");
          titulo.className = "semana-titulo";
          titulo.textContent = semanaGrupo.display;
          grupoDiv.appendChild(titulo);

          // Cria o grid principal para esta semana
          const gridSemana = document.createElement("div");
          gridSemana.className = "cards-grid"; // O grid que contém os cards ou os wrappers de dia

          // 3. Agrupar eventos por Dia DENTRO da semana atual
          const eventosPorDiaNaSemana = {};
          semanaGrupo.eventos.forEach(ev => {
              const diaKey = ev.dataOriginal; // Usa 'YYYY-MM-DD' como chave do dia
              if (!eventosPorDiaNaSemana[diaKey]) {
                  eventosPorDiaNaSemana[diaKey] = [];
              }
              eventosPorDiaNaSemana[diaKey].push(ev);
          });

          // 4. Iterar pelos Dias (já ordenados por dataOriginal porque eventos estavam ordenados)
          const diasOrdenadosNaSemana = Object.keys(eventosPorDiaNaSemana);

          diasOrdenadosNaSemana.forEach(dataDia => {
              const eventosDoDia = eventosPorDiaNaSemana[dataDia];

              if (eventosDoDia.length === 1) {
                  // --- Se há SÓ UM evento neste dia ---
                  const ev = eventosDoDia[0];
                  const cardElement = createCardElement(ev); // Cria o card
                  gridSemana.appendChild(cardElement); // Adiciona diretamente ao grid da semana
              } else if (eventosDoDia.length > 1) {
                  // --- Se há MAIS DE UM evento neste dia ---
                  console.log(`[renderCardsAgrupados] Found ${eventosDoDia.length} events for day ${dataDia}. Grouping them.`);
                  // Cria o wrapper flex para este dia
                  const diaAgrupadoWrapper = document.createElement("div");
                  diaAgrupadoWrapper.className = "dia-agrupado"; // CSS aplicará display: flex

                  // Cria cada card e adiciona AO WRAPPER
                  eventosDoDia.forEach(ev => {
                      const cardElement = createCardElement(ev);
                      diaAgrupadoWrapper.appendChild(cardElement);
                  });

                  // Adiciona o WRAPPER (que contém os cards do dia) ao grid da semana
                  gridSemana.appendChild(diaAgrupadoWrapper);
              }
          }); // Fim loop dias na semana

          grupoDiv.appendChild(gridSemana); // Adiciona grid da semana ao grupo da semana
          container.appendChild(grupoDiv); // Adiciona grupo da semana ao container principal
      }); // Fim loop semanas

      console.log("[renderCardsAgrupados] Finished rendering.");
  } // Fim de renderCardsAgrupados


  // --- Find and Delete Confirmation (Deletes specific Nome+Data+Horario) ---
  async function deleteConfirmation(dataOriginal, horario = null) {
      if (!usuarioAtual || !dataOriginal || !db) { console.error("deleteConfirmation missing data"); return false; }

      console.log(`[deleteConfirmation] Attempting deletion for ${usuarioAtual} on ${dataOriginal} ${horario !== undefined ? `at ${horario}` : '(specific horario REQUIRED)'}...`);

      // **Horário é OBRIGATÓRIO para apagar uma entrada específica**
      // Se horário for undefined ou null aqui, não sabemos qual apagar se houver múltiplos no dia.
      // A lógica atual em 'confirmar' SEMPRE passa o horário.
      // Esta verificação é uma segurança extra.
      if (horario === undefined) {
          console.error("[deleteConfirmation] Horario is required to delete a specific entry. Aborting.");
           alert("Erro interno: Não foi possível identificar qual horário remover.");
          return false;
      }

      // Constrói a query para o documento exato
      const q = query(
          collection(db, "disponibilidade"),
          where("nome", "==", usuarioAtual),
          where("dataOriginal", "==", dataOriginal),
          where("horario", "==", horario), // Usa o horário específico
          limit(1) // Deve haver apenas um
      );

      try {
          const querySnapshot = await getDocs(q);
          if (querySnapshot.empty) {
              console.warn(`[deleteConfirmation] No specific document found for ${dataOriginal} at ${horario}. Assuming already deleted.`);
              return true; // Se não encontrou nada para apagar, considera sucesso
          }

          // Apaga o único documento encontrado
          const docToDelete = querySnapshot.docs[0];
          console.log(`[deleteConfirmation] Preparing to delete specific document ${docToDelete.id}.`);
          await deleteDoc(doc(db, "disponibilidade", docToDelete.id));

          console.log(`[deleteConfirmation] Document ${docToDelete.id} deleted successfully for ${dataOriginal} at ${horario}.`);
          return true; // Indica sucesso

      } catch (error) {
          console.error(`[deleteConfirmation] Error deleting document for ${dataOriginal} at ${horario}:`, error);
          alert(`Erro ao remover confirmação para ${dataOriginal} (${horario}).`);
          return false; // Indica falha
      }
  } // Fim de deleteConfirmation


  // --- Check Cache Helper (Opcional, dependendo da lógica visual desejada ao remover) ---
  // Esta função verifica se *ainda* há alguma confirmação no DB para a data,
  // e atualiza o cache visual (userConfirmations) de acordo.
  async function checkAndUpdateSessionCache(dataOriginal) {
      if (!usuarioAtual || !dataOriginal || !db) return;
      console.log(`[checkCache] Checking DB if other confirmations exist for ${usuarioAtual} on ${dataOriginal}...`);
      const q = query( collection(db, "disponibilidade"), where("nome", "==", usuarioAtual), where("dataOriginal", "==", dataOriginal), limit(1) );
      try {
          const querySnapshot = await getDocs(q);
          if (querySnapshot.empty) {
              console.log(`[checkCache] No confirmations remain for ${dataOriginal}. Removing from session cache.`);
              userConfirmations.delete(dataOriginal); // Remove da cache visual da sessão
          } else {
              console.log(`[checkCache] Other confirmations still exist for ${dataOriginal}. Keeping in session cache.`);
              userConfirmations.add(dataOriginal); // Garante que está na cache visual da sessão
          }
      } catch (error) {
          console.error(`[checkCache] Error checking remaining confirmations for ${dataOriginal}:`, error);
          userConfirmations.add(dataOriginal); // Segurança: mantém no cache se der erro
      }
  }


  // --- Confirmation Logic (Revised - Checks Firestore state first) ---
  async function confirmar(eventoData, button) {
    if (!db) { console.error("DB not available."); alert("Erro conexão."); return; }
    const card = button.closest('.card');
    const dataOriginal = eventoData.dataOriginal;
    const horarioEvento = eventoData.horario || null; // Use null if undefined/empty
    if (!dataOriginal) { console.error("Missing dataOriginal"); alert("Erro data."); return; }
    if (button.disabled) { console.log("In progress"); return; }

    console.log(`[confirmar] Clicked on card for ${dataOriginal} / ${horarioEvento}.`);
    button.disabled = true;
    const spinner = document.createElement('div'); spinner.className = 'loading-spinner'; card.appendChild(spinner);

    let existsInFirestore = false;
    const checkQuery = query( collection(db, "disponibilidade"), where("nome", "==", usuarioAtual), where("dataOriginal", "==", dataOriginal), where("horario", "==", horarioEvento), limit(1) );

    try {
        console.log(`[confirmar] Checking Firestore for existing entry (nome+data+horario)...`);
        const existingDocsSnapshot = await getDocs(checkQuery);
        existsInFirestore = !existingDocsSnapshot.empty;
        console.log(`[confirmar] Entry for ${dataOriginal}/${horarioEvento} exists in Firestore: ${existsInFirestore}`);

        if (existsInFirestore) {
            // --- Caminho de REMOÇÃO ---
            button.textContent = 'A remover...';
            console.log(`[confirmar] Attempting deletion from Firestore...`);
            // **Passa o horário para garantir que apaga a entrada correta**
            const deleteSuccess = await deleteConfirmation(dataOriginal, horarioEvento);

            if (deleteSuccess) {
                // Opcional: Atualizar cache visual só se não houver mais nenhuma conf. para o dia
                // await checkAndUpdateSessionCache(dataOriginal);
                // Simples: Sempre remover do cache da sessão visual ao apagar
                 userConfirmations.delete(dataOriginal);

                // Atualiza UI para estado não confirmado
                card.classList.remove('confirmado');
                button.textContent = 'Eu posso';
                button.disabled = false;
                console.log(`[confirmar] Deletion successful for ${dataOriginal} / ${horarioEvento}.`);
            } else {
                button.textContent = 'Confirmado!'; // Reverte UI na falha
                button.disabled = false;
                console.error(`[confirmar] Deletion failed for ${dataOriginal} / ${horarioEvento}.`);
            }
        } else {
            // --- Caminho de ADIÇÃO ---
             button.textContent = 'A guardar...';
             console.log(`[confirmar] Attempting addition to Firestore...`);
             const dadosConfirmacao = {
                nome: usuarioAtual, ano: eventoData.ano, mes: eventoData.mes,
                semana: eventoData.semanaDisplay || getSemanaRange(eventoData.data).display, dia: eventoData.dia,
                diasemana: eventoData.diasemana, dataOriginal: dataOriginal, horario: horarioEvento,
                timestamp: serverTimestamp()
             };
             if (!dadosConfirmacao.nome || !dadosConfirmacao.ano || !dadosConfirmacao.mes || !dadosConfirmacao.semana || !dadosConfirmacao.dia || !dadosConfirmacao.diasemana || !dadosConfirmacao.dataOriginal) {
                 throw new Error("Missing required fields for saving confirmation.");
             }
             const docRef = await addDoc(collection(db, "disponibilidade"), dadosConfirmacao);
             console.log("[confirmar] Document written successfully with ID: ", docRef.id);

             // Atualiza cache da sessão visual e UI
             userConfirmations.add(dataOriginal); // Adiciona data ao cache visual
             card.classList.add('confirmado');
             button.textContent = "Confirmado!";
             button.disabled = false;
             triggerEmojiBurst(button);
             console.log(`[confirmar] Addition successful for ${dataOriginal} / ${horarioEvento}.`);
        }
    } catch (e) {
        console.error("[confirmar] !!!!! ERROR during Firestore operation !!!!! ", e);
        alert(`Erro ao processar confirmação para ${dataOriginal}. Tente novamente.\nDetalhes: ${e.message}`);
        button.disabled = false;
        button.textContent = existsInFirestore ? 'Confirmado!' : 'Eu posso'; // Tenta reverter texto
        console.error(`[confirmar] Operation failed for ${dataOriginal}.`);
    } finally {
        if(spinner) spinner.remove();
        console.log(`[confirmar] Finished processing click for ${dataOriginal}. Final session cache:`, Array.from(userConfirmations));
    }
  } // Fim da função confirmar


  // --- Visual Effects ---
  function triggerEmojiBurst(button) {
     if (!button || !document.body) return;
     const buttonRect = button.getBoundingClientRect();
     const startX = buttonRect.left + buttonRect.width / 2 + window.scrollX;
     const startY = buttonRect.top + buttonRect.height / 2 + window.scrollY;
     for (let i = 0; i < 15; i++) {
       const emoji = document.createElement('span'); emoji.textContent = '👍'; emoji.className = 'emoji-burst';
       emoji.style.left = `${startX}px`; emoji.style.top = `${startY}px`;
       document.body.appendChild(emoji);
       const angle = Math.random() * Math.PI * 2; const distance = 60 + Math.random() * 50;
       const duration = 700 + Math.random() * 300; const x = Math.cos(angle) * distance;
       const y = Math.sin(angle) * distance - distance * 0.5;
       const animation = emoji.animate([{ transform: `translate(0, 0) scale(1)`, opacity: 1 }, { transform: `translate(${x}px, ${y}px) scale(0.5)`, opacity: 0 }], { duration: duration, easing: 'cubic-bezier(0.1, 0.8, 0.7, 1.0)' });
       animation.finished.then(() => emoji.remove());
     }
   }


  // --- Expose functions ---
  window.continuar = continuar;
  window.voltar = voltar;

  // --- INITIALIZATION ---
  window.onload = async () => {
      console.log("[window.onload] Page loading...");
      console.log("[window.onload] Calling preencherDropdown()...");
      await preencherDropdown(); // Load names first
      console.log("[window.onload] preencherDropdown() finished.");
      const nomeSelect = document.getElementById('nomeSelect');
      if (nomeSelect && !nomeSelect.disabled) {
          console.log("[window.onload] Adding Enter key listener to nomeSelect.");
          nomeSelect.addEventListener('keypress', function(event) { if (event.key === 'Enter') { continuar(); } });
      } else {
          console.log("[window.onload] Skipping Enter key listener.");
      }
      console.log("[window.onload] Page load script finished.");
  };

</script>

</body>
</html>
