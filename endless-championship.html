<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Endless Championship - Ggames</title>
    <link rel="icon" type="image/png" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTl6Ljabwgx-VXdZz8FcAoygQprujSsCoXc32Y_iU0FjYVPu1B6MffWwp8gcCVuV8TWn39FRk9OIe1nc-esubVJYmdLsTptAoR9GyqNuw4R5MBaeaoWXTc3JaqH2YVNtEmfReQqohvQKvHiI0XwE5na2ty2B9Bt4oELxYv2BaZ7R3UmeylpiVEIbiLnCB/s320/soccer-ball-png.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <style>
   :root {
    --primary-bg: #263340;
    --secondary-bg: #2c3e50;
    --accent-color: #4ecdc4;
    --text-color: #ffffff;
    --gold-color: #ffd700;
}

body { margin: 0; background-color: var(--primary-bg); font-family: 'Roboto', sans-serif; color: var(--text-color); }
.container { padding: 20px; margin-bottom: 100px; }
header h1 { font-size: 2.5em; color: var(--accent-color); text-align: center; margin-bottom: 30px; }

/* Loading Screen & Animations */
#loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #FFFFFF; display: flex; justify-content: center; align-items: center; z-index: 1001; }
.loading-spinner { border: 16px solid #f3f3f3; border-top: 16px solid #3498db; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
@keyframes fadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }

/* Create Club Screen */
#create-club-container { display: none; padding: 40px 20px; text-align: center; max-width: 500px; margin: 50px auto; background: var(--secondary-bg); border-radius: 15px; animation: fadeIn 0.5s ease-out; }
#create-club-container h2 { font-size: 2em; color: var(--accent-color); margin-bottom: 20px; }
#club-name-input { width: 80%; padding: 12px; border-radius: 25px; border: 2px solid var(--accent-color); background: var(--primary-bg); color: var(--text-color); font-size: 1.1em; text-align: center; margin-bottom: 20px;}
.btn-create { background: linear-gradient(135deg, var(--accent-color) 0%, #3aa196 100%); color: var(--text-color); border: none; padding: 12px 30px; border-radius: 25px; font-size: 1.1em; font-weight: bold; cursor: pointer; }

/* Dashboard Grid */
.dashboard-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; }
.widget-card { background: var(--secondary-bg); border-radius: 15px; padding: 20px; box-shadow: 0 4px 15px rgba(0,0,0,0.3); position: relative; display: flex; flex-direction: column; height: 350px; }
.widget-header { display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; margin-bottom: 15px;}
.widget-title { font-size: 1.4em; margin: 0; }
.expand-icon { color: var(--accent-color); font-size: 1.2em; cursor: pointer; }
.widget-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    overflow: hidden;
    scroll-behavior: smooth;
}
.card-big-icon { font-size: 60px; color: var(--accent-color); margin-bottom: 15px; }
.card-main-text { font-size: 1.2em; font-weight: bold; }
.card-sub-text { opacity: 0.8; }
.squad-summary { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
.league-table { width: 100%; border-collapse: collapse; }
.league-table th, .league-table td { padding: 8px; text-align: left; border-bottom: 1px solid var(--primary-bg); }
.user-team-row { background-color: rgba(255, 215, 0, 0.2); font-weight: bold; }

/* Shop Icon */
#shop-icon-container { position: fixed; top: 20px; right: 20px; width: 55px; height: 55px; background-color: var(--gold-color); color: var(--primary-bg); border-radius: 50%; display: none; justify-content: center; align-items: center; font-size: 1.6em; cursor: pointer; z-index: 999; box-shadow: 0 4px 12px rgba(0,0,0,0.4); transition: transform 0.2s ease; }
#shop-icon-container:hover { transform: scale(1.1); }

/* Popups */
.popup-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; z-index: 1000; backdrop-filter: blur(5px); padding: 20px; box-sizing: border-box; }
.popup-content {
    background: var(--secondary-bg);
    border-radius: 15px;
    padding: 25px;
    width: 100%;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
    animation: fadeIn 0.3s ease-out;
    scroll-behavior: smooth;
}
.popup-close { position: absolute; top: 15px; right: 20px; font-size: 2em; color: #fff; cursor: pointer; }
.btn-simulate { background: linear-gradient(135deg, #ff6b6b 0%, #d62222 100%); color: var(--text-color); border: none; padding: 15px 35px; border-radius: 25px; font-size: 1.2em; font-weight: bold; cursor: pointer; }
.btn-simulate:disabled, .btn-create:disabled { background: #555; cursor: not-allowed; opacity: 0.7; }

/* Shop Popup & Pack Opening */
.packs-container { display: flex; flex-wrap: wrap; justify-content: space-around; gap: 20px; margin-top: 25px; }
.pack-option { background: var(--primary-bg); padding: 25px; border-radius: 10px; text-align: center; width: 180px; transition: transform 0.2s; border: 1px solid rgba(255,255,255,0.1); cursor: pointer; }
.pack-option:hover { transform: translateY(-5px); }
.pack-option .card-big-icon { font-size: 4em; }
.pack-option h3 { margin-top: 15px; margin-bottom: 20px; }
#player-cards-container { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-top: 25px; }
.player-card { background: var(--primary-bg); border-radius: 10px; padding: 20px; width: 200px; border: 1px solid var(--accent-color); box-shadow: 0 2px 8px rgba(0,0,0,0.4); text-align: center; animation: fadeIn 0.5s ease-out; }
.player-card .position { font-size: 1.2em; font-weight: bold; color: var(--accent-color); margin-bottom: 15px; }
.player-card .name { font-size: 1.1em; margin-bottom: 10px; }
.player-card .nationality { display: flex; align-items: center; justify-content: center; gap: 8px; opacity: 0.8; }
.player-card .nationality img { width: 24px; height: auto; border-radius: 3px; }

/* Squad Selection Styles */
#squad-options-container { justify-content: center; gap: 15px; }
.squad-option-card { background: var(--primary-bg); border: 1px solid var(--accent-color); border-radius: 10px; padding: 15px; width: 280px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
.squad-option-card h3 { margin: 0 0 10px 0; color: var(--accent-color); }
.squad-option-card .players-list { width: 100%; font-size: 0.9em; }
.squad-option-card .player-entry { display: flex; justify-content: space-between; padding: 4px; border-radius: 3px; }
.squad-option-card .player-entry:nth-child(odd) { background-color: rgba(0,0,0,0.2); }
.squad-option-card .player-entry .overall { font-weight: bold; color: var(--gold-color); }
.choose-squad-btn { margin-top: 15px; width: 100%; padding: 10px; }

/* Mini Pitch Styles */
.mini-pitch { background-color: #27ae60; background-image: linear-gradient(to right, rgba(255,255,255,0.1) 1px, transparent 1px), linear-gradient(to bottom, rgba(255,255,255,0.1) 1px, transparent 1px); background-size: 20px 20px; border: 3px solid #ecf0f1; border-radius: 10px; padding: 10px; height: 450px; display: flex; flex-direction: column; justify-content: space-around; position: relative; }
.mini-pitch::before { content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100px; height: 100px; border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; }
.mini-pitch::after { content: ''; position: absolute; top: 50%; left: 0; width: 100%; height: 2px; background-color: rgba(255,255,255,0.5); }
.pitch-row { display: flex; justify-content: center; align-items: center; gap: 20px; width: 100%; z-index: 1; }
.player-dot { width: 60px; height: 60px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--text-color); font-weight: bold; font-size: 1.2em; border: 3px solid #fff; box-shadow: 0 2px 5px rgba(0,0,0,0.5); cursor: help; position: relative; }
.player-dot[data-position="GR"] { background-color: #e67e22; }
.player-dot[data-position="DEF"] { background-color: #3498db; }
.player-dot[data-position="MED"] { background-color: #2ecc71; }
.player-dot[data-position="AVA"] { background-color: #e74c3c; }
.player-dot .player-name-tooltip { visibility: hidden; width: 160px; background-color: var(--primary-bg); color: #fff; text-align: center; border-radius: 6px; padding: 5px 0; position: absolute; z-index: 10; bottom: 125%; left: 50%; margin-left: -80px; opacity: 0; transition: opacity 0.3s; }
.player-dot:hover .player-name-tooltip { visibility: visible; opacity: 1; }

/* Match Results */
.match-results-container { width: 100%; text-align: center; font-size: 0.9em; overflow-y: auto; max-height: 100%; }
.match-result { display: flex; justify-content: space-between; align-items: center; padding: 8px 5px; border-radius: 5px; margin-bottom: 5px; background-color: var(--primary-bg); }
.match-result span { flex: 1; text-align: center; }
.match-result span.team-home { text-align: right; }
.match-result span.team-away { text-align: left; }
.match-result b { flex-basis: 50px; font-size: 1.1em; color: var(--accent-color); }
.match-result.user-match { background-color: rgba(255, 215, 0, 0.2); font-weight: bold; }
#pre-simulation-content { display: flex; flex-direction: column; justify-content: center; align-items: center; width: 100%; height: 100%; }
.pack-opener-btn {
    padding: 12px 25px;
    border-radius: 25px;
    border: none;
    color: var(--text-color);
    font-size: 1em;
    font-weight: bold;
    cursor: pointer;
    transition: transform 0.2s, opacity 0.2s;
}
.pack-opener-btn:hover:not(:disabled) {
    transform: translateY(-3px);
}
.pack-opener-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

/* Cores diferentes para cada botão */
.pack-opener-btn:nth-child(1) { background: linear-gradient(135deg, #4ecdc4 0%, #3aa196 100%); }
.pack-opener-btn:nth-child(2) { background: linear-gradient(135deg, #47a6e0 0%, #378ab8 100%); }
.pack-opener-btn:nth-child(3) { background: linear-gradient(135deg, #e07147 0%, #b86037 100%); }

#founding-message {
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 0.8; }
    50% { opacity: 1; }
    100% { opacity: 0.8; }
}

/* --- ANIMAÇÃO DO MARTELO EM CSS PURO --- */
.forging-animation-container {
    position: relative;
    width: 200px;
    height: 200px;
    display: flex;
    justify-content: center;
    align-items: center;
    margin: 0 auto;
}

.forging-emblem {
    font-size: 80px;
    color: var(--text-color);
    animation: impact-flash 1.5s infinite ease-in-out;
}

.forging-hammer {
    position: absolute;
    font-size: 60px;
    color: #bdc3c7;
    transform-origin: bottom right;
    animation: swing-hammer 1.5s infinite ease-in-out;
}

@keyframes swing-hammer {
    0% { transform: rotate(-45deg) translate(0px, 0px); }
    50% { transform: rotate(20deg) translate(-70px, 70px); }
    100% { transform: rotate(-45deg) translate(0px, 0px); }
}

@keyframes impact-flash {
    0%, 49%, 52%, 100% {
        color: var(--text-color);
        text-shadow: none;
        transform: scale(1);
    }
    50%, 51% {
        color: var(--gold-color);
        text-shadow: 0 0 20px var(--gold-color);
        transform: scale(1.05);
    }
}

/* --- ESTILOS PARA O ESTÁDIO 3D (VERSÃO MELHORADA E CORRIGIDA) --- */
#stadium-3d-container {
    width: 300px;
    height: 250px;
    margin: 30px auto;
    perspective: 1200px;
}

.stadium-scene {
    width: 100%;
    height: 100%;
    position: relative;
    transform-style: preserve-3d;
    transform: rotateX(60deg) rotateZ(-45deg);
    transition: transform 0.5s ease;
}
#stadium-3d-container:hover .stadium-scene {
    transform: rotateX(55deg) rotateZ(-45deg) scale(1.05);
}

.stadium-pitch {
    position: absolute;
    width: 150px;
    height: 220px;
    top: 15px;
    left: 75px;
    background-color: #27ae60;
    background-image: linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px);
    background-size: 15px 15px;
    box-shadow: 0 0 15px rgba(0,0,0,0.5) inset;
}

.stadium-stand {
    position: absolute;
    background-image: repeating-linear-gradient(to bottom, #a2a6a9, #8e9397 4px, #a2a6a9 8px);
    border: 1px solid #7f8c8d;
    box-shadow: 0 5px 10px rgba(0,0,0,0.3);
}

.stand-north.level-2 { width: 180px; height: 45px; top: -15px; left: 60px; transform: rotateX(-90deg) translateZ(22.5px); }
.stand-south.level-2 { width: 180px; height: 45px; top: 220px; left: 60px; transform: rotateX(-90deg) translateZ(-22.5px); }
.stand-west.level-2  { width: 45px; height: 250px; top: 0px; left: 37.5px; transform: rotateY(90deg) translateZ(22.5px); }
.stand-east.level-2  { width: 45px; height: 250px; top: 0px; left: 217.5px; transform: rotateY(90deg) translateZ(-22.5px); }

.stand-north.level-3 { width: 210px; height: 60px; top: -30px; left: 45px; transform: rotateX(-90deg) translateZ(30px); }
.stand-south.level-3 { width: 210px; height: 60px; top: 220px; left: 45px; transform: rotateX(-90deg) translateZ(-30px); }
.stand-west.level-3  { width: 60px; height: 280px; top: -15px; left: 15px; transform: rotateY(90deg) translateZ(30px); }
.stand-east.level-3  { width: 60px; height: 280px; top: -15px; left: 225px; transform: rotateY(90deg) translateZ(-30px); }

.stand-north.level-4, .stand-north.level-5, .stand-north.level-6, .stand-north.level-7 { width: 240px; height: 75px; top: -45px; left: 30px; transform: rotateX(-90deg) translateZ(37.5px); }
.stand-south.level-4, .stand-south.level-5, .stand-south.level-6, .stand-south.level-7 { width: 240px; height: 75px; top: 220px; left: 30px; transform: rotateX(-90deg) translateZ(-37.5px); }
.stand-west.level-4, .stand-west.level-5, .stand-west.level-6, .stand-west.level-7 { width: 75px; height: 310px; top: -30px; left: -7.5px; transform: rotateY(90deg) translateZ(37.5px); }
.stand-east.level-4, .stand-east.level-5, .stand-east.level-6, .stand-east.level-7 { width: 75px; height: 310px; top: -30px; left: 232.5px; transform: rotateY(90deg) translateZ(-37.5px); }

.stand-north.level-5, .stand-north.level-6, .stand-north.level-7 { width: 270px; height: 90px; top: -60px; left: 15px; transform: rotateX(-90deg) translateZ(45px); }
.stand-south.level-5, .stand-south.level-6, .stand-south.level-7 { width: 270px; height: 90px; top: 220px; left: 15px; transform: rotateX(-90deg) translateZ(-45px); }
.stand-west.level-5, .stand-west.level-6, .stand-west.level-7 { width: 90px; height: 340px; top: -45px; left: -30px; transform: rotateY(90deg) translateZ(45px); }
.stand-east.level-5, .stand-east.level-6, .stand-east.level-7 { width: 90px; height: 340px; top: -45px; left: 240px; transform: rotateY(90deg) translateZ(-45px); }

.stand-north.level-6, .stand-north.level-7 { width: 300px; height: 105px; top: -75px; left: 0px; transform: rotateX(-90deg) translateZ(52.5px); }
.stand-south.level-6, .stand-south.level-7 { width: 300px; height: 105px; top: 220px; left: 0px; transform: rotateX(-90deg) translateZ(-52.5px); }
.stand-west.level-6, .stand-west.level-7 { width: 105px; height: 370px; top: -60px; left: -52.5px; transform: rotateY(90deg) translateZ(52.5px); }
.stand-east.level-6, .stand-east.level-7 { width: 105px; height: 370px; top: -60px; left: 247.5px; transform: rotateY(90deg) translateZ(-52.5px); }

.stand-north.level-7 { width: 330px; height: 120px; top: -90px; left: -15px; transform: rotateX(-90deg) translateZ(60px); }
.stand-south.level-7 { width: 330px; height: 120px; top: 220px; left: -15px; transform: rotateX(-90deg) translateZ(-60px); }
.stand-west.level-7  { width: 120px; height: 400px; top: -75px; left: -75px; transform: rotateY(90deg) translateZ(60px); }
.stand-east.level-7  { width: 120px; height: 400px; top: -75px; left: 255px; transform: rotateY(90deg) translateZ(-60px); }

/* --- ESTILOS PARA OS HOLOFOTES (NOVO) --- */
.stadium-floodlight-pylon {
    position: absolute;
    width: 8px;
    height: 120px;
    background: linear-gradient(to top, #566573, #8a9aab);
    box-shadow: 0 0 10px rgba(0,0,0,0.5);
    transform-style: preserve-3d;
    border-top: 15px solid #f1c40f; /* A "luz" do holofote */
}
.pylon-nw { top: -45px; left: 45px; transform: rotateX(90deg) rotateY(15deg); }
.pylon-ne { top: -45px; left: 247px; transform: rotateX(90deg) rotateY(-15deg); }
.pylon-sw { top: 200px; left: 45px; transform: rotateX(90deg) rotateY(15deg); }
.pylon-se { top: 200px; left: 247px; transform: rotateX(90deg) rotateY(-15deg); }

/* --- ESTILOS DO TELHADO (VERSÃO FINAL E CORRIGIDA) --- */
.roof-panel {
    position: absolute;
    width: 50%;
    height: 310px;
    background: linear-gradient(to bottom, #6c7a89, #566573);
    border: 2px solid #34495e;
    box-shadow: 0 5px 15px rgba(0,0,0,0.4);
    transform: rotateX(90deg) translateZ(85px);
    transition: transform 0.5s ease-in-out;
}
.roof-panel-a { left: 0; }
.roof-panel-b { right: 0; }

.roof.level-5 .roof-panel-a { transform: rotateX(90deg) translateZ(85px) translateX(-70%); }
.roof.level-5 .roof-panel-b { transform: rotateX(90deg) translateZ(85px) translateX(70%); }

.roof.level-6 .roof-panel-a { transform: rotateX(90deg) translateZ(85px) translateX(-25%); }
.roof.level-6 .roof-panel-b { transform: rotateX(90deg) translateZ(85px) translateX(25%); }

.roof.level-7 .roof-panel-a { transform: rotateX(90deg) translateZ(85px) translateX(0%); }
.roof.level-7 .roof-panel-b { transform: rotateX(90deg) translateZ(85px) translateX(0%); }

/* --- ESTILOS PARA A MINIATURA DO ESTÁDIO NO WIDGET (NOVO) --- */
#stadium-widget-render-area {
    height: 160px;
    width: 100%;
    perspective: 800px;
    overflow: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 10px;
}
#stadium-widget-render-area .stadium-scene {
    transform: rotateX(60deg) rotateZ(-45deg) scale(0.65);
    transition: none;
}

/* Correção para remover o efeito de camadas múltiplas indesejado */
.widget-card::before, .widget-card::after {
    content: none !important;
    display: none !important;
    box-shadow: none !important;
}

/* --- ESTILOS PARA DETALHES DO RELVADO (JOGADORES E BOLA) --- */
.stadium-goal {
    position: absolute;
    width: 25px;
    height: 10px;
    border: 2px solid rgba(255, 255, 255, 0.8);
    border-bottom: none;
    left: 50%;
    transform: translateX(-50%);
    z-index: 5;
}

.goal-north { top: 5px; }
.goal-south { bottom: 5px; }

/* Estilo para os pontos (jogadores) */
.player-marker {
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    box-shadow: 0 0 4px rgba(0,0,0,0.6);
    z-index: 6;
}
.team-a { background-color: #3498db; }
.team-b { background-color: #e74c3c; }

/* Estilo e nova animação para a bola */
.animated-ball {
    position: absolute;
    width: 5px;
    height: 5px;
    background-color: #ffffff;
    border-radius: 50%;
    box-shadow: 0 0 5px rgba(0,0,0,0.7);
    z-index: 10;
    animation: passing-drill 5s ease-in-out infinite;
}

@keyframes passing-drill {
    0%, 100% { top: 25%; left: 30%; }
    25% { top: 45%; left: 60%; }
    50% { top: 65%; left: 40%; }
    75% { top: 75%; left: 20%; }
}

/* --- ESTILOS PARA FLASHES NAS BANCADAS (CORRIGIDO) --- */
.flash-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    transform: translateZ(1px);
}

.camera-flash {
    position: absolute;
    width: 4px;
    height: 4px;
    border-radius: 50%;
    background-color: #ffffff;
    box-shadow: 0 0 8px 3px rgba(255, 255, 220, 0.9);
    opacity: 0;
    animation: flash-animation 5s infinite;
}

@keyframes flash-animation {
    0% { opacity: 0; }
    1% { opacity: 1; transform: scale(1.2); }
    3% { opacity: 0; transform: scale(1); }
    100% { opacity: 0; }
}

/* --- ESTILOS PERSONALIZADOS PARA A SCROLLBAR --- */
*::-webkit-scrollbar {
    width: 10px;
    height: 10px;
}

*::-webkit-scrollbar-track {
    background: var(--primary-bg);
    border-radius: 5px;
}

*::-webkit-scrollbar-thumb {
    background-color: var(--accent-color);
    border-radius: 5px;
    border: 2px solid var(--primary-bg);
}

*::-webkit-scrollbar-thumb:hover {
    background-color: #3aa196;
}

/* --- CORREÇÃO ESPECÍFICA PARA O WIDGET DA CLASSIFICAÇÃO --- */
.widget-card[data-widget="league"] .widget-content {
    display: block; /* Anula o 'display: flex' */
    justify-content: initial; /* Anula o centramento vertical */
    align-items: initial; /* Anula o centramento horizontal */
    overflow-y: auto; /* Garante que a barra de scroll aparece aqui */
}

.tactic-selection-container { margin-top: 20px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px; }
.tactic-btn { background-color: var(--primary-bg); border: 2px solid var(--accent-color); color: var(--accent-color); padding: 8px 15px; border-radius: 20px; cursor: pointer; margin: 5px; font-weight: bold; }
.tactic-btn:hover { background-color: var(--accent-color); color: var(--primary-bg); }
.tactic-btn.active-tactic { background-color: var(--gold-color); border-color: var(--gold-color); color: var(--primary-bg); }
.tactic-btn:disabled { cursor: not-allowed; opacity: 0.6; }

.tactic-btn:disabled .fa-lock { 
    margin-left: 8px; 
    font-size: 0.8em;
    opacity: 0.7;
}


/* Efeito de onda de choque/fanfarra */
.btn-simulate::after {
    content: '';
    position: absolute;
    top: -4px; left: -4px; right: -4px; bottom: -4px;
    border-radius: 30px; /* Um pouco mais que o botão */
    border: 3px solid var(--gold-color);
    opacity: 0;
    transform: scale(0.8);
}

.btn-simulate.simulating {
    pointer-events: none; /* Impede múltiplos cliques */
    color: var(--gold-color); /* Destaca o texto durante a animação */
}

.btn-simulate.simulating::after {
    /* Ativa a animação da onda de choque */
    animation: fanfare-pulse 0.8s ease-out forwards;
}

@keyframes fanfare-pulse {
    0% {
        transform: scale(0.9);
        opacity: 0.8;
    }
    100% {
        transform: scale(1.4);
        opacity: 0;
    }
}

/* Partículas de Confetti */
.confetti-piece {
    position: absolute;
    width: 8px;
    height: 16px;
    background-color: var(--gold-color);
    border-radius: 4px;
    opacity: 0;
    z-index: 1002; /* Garante que fica por cima do overlay */
    animation: confetti-burst 1s ease-out forwards;
}

@keyframes confetti-burst {
    0% {
        transform: translate(0, 0) rotate(0deg) scale(0.5);
        opacity: 1;
    }
    100% {
        /* O JavaScript irá definir os valores de translate e rotate */
        transform: translate(var(--x-end), var(--y-end)) rotate(var(--rotate-end)) scale(1);
        opacity: 0;
    }
}

/* --- ESTILOS PARA O TOAST DE INFORMAÇÃO DO DONO --- */
#owner-toast {
    position: fixed;
    bottom: 25px;
    left: 25px;
    background-color: var(--secondary-bg);
    padding: 18px 25px;
    border-radius: 12px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.4);
    z-index: 1005;
    max-width: 320px;
    border-left: 5px solid var(--accent-color);
    
    /* Estado inicial (escondido fora da tela) */
    opacity: 0;
    transform: translateX(-120%);
    transition: transform 0.4s ease-out, opacity 0.4s ease-out;
}

/* Estado visível */
#owner-toast.show {
    opacity: 1;
    transform: translateX(0);
}

#owner-toast h3, #owner-toast p, #owner-toast h4 {
    margin: 0;
    padding: 0;
}

#owner-toast p {
    margin-top: 10px;
    font-size: 0.9em;
    opacity: 0.8;
}

#owner-toast h4 {
    font-size: 1.3em;
    color: var(--gold-color);
    margin-top: 4px;
}

#points-reward-icon {
    position: fixed;
    top: 20px;
    right: 90px; /* Posição à esquerda do ícone da loja */
    width: 55px;
    height: 55px;
    background-color: #2ecc71; /* Cor verde para dinheiro/recompensa */
    color: var(--text-color);
    border-radius: 50%;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 1.2em;
    cursor: default;
    z-index: 998;
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    transition: transform 0.2s ease, background-color 0.3s;
}

#points-reward-icon .fa-coins {
    font-size: 0.9em;
    margin-bottom: -2px;
}

#points-reward-icon span {
    font-size: 0.8em;
    font-weight: bold;
}

/* Animação para quando o prémio está disponível */
#points-reward-icon.is-claimable {
    cursor: pointer;
    background-color: var(--gold-color);
    color: var(--primary-bg);
    animation: pulse-and-shake 1.5s infinite;
}

@keyframes pulse-and-shake {
    0% { transform: scale(1) rotate(0deg); }
    10% { transform: scale(1.1) rotate(-5deg); }
    20% { transform: scale(1.1) rotate(5deg); }
    30% { transform: scale(1.1) rotate(-5deg); }
    40% { transform: scale(1.1) rotate(5deg); }
    50% { transform: scale(1) rotate(0deg); }
    100% { transform: scale(1) rotate(0deg); }
}


@media (max-width: 600px) {
  .league-table th:nth-child(n+4),
  .league-table td:nth-child(n+4) {
    /* This selects and hides the 4th column (J) and all columns after it */
    display: none;
  }

  .league-table th, .league-table td {
      /* Optional: Reduce padding to make more space */
      padding: 8px 5px;
  }
}

    </style>
</head>
<body>


    <!-- Ícone de Recompensa de Pontos -->
<div id="points-reward-icon" style="display: none;">
    <i class="fas fa-coins"></i>
    <span id="points-reward-value">0</span>
</div>

    <div id="loading-screen"><div class="loading-spinner"></div></div>
    
    <div id="shop-icon-container"><i class="fas fa-store"></i></div>

    <div id="create-club-container">
        <h2>Bem-vindo ao Campeonato!</h2>
        <p>Parece que ainda não tens um clube. Dá um nome à tua equipa para começares a tua jornada!</p>
        <input type="text" id="club-name-input" placeholder="Nome do Clube" maxlength="25">
        <button id="save-club-btn" class="btn-create">Criar Clube</button>
    </div>

    <div id="dashboard-container" class="container" style="display: none;">
        <header><h1 id="club-name-header">The Endless Championship</h1></header>
        <div class="dashboard-grid">
            <div class="widget-card" data-widget="match">
                <div class="widget-header"><h3 class="widget-title">Grande Jornada</h3><i class="fas fa-expand expand-icon"></i></div>
                <div class="widget-content">
                    <div id="pre-simulation-content">
                        <i class="fas fa-calendar-alt card-big-icon"></i>
                        <h4 id="grande-jornada-week" class="card-main-text">Semana 1 de 4</h4>
                        <button id="simulate-week-btn-widget" class="btn-simulate" style="margin-top: 15px; padding: 12px 25px; font-size: 1em;">
                            <i class="fas fa-play-circle"></i> Simular Semana
                        </button>
                    </div>
                    <div id="grande-jornada-results" class="match-results-container" style="display: none;"></div>
                </div>
            </div>
           <div class="widget-card" data-widget="league">
    <div class="widget-header">
        <h3 class="widget-title">Classificação</h3>
        <i class="fas fa-expand expand-icon"></i>
    </div>
    <div class="widget-content" style="overflow-y: auto;">
        <table class="league-table">
            <thead>
                <tr>
                    <th>Pos</th>
                    <th>Clube</th>
                    <th>Pts</th>
                     <th>J</th>
                    <th>V</th>
                    <th>E</th>
                    <th>D</th>
                    <th>GM</th>
                    <th>GS</th>
                </tr>
            </thead>
            <tbody id="league-table-body"></tbody>
        </table>
    </div>
</div>

            <div class="widget-card" data-widget="coach">
                <div class="widget-header"><h3 class="widget-title">Treinador</h3><i class="fas fa-expand expand-icon"></i></div>
                <div class="widget-content"><i class="fas fa-user-tie card-big-icon"></i><p class="card-main-text">Por Contratar</p><p class="card-sub-text">Sem tática definida</p></div>
            </div>
            <div class="widget-card" data-widget="squad">
                <div class="widget-header"><h3 class="widget-title">Meu Plantel</h3><i class="fas fa-expand expand-icon"></i></div>
                <div class="widget-content">
                    <div id="squad-summary-container" class="squad-summary"></div>
                    <p id="squad-player-count" style="margin-top: 20px;">0/6 Jogadores</p>
                </div>
            </div>
           <div class="widget-card" data-widget="stadium">
                <div class="widget-header">
                    <h3 class="widget-title">Estádio</h3>
                    <i class="fas fa-expand expand-icon"></i>
                </div>
                <div class="widget-content">
                    <div id="stadium-widget-render-area">
                        <!-- O JavaScript vai renderizar o estádio aqui -->
                    </div>
                    <p class="card-main-text">O Seu Estádio</p>
                    <p class="card-sub-text">Nível do Estádio: 1</p>
                </div>
            </div>
        </div>
    </div>

    <!-- POPUPS -->
    <div id="widget-popup" class="popup-overlay">
        <div class="popup-content"><span class="popup-close">&times;</span><h2 id="popup-title" style="text-align: center; margin-bottom: 20px;"></h2><div id="popup-body"></div></div>
    </div>

    <div id="shop-popup" class="popup-overlay">
        <div class="popup-content">
            <span class="popup-close">&times;</span><h2 style="text-align: center; color: var(--gold-color);">Loja de Packs</h2>
            <div class="packs-container">
                <div class="pack-option" data-pack="players"><i class="fas fa-users card-big-icon"></i><h3>Pack de Jogadores</h3></div>
                <div class="pack-option" data-pack="coach"><i class="fas fa-user-tie card-big-icon" style="color: var(--accent-color);"></i><h3>Pack de Treinador</h3></div>
                <div class="pack-option" data-pack="stadium"><i class="fas fa-flag card-big-icon" style="color: #ff6b6b;"></i><h3>Pack de Estádio</h3></div>
            </div>
        </div>
    </div>
    
    <div id="pack-opening-popup" class="popup-overlay">
        <div class="popup-content">
            <span class="popup-close">&times;</span>
            <h2 style="text-align: center; color: var(--gold-color);">Pack de Jogadores</h2>
            <div id="player-cards-container" style="text-align: center;"></div>
        </div>
    </div>

   <div id="monthly-renewal-popup" class="popup-overlay">
    <div class="popup-content" style="max-width: 550px; text-align: center;">
        <h2 style="color: var(--accent-color);">Fim da Temporada</h2>
        <p style="margin: 20px 0;">A temporada terminou! Deseja continuar com a sua equipa e evoluí-la, ou prefere fazer alterações estruturais para a nova época?</p>
        <div style="display: flex; justify-content: space-around; gap: 15px;">
            <button id="keep-squad-btn" class="btn-create" style="flex: 1;">Manter e Evoluir</button>
            <button id="change-squad-btn" class="btn-simulate" style="flex: 1;">Fazer Alterações</button>
        </div>
    </div>
</div>

    <div id="initial-squad-popup" class="popup-overlay">
        <div class="popup-content" style="max-width: 95%;">
            <h2 style="text-align: center; color: var(--gold-color);">Escolha o Seu Plantel Inicial</h2>
            <p id="squad-selection-status" style="text-align: center;">Para começar, precisa de um plantel. Abra até 3 packs de jogadores e depois escolha o que mais lhe agrada para ser a sua equipa oficial.</p>
            <div style="text-align: center; margin: 20px 0;">
                <div id="pack-buttons-container" style="display: flex; justify-content: center; gap: 15px; margin: 20px 0;"></div>
            </div>
            <div id="squad-options-container" class="packs-container" style="align-items: flex-start;"></div>
        </div>
    </div>

    <div id="founding-club-overlay" class="popup-overlay" style="display: none; animation: fadeIn 0.5s ease-out;">
        <div class="popup-content" style="background: transparent; box-shadow: none; text-align: center;">
            <img src="https://i.gifer.com/ZZ5H.gif" alt="A forjar o emblema do clube" style="width: 180px; margin-bottom: 20px; border-radius: 10px;">
            <h2 id="founding-message" style="color: var(--gold-color); text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);">A Fundar o Clube...</h2>
        </div>
    </div>

    <!-- Pop-up para Resgatar Prémios -->
<div id="claim-reward-popup" class="popup-overlay">
    <div class="popup-content" style="max-width: 450px; text-align: center;">
        <span class="popup-close">&times;</span>
        <h2 style="color: var(--gold-color);">Recompensa da Temporada</h2>
        <p style="margin: 20px 0;">Parabéns pelo seu desempenho! Pode converter os pontos que acumulou em mini-gcoins.</p>
        <p style="font-size: 1.5em; margin-bottom: 25px;">
            Total a Receber: <b id="claim-reward-amount" style="color: var(--accent-color);">0</b> mini-gcoins
        </p>
        <button id="claim-reward-btn" class="btn-create">Resgatar Recompensa</button>
    </div>
</div>

    <!-- NOVO TOAST PARA MOSTRAR O DONO DO CLUBE -->
    <div id="owner-toast">
        <div id="owner-toast-content">
            <!-- O conteúdo será preenchido por JavaScript -->
        </div>
    </div>
  
      <!-- Pop-up de Notificação Genérica -->
    <div id="notification-popup" class="popup-overlay">
        <div class="popup-content" style="max-width: 450px; text-align: center;">
            <h2 id="notification-title" style="color: var(--accent-color);">Aviso</h2>
            <p id="notification-message" style="margin: 20px 0;"></p>
            <button id="notification-close-btn" class="btn-create">OK</button>
        </div>
    </div>


    <!-- CONTEÚDO PARA POPUPS DE WIDGETS -->
    <div id="widget-details" style="display: none;">
        <div data-content="match"> <div id="popup-match-results" class="match-results-container"></div> <p id="simulation-status-popup">Ao clicar, todos os jogos da semana serão simulados. Esta ação é irreversível.</p> <button id="simulate-week-btn" class="btn-simulate"><i class="fas fa-play-circle"></i> Simular Jogos da Semana</button> </div>
<div data-content="league">
    <table class="league-table">
        <thead>
            <tr>
                <th>Pos</th>
                <th>Clube</th>
                <th>Pts</th>
                 <th>J</th>
                <th>V</th>
                <th>E</th>
                <th>D</th>
                <th>GM</th>
                <th>GS</th>
            </tr>
        </thead>
        <tbody id="league-table-body-popup"></tbody>
    </table>
</div>        <div data-content="coach"><p>Aqui poderá ver os detalhes do seu treinador, as suas táticas e procurar novos treinadores no mercado.</p></div>
        <div data-content="squad">
            <div class="mini-pitch">
                <div class="pitch-row attack-area"></div>
                <div class="pitch-row midfield-area"></div>
                <div class="pitch-row defense-area"></div>
                <div class="pitch-row goalkeeper-area"></div>
            </div>
        </div>
        <div data-content="stadium">
            <div id="stadium-3d-container">
                <!-- O JavaScript irá construir o estádio aqui -->
            </div>
            <button id="upgrade-stadium-btn" class="btn-create" style="margin-top: 15px;">Aumentar Tamanho do Estádio</button>
            <p style="margin-top: 20px;">Aqui poderá ver o seu estádio, fazer melhorias para aumentar os bónus e a capacidade.</p>
        </div>
        <!-- HTML DA ANIMAÇÃO DO MARTELO EM CSS PURO -->
        <div data-content="founding-animation">
            <div class="forging-animation-container">
                <i class="fas fa-shield-alt forging-emblem"></i>
                <i class="fas fa-hammer forging-hammer"></i>
            </div>
            <h2 style="color: var(--gold-color); text-shadow: 0 0 10px rgba(255, 215, 0, 0.7); margin-top: 20px;">A Fundar o Clube...</h2>
        </div>
    </div>

    <script src="menu-component.js"></script>
    <script src="config.js"></script>
    <script type="module">
import { getFirestore, doc, getDoc, collection, query, where, getDocs, setDoc, writeBatch, Timestamp, increment, updateDoc, onSnapshot, orderBy, limit } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";
import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js"; // <-- VERIFIQUE ESTA LINHA
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFunctions, httpsCallable } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-functions.js";


        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const functions = getFunctions(app);
const fictitiousTeamNames = ["Leões do Vale FC", "Northern Rovers FC", "Leones de Montaña", "Olympique de la Vallée", "Aquile della Notte", "Stahlwerk FC", "Al-Ittihad Al-Jabal", "Lokomotiv Taiga", "Shāndǐng Jùrén", "Dragões do Atlântico", "Avalon Athletic", "Atlético del Sol", "AS Étoiles d'Argent", "Unione Titani", "Adler von den Gipfelns", "Al-Nujum Al-Sharqiya", "Dynamo Sever", "Hóng Lóng FC", "Unidos da Serra", "Redwood Giants", "Unión Capital CF", "Lions de Fer", "Dinamo Ferroviario", "Einheit Hauptstadt", "Shabab Al-Sahra", "Zvezda Vostoka", "Běijí Xīng", "Imperial FC", "Harbor City United", "Gigantes del Sur", "Cité Royale FC", "Foresta Nera FC", "Dynamo Berg", "Al-Nasr Al-Thahabi", "Sokol Tundra", "Hēi Hǔ Dìguó", "Metropolitanos de Aço", "Starlight FC", "Estrella Roja FC"];

        const loadingScreen = document.getElementById('loading-screen');
        const createClubContainer = document.getElementById('create-club-container');
        const dashboardContainer = document.getElementById('dashboard-container');
        const shopIcon = document.getElementById('shop-icon-container');
        const shopPopup = document.getElementById('shop-popup');

        let currentUserClubData;
     let leagueClubs = []; // Esta será a nossa tabela "visível" ou "congelada"
let liveLeagueClubs = []; // Esta será a tabela "escondida", atualizada em tempo real
let allowRealtimeLeagueRender = false; // Flag para controlar a renderização
let leagueListener = null;
        
     const fictitiousNames = [
            "Estádio da Colina", "Arena do Horizonte", "Parque dos Campeões", "Fortaleza do Dragão", 
            "Ninho da Águia", "Caldeirão do Leão", "Vale Dourado", "Centro Desportivo Metropolitano",
            "Estádio Vanguarda", "Arena Sideral", "Complexo Olímpico da Planície", "Estádio da Fronteira",
            "Cidadela Imperial", "Parque dos Pioneiros", "Arena da Costa Dourada", "Santuário do Gladiador",
            "Estádio do Monarca", "Coliseu do Trovão", "Arena da Maré Alta", "Recinto dos Titãs",
            "Estádio Aurora Boreal", "Parque Centenário", "Fortaleza do Norte", "Estádio do Penhasco",
            "Arena de Mármore", "Estádio da Capital", "O Ninho do Falcão", "Estádio Ciclone",
            "Arena dos Vulcões", "Parque Esmeralda",
            "Estádio do Sol Poente", "Arena das Lendas", "Parque da Vitória", "Catedral do Futebol",
            "Estádio Titânico", "Ninho dos Grifos", "Arena da Constelação", "Fortaleza Escarlate",
            "Estádio da Muralha", "Recinto dos Heróis", "Campo de Elísio", "Arena do Pinhal",
            "Estádio do Farol", "Parque dos Ventos", "Arena da Baía", "Estádio da Rocha",
            "O Colosso Verde", "Estádio da Coroa", "Arena do Deserto", "Vale dos Gigantes"
            // Pode continuar a adicionar...
        ];

        // --- INÍCIO DAS FUNÇÕES ADICIONADAS PARA CONTROLO DE ACESSO E MENU ---

        // Função para carregar as REGRAS DE ACESSO À PÁGINA (de 'paineis perfil')
        async function loadAccessSettings() {
            return getDoc(doc(db, 'paineis', 'paineis perfil')).then(d => d.exists() ? d.data() : {});
        }

        // Função para carregar as REGRAS DE VISIBILIDADE DO MENU (de 'paineis menu')
        async function loadMenuSettings() {
            return getDoc(doc(db, 'paineis', 'paineis menu')).then(d => d.exists() ? d.data() : {});
        }

        // Função que usa as regras de ACESSO para verificar se o utilizador pode ver a página
   function checkPageAccess(userStatus, accessSettings) {

    // REGRA 1 (PRIORIDADE MÁXIMA): Acesso de Administrador ('ruler')
    // Esta regra não muda. Se o utilizador for 'ruler', tem acesso imediato.
    if (userStatus.estatuto === 'ruler') {
        return true;
    }

    // REGRA 2 (PARA UTILIZADORES NORMAIS): Verificação "E" (AND)
    // Ambas as condições seguintes devem ser verdadeiras para o acesso ser concedido.

    // Condição A: O "interruptor" global no painel de controlo deve estar ligado.
    const globalAccess = accessSettings['endless'] === 'on';

    // Condição B: O utilizador deve ter a permissão específica no seu perfil.
    const hasSpecificPermission = userStatus?.permissoes?.endless === 'yes';

    // A função retorna 'true' apenas se a Condição A E a Condição B forem verdadeiras.
    return globalAccess && hasSpecificPermission;
}


        // Função para obter dados básicos do utilizador da coleção 'users'
    async function getUserStatus(userId) {
    const userDoc = await getDoc(doc(db, 'users', userId));

    // Primeiro, verifica se o documento do utilizador existe. Se não, não há nada a fazer.
    if (!userDoc.exists()) {
        return null;
    }

    const userData = userDoc.data();

    // REGRA DE PRIORIDADE: Se o estatuto for 'ruler', retorna os dados imediatamente,
    // ignorando qualquer outra condição como o campo 'aceite'.
    if (userData.estatuto === 'ruler') {
        return userData;
    }

    // Para todos os outros utilizadores, a verificação original mantém-se.
    if (userData.aceite === "Yes") {
        return userData;
    }

    // Se não for 'ruler' nem tiver o perfil aceite, o acesso é negado.
    return null;
}
        
        // --- FIM DAS FUNÇÕES ADICIONADAS ---
// NOVA FUNÇÃO para ajustar os jogos de um bot que foi desativado
async function adjustGamesForDeactivatedBot(botId, seasonIdentifier) {
    console.log(`A ajustar jogos para o bot desativado: ${botId}`);
    const gamesRef = collection(db, "endlessjogos");
    const batch = writeBatch(db);

    // Firestore não suporta queries OR, por isso fazemos duas queries separadas
    const homeGamesQuery = query(gamesRef, where("homeTeamId", "==", botId), where("seasonId", "==", seasonIdentifier));
    const awayGamesQuery = query(gamesRef, where("awayTeamId", "==", botId), where("seasonId", "==", seasonIdentifier));

    try {
        const [homeGamesSnapshot, awayGamesSnapshot] = await Promise.all([
            getDocs(homeGamesQuery),
            getDocs(awayGamesQuery)
        ]);

        const allGames = [...homeGamesSnapshot.docs, ...awayGamesSnapshot.docs];
        if (allGames.length === 0) {
            console.log("Nenhum jogo encontrado para ajustar.");
            return;
        }

        console.log(`Encontrados ${allGames.length} jogos para ajustar.`);

        for (const gameDoc of allGames) {
            const gameData = gameDoc.data();
            const opponentId = gameData.homeTeamId === botId ? gameData.awayTeamId : gameData.homeTeamId;
            const opponentRef = doc(db, 'endlessclubes', opponentId);
            
            // Stats antigos
            const oldBotPoints = gameData.homeScore > gameData.awayScore ? 3 : (gameData.homeScore === gameData.awayScore ? 1 : 0);
            const oldOpponentPoints = gameData.awayScore > gameData.homeScore ? 3 : (gameData.awayScore === gameData.homeScore ? 1 : 0);

            // O adversário ganha sempre por 3-0
            const newScore = gameData.homeTeamId === botId ? { home: 0, away: 3 } : { home: 3, away: 0 };
            
            // Deltas (mudanças) nas estatísticas para o adversário
            const pointsDelta = 3 - oldOpponentPoints;
            const winsDelta = (oldOpponentPoints < 3) ? 1 : 0; // Ganha uma vitória se não a tinha
            const lossesDelta = (oldOpponentPoints === 3) ? -1 : 0; // Perde uma derrota se a tinha
            const drawsDelta = (oldOpponentPoints === 1) ? -1 : 0; // Perde um empate se o tinha

            // Atualiza o documento do jogo para 3-0
            batch.update(gameDoc.ref, { homeScore: newScore.home, awayScore: newScore.away });
            
            // Atualiza as estatísticas do adversário usando incrementos atómicos
            batch.update(opponentRef, {
                pontos: increment(pointsDelta),
                vitorias: increment(winsDelta),
                derrotas: increment(lossesDelta),
                empates: increment(drawsDelta),
                // Ajusta golos para refletir o 3-0
                golosMarcados: increment(newScore.away - gameData.awayScore),
                golosSofridos: increment(newScore.home - gameData.homeScore)
            });
        }
        
        await batch.commit();
        console.log("Jogos e estatísticas ajustados com sucesso.");

    } catch (error) {
        console.error("Erro ao ajustar os jogos do bot desativado:", error);
    }
}


   async function generateRandomCoach() {
    try {
        // Prepara a chamada para a sua nova Cloud Function
        const getRandomUsers = httpsCallable(functions, 'getRandomUsers');
        const result = await getRandomUsers({ count: 20 }); // Pede 20 utilizadores
        
        const coach = result.data[0]; // Os dados vêm em result.data
        const name = `${coach.name.first} ${coach.name.last}`;
        const countryCode = coach.nat;
        
        const BASIC_FORMATIONS = ["1-2-2-1", "1-3-1-1"];
        const shuffledBasics = BASIC_FORMATIONS.sort(() => 0.5 - Math.random());
        const availableFormations = shuffledBasics.slice(0, Math.floor(Math.random() * 2) + 1);

        return {
            name: name,
            countryCode: countryCode,
            overall: Math.floor(Math.random() * 49) + 2,
            quimica: Math.floor(Math.random() * 49) + 2,
            temporadas: 1,
            formacaoAtual: availableFormations[0],
            formacoesDisponiveis: availableFormations
        };
    } catch (error) {
        console.error("Erro ao gerar treinador aleatório via Cloud Function, usando fallback:", error);
        return {
            name: "Treinador Genérico", countryCode: "PT",
            overall: Math.floor(Math.random() * 49) + 2, quimica: Math.floor(Math.random() * 49) + 2,
            temporadas: 1, formacaoAtual: "1-2-2-1", formacoesDisponiveis: ["1-2-2-1"]
        };
    }
}

async function generateUniqueStadiumOptions(count = 3) {
    try {
        // Passo 1: Obter todos os nomes de estádio já em uso no Firestore
        const clubsQuery = query(collection(db, 'endlessclubes'), where("estadio", "!=", null));
        const querySnapshot = await getDocs(clubsQuery);
        const existingStadiumNames = new Set();
        querySnapshot.forEach(doc => {
            if (doc.data().estadio && doc.data().estadio.name) {
                existingStadiumNames.add(doc.data().estadio.name);
            }
        });

        // Passo 2: Filtrar a lista principal para obter apenas os nomes disponíveis
        const availableNames = fictitiousNames.filter(name => !existingStadiumNames.has(name));

        // Passo 3: Verificar se há nomes suficientes e ter um plano B
        if (availableNames.length < count) {
            console.warn(`Não há nomes de estádios únicos suficientes (${availableNames.length}/${count})! A gerar nomes de fallback.`);
            const fallbacks = [];
            for (let i = 0; i < count; i++) {
                fallbacks.push({ name: `Estádio Genérico ${Date.now() + i}`, ambiente: 0 });
            }
            return fallbacks;
        }

        // Passo 4: Baralhar os nomes disponíveis e escolher a quantidade necessária
        const shuffled = availableNames.sort(() => 0.5 - Math.random());
        const selectedNames = shuffled.slice(0, count);

        // Passo 5: Formatar os nomes escolhidos como objetos de estádio
        return selectedNames.map(name => ({ name: name, ambiente: 0 }));

    } catch (error) {
        console.error("Erro ao gerar opções de estádio únicas:", error);
        // Retornar um fallback em caso de erro na consulta
        const fallbacks = [];
        for (let i = 0; i < count; i++) {
            fallbacks.push({ name: `Estádio de Emergência ${Date.now() + i}`, ambiente: 0 });
        }
        return fallbacks;
    }
}

       async function generateUniquePlayers(excludeNamesSet = new Set()) {
    const positions = ['GR', 'DEF', 'DEF', 'MED', 'MED', 'AVA'];
    const neededPlayers = 6;
    let players = [];
    const sessionUsedNames = new Set();
    let attempts = 0;
    const maxAttempts = 5; // Reduzido, pois a chamada à função é mais fiável

    while (players.length < neededPlayers && attempts < maxAttempts) {
        attempts++;
        try {
            const fetchCount = (neededPlayers - players.length) * 2 + 5;
            
            // Prepara a chamada para a sua nova Cloud Function
            const getRandomUsers = httpsCallable(functions, 'getRandomUsers');
            const result = await getRandomUsers({ count: fetchCount });
            const candidates = result.data;

            for (const candidate of candidates) {
                const name = `${candidate.name.first} ${candidate.name.last}`;
                const normalizedName = normalizePlayerName(name);

                const isDuplicateInDB = excludeNamesSet.has(normalizedName);
                const isDuplicateInSession = sessionUsedNames.has(normalizedName);

                if (!isDuplicateInDB && !isDuplicateInSession) {
                    sessionUsedNames.add(normalizedName);
                    players.push({
                        name: name,
                        countryCode: candidate.nat,
                        overall: Math.floor(Math.random() * 49) + 2
                    });
                    if (players.length === neededPlayers) break;
                }
            }
        } catch (error) {
            console.warn("Falha na Cloud Function durante a geração de jogadores. A tentar novamente...", error);
        }
    }
    
    while (players.length < neededPlayers) {
        players.push({ 
            name: `Jogador Genérico ${players.length + 1}`, 
            countryCode: 'PT', 
            overall: Math.floor(Math.random() * 49) + 2 
        });
    }

    return players.map((player, index) => ({ ...player, position: positions[index] }));
}

        
        async function generateCoachPack(size = 3) {
            const coaches = [];
            for (let i = 0; i < size; i++) {
                coaches.push(await generateRandomCoach());
            }
            return coaches;
        }

        function generateStadiumPack(size = 3) {
            const stadiums = [];
            for (let i = 0; i < size; i++) {
                stadiums.push(generateRandomStadium());
            }
            return stadiums;
        }

        function generateRandomStadium() {
            const name = fictitiousStadiumNames[Math.floor(Math.random() * fictitiousStadiumNames.length)];
            return {
                name: name,
                ambiente: 0
            };
        }

 onAuthStateChanged(auth, async (user) => {
    if (user) {
        try {
            // PASSO 1: Obter dados e verificar permissão de acesso à página (isto não muda)
            const userInfo = await getUserStatus(user.uid);
            if (!userInfo) {
                window.location.href = 'index.html';
                return;
            }

            const accessSettings = await loadAccessSettings();
            if (!checkPageAccess(userInfo, accessSettings)) {
                window.location.href = '404.html';
                return;
            }

            // PASSO 2: Carregar configurações do menu (isto não muda)
            const menuSettings = await loadMenuSettings();
            if (typeof updateMenuVisibility === 'function') {
                updateMenuVisibility(menuSettings);
            }

            // PASSO 3 (CORRIGIDO): Unificar o fluxo para TODOS os utilizadores
            // Removemos a bifurcação 'if (userInfo.estatuto === 'ruler')'.
            // Agora, tanto o ruler como o jogador normal passam pela mesma verificação de clube,
            // que é a lógica correta.
            await checkUserClub(user.uid);

        } catch (error) {
            console.error("Ocorreu um erro crítico durante a inicialização:", error);
            window.location.href = 'index.html';
        }
    } else {
        window.location.href = 'index.html';
    }
});



        async function checkUserClub(userId) {
            const clubDocRef = doc(db, 'endlessclubes', userId);
            const clubSnap = await getDoc(clubDocRef);
            if (clubSnap.exists() && clubSnap.data().ativo) {
                await showDashboard(userId, clubSnap.data());
            } else {
                showCreateClubScreen();
            }
        }

        function showCreateClubScreen() {
            loadingScreen.style.display = 'none';
            createClubContainer.style.display = 'block';
            document.getElementById('save-club-btn').addEventListener('click', handleCreateClub);
        }

function normalizeClubName(name) {
    if (!name) return "";
    return name
        .toLowerCase()              // Converte para minúsculas
        .replace(/\s+/g, '')        // Remove todos os espaços (início, meio, fim)
        .replace(/[^a-z]/g, '');    // Remove tudo o que não for uma letra de 'a' a 'z'
}


function showNotification(title, message) {
    document.getElementById('notification-title').textContent = title;
    document.getElementById('notification-message').textContent = message;
    document.getElementById('notification-popup').style.display = 'flex';
}

// Configurar o fecho do novo pop-up (deve ser executado apenas uma vez)
const notificationPopup = document.getElementById('notification-popup');
if (notificationPopup) {
    document.getElementById('notification-close-btn').addEventListener('click', () => {
        notificationPopup.style.display = 'none';
    });
    // Permite fechar clicando fora da caixa de conteúdo
    notificationPopup.addEventListener('click', (e) => {
        if (e.target === notificationPopup) {
            notificationPopup.style.display = 'none';
        }
    });
}


 async function handleCreateClub() {
    const clubNameInput = document.getElementById('club-name-input');
    const clubName = clubNameInput.value.trim();
    const saveBtn = this; // Referência ao botão

    if (!clubName || clubName.length < 3) {
        showNotification("Nome Inválido", "O nome do clube deve ter pelo menos 3 caracteres.");
        return;
    }
    
    saveBtn.disabled = true;
    saveBtn.textContent = "A Verificar...";

    try {
        const normalizedNewName = normalizeClubName(clubName);

        // 1. Nova Verificação: Compara com a lista de nomes fictícios
        const isFictitious = fictitiousTeamNames.some(name => normalizeClubName(name) === normalizedNewName);
        if (isFictitious) {
            showNotification("Nome Indisponível", "Este nome é muito semelhante a uma equipa já existente na liga. Por favor, escolha outro.");
            saveBtn.disabled = false;
            saveBtn.textContent = "Criar Clube";
            return;
        }

        // 2. Verificação de Duplicados (contra outros jogadores reais)
        const clubsRef = collection(db, 'endlessclubes');
        const q = query(clubsRef);
        const querySnapshot = await getDocs(q);
        let isDuplicate = false;
        querySnapshot.forEach((doc) => {
            const existingName = doc.data().nome;
            if (normalizeClubName(existingName) === normalizedNewName) { isDuplicate = true; }
        });

        if (isDuplicate) {
            showNotification("Nome Indisponível", "Este nome de clube já foi escolhido por outro jogador. Tente outro.");
            saveBtn.disabled = false;
            saveBtn.textContent = "Criar Clube";
            return;
        }

        // 3. Sucesso! Esconde o ecrã atual e chama o popup de seleção
        createClubContainer.style.display = 'none';
        showInitialSquadSelection(auth.currentUser.uid, clubName); // Passa o nome do clube para a próxima fase

    } catch (error) {
        console.error("Erro ao validar nome do clube:", error);
        showNotification("Erro", "Ocorreu um erro ao verificar o nome. Tente novamente.");
        saveBtn.disabled = false;
        saveBtn.textContent = "Criar Clube";
    }
}


// SUBSTITUA A SUA FUNÇÃO INTEIRA POR ESTA
async function showDashboard(userId, clubData) {
    // Guarda os dados do clube numa variável global para acesso fácil por outras funções
    currentUserClubData = clubData;

    // --- GESTÃO DE ESTADO DE RENOVAÇÃO (NOVA LÓGICA DE ALTA PRIORIDADE) ---
    // VERIFICAÇÃO Nº 1: O jogador está obrigado a fazer alterações no clube?
    // Se este estado estiver ativo, a função abre a loja forçada e pára aqui.
    if (clubData.renewalState === 'pendingChoice') {
        loadingScreen.style.display = 'none'; // Esconde o carregamento
        await openRenewalShop(); // Abre a loja em modo forçado
        return; // Interrompe a execução normal da função para não mostrar o dashboard
    }

    // Se a verificação acima passar, o jogo continua a carregar o dashboard normal.
    
    // Preenche os elementos básicos da UI com os dados do clube
    document.getElementById('club-name-header').textContent = clubData.nome;
    shopIcon.style.display = 'flex';
    
    // Renderiza os widgets individuais
    renderSquadWidget(clubData.plantel);
    renderCoachWidget(clubData.treinador);
    renderStadiumWidget(clubData.estadio);
    
    // Obtém a temporada atual para carregar os dados corretos
    const globalConfigSnap = await getDoc(doc(db, 'paineis', 'configuracoes_gerais'));
    const temporada = globalConfigSnap.exists() ? globalConfigSnap.data().temporadaAtual : 'default_season';
    
    // Configura os sistemas restantes do dashboard
    await setupWinningsSystem(userId, clubData, temporada);
    // Carrega a tabela da liga (a variável global 'leagueClubs' será preenchida aqui)
    await assembleLeague(userId, clubData, temporada, true); 
    await setupGrandeJornadaWidget(temporada, 1, userId);
    setupInteractivity(userId, temporada);
    
    // --- LÓGICA DE DECISÃO DE FIM DE TEMPORADA ---
    // VERIFICAÇÃO Nº 2: É o início de um novo mês? Se sim, mostra o pop-up de decisão.
    const now = new Date();
    const lastUpdate = clubData.plantelLastUpdated ? clubData.plantelLastUpdated.toDate() : new Date(0); 
    if (now.getMonth() > lastUpdate.getMonth() || now.getFullYear() > lastUpdate.getFullYear()) {
        const renewalPopup = document.getElementById('monthly-renewal-popup');
        renewalPopup.style.display = 'flex';

        // LÓGICA DO BOTÃO "MANTER E EVOLUIR" (Com a condição de classificação)
        document.getElementById('keep-squad-btn').onclick = async () => {
            const btn = document.getElementById('keep-squad-btn');
            btn.disabled = true;
            btn.textContent = "A Evoluir Equipa...";

            try {
                let updatedSquad = JSON.parse(JSON.stringify(currentUserClubData.plantel));
                let updatedCoach = JSON.parse(JSON.stringify(currentUserClubData.treinador));
                
                // Lógica de evolução do treinador baseada na classificação
                const userRankIndex = leagueClubs.findIndex(club => club.id === userId);
                const userPosition = userRankIndex !== -1 ? userRankIndex + 1 : 20;
                const change = Math.floor(Math.random() * 3) + 2;
                let coachEvolutionMessage = "";

                if (userPosition <= 5) {
                    updatedCoach.quimica += change;
                    coachEvolutionMessage = `Parabéns pelo Top 5! A química do seu treinador aumentou em ${change} pontos!`;
                } else {
                    if (Math.random() < 0.5) {
                        updatedCoach.quimica += change;
                        coachEvolutionMessage = `Apesar de uma temporada difícil, o treinador conseguiu melhorar a sua química em ${change} pontos!`;
                    } else {
                        updatedCoach.quimica -= change;
                        updatedCoach.quimica = Math.max(10, updatedCoach.quimica); 
                        coachEvolutionMessage = `Devido aos resultados, a química do treinador diminuiu em ${change} pontos.`;
                    }
                }
                
                // Lógica de evolução dos jogadores (inalterada)
                updatedSquad.sort(() => 0.5 - Math.random());
                updatedSquad.forEach((player, index) => {
                    const playerChange = Math.floor(Math.random() * 5) + 2;
                    if (index < 4) player.overall += playerChange;
                    else {
                        if (Math.random() < 0.5) player.overall = Math.max(10, player.overall - playerChange);
                        else player.overall += playerChange;
                    }
                });
                
                // Recalcula os totais e guarda no Firebase
                const novoPlantelOverall = updatedSquad.reduce((sum, p) => sum + p.overall, 0);
                const novoOverallTotal = novoPlantelOverall + updatedCoach.overall + currentUserClubData.formacaoatualpontos;
                const novaQuimicaTotal = updatedCoach.quimica + currentUserClubData.estadio.ambiente;
                const novaTemporadaReal = (currentUserClubData.numerorealtemporada || 1) + 1;

                const clubRef = doc(db, 'endlessclubes', userId);
                await setDoc(clubRef, {
                    plantel: updatedSquad, treinador: updatedCoach, plantelLastUpdated: Timestamp.now(),
                    overall: novoOverallTotal, quimica: novaQuimicaTotal, numerorealtemporada: novaTemporadaReal
                }, { merge: true });

                alert(coachEvolutionMessage);
                alert("Equipa evoluída com sucesso para a nova temporada!");
                location.reload();

            } catch (error) {
                console.error("Erro ao evoluir a equipa:", error);
                alert("Ocorreu um erro. Tente novamente.");
                btn.disabled = false;
                btn.textContent = "Manter e Evoluir";
            }
        };

        // LÓGICA DO NOVO BOTÃO "FAZER ALTERAÇÕES"
        document.getElementById('change-squad-btn').onclick = async () => {
            const btn = document.getElementById('change-squad-btn');
            btn.disabled = true;
            btn.textContent = "A Preparar...";

            if (!confirm("Esta opção irá levá-lo à loja, onde terá de adquirir um novo pack (jogadores, treinador ou estádio) para continuar. Tem a certeza?")) {
                btn.disabled = false;
                btn.textContent = "Fazer Alterações";
                return;
            }

            try {
                // Define o estado de 'escolha pendente' no Firebase
                const clubRef = doc(db, 'endlessclubes', userId);
                await updateDoc(clubRef, { renewalState: 'pendingChoice' });
                
                // Recarrega a página. A verificação no início desta função irá apanhar o novo estado.
                location.reload();

            } catch (error) {
                console.error("Erro ao definir o estado de renovação:", error);
                alert("Ocorreu um erro. Tente novamente.");
                btn.disabled = false;
                btn.textContent = "Fazer Alterações";
            }
        };
    } else {
        // Se não for altura de renovação, simplesmente esconde o ecrã de carregamento e mostra o dashboard
        loadingScreen.style.display = 'none';
        dashboardContainer.style.display = 'block';
    }
}




async function openRenewalShop() {
    const shopPopup = document.getElementById('shop-popup');
    
    // Modifica o pop-up para o modo forçado
    shopPopup.querySelector('.popup-close').style.display = 'none'; // Esconde o botão de fechar
    shopPopup.onclick = null; // Remove o evento de fechar ao clicar fora
    const title = shopPopup.querySelector('h2');
    title.textContent = "Faça uma Alteração Estrutural";
    title.insertAdjacentHTML('afterend', '<p style="text-align:center;">Para continuar na nova temporada, deve recrutar um novo pack de jogadores, um novo treinador ou um novo estádio.</p>');

    shopPopup.style.display = 'flex';

    // Substitui os eventos de clique dos packs
    shopPopup.querySelectorAll('.pack-option').forEach(pack => {
        pack.onclick = () => handleRenewalPurchase(pack.dataset.pack);
    });
}

// NOVA FUNÇÃO para processar a substituição e penalização
async function handleRenewalPurchase(packType) {
    if (!confirm(`Tem a certeza que deseja substituir os seus ${packType} atuais? Esta ação aplicará as alterações e penalizações imediatamente.`)) {
        return;
    }

    const shopPopup = document.getElementById('shop-popup');
    shopPopup.innerHTML = `<div class="popup-content" style="text-align: center;"><div class="loading-spinner"></div><h3 style="margin-top:20px;">A aplicar alterações...</h3></div>`;

    try {
        const userId = auth.currentUser.uid;
        const clubRef = doc(db, 'endlessclubes', userId);
        const clubData = currentUserClubData; // Usa os dados já carregados
        let updates = {};
        let finalMessage = "";

        if (packType === 'players') {
            const newPlayers = await generateUniquePlayers();
            updates.plantel = newPlayers;
            
            // Recalcula o overall com os novos jogadores e aplica a penalização
            const newPlantelOverall = newPlayers.reduce((sum, p) => sum + p.overall, 0);
            const coachOverall = clubData.treinador.overall || 0;
            const formationPoints = clubData.formacaoatualpontos || 0;
            // Penalização de -6 no overall
            updates.overall = newPlantelOverall + coachOverall + formationPoints - 6; 
            finalMessage = "Novo plantel recrutado! Foi aplicada uma penalização de -6 ao overall total da equipa devido à reestruturação.";
        } 
        else if (packType === 'coach') {
            const newCoach = await generateRandomCoach();
            updates.treinador = newCoach;

            // Recalcula a química com o novo treinador e aplica a penalização
            const stadiumAmbience = clubData.estadio.ambiente || 0;
             // Penalização de -5 na química
            updates.quimica = newCoach.quimica + stadiumAmbience - 5;
            finalMessage = "Novo treinador contratado! Foi aplicada uma penalização de -5 à química da equipa para refletir o período de adaptação.";
        } 
        else if (packType === 'stadium') {
            const newStadiums = await generateUniqueStadiumOptions(1);
            updates.estadio = { ...newStadiums[0], nivel: 1 }; // Reset para nível 1
            finalMessage = "Novo estádio selecionado! Bem-vindo à sua nova casa.";
        }

        // Remove o estado de pendência e define a data de atualização
        updates.renewalState = admin.firestore.FieldValue.delete();
        updates.plantelLastUpdated = Timestamp.now();

        await updateDoc(clubRef, updates);

        alert(finalMessage);
        location.reload();

    } catch (error) {
        console.error("Erro ao processar a compra de renovação:", error);
        alert("Ocorreu um erro crítico. A página será recarregada.");
        location.reload();
    }
}


async function setupWinningsSystem(userId, clubData, seasonId) {
    // 1. Obter referências para todos os elementos HTML necessários
    const rewardIcon = document.getElementById('points-reward-icon');
    const rewardValueEl = document.getElementById('points-reward-value');
    const claimPopup = document.getElementById('claim-reward-popup');
    const claimAmountEl = document.getElementById('claim-reward-amount');
    const claimBtn = document.getElementById('claim-reward-btn');

    // Se o ícone ou os dados do clube não existirem, não faz nada para evitar erros.
    if (!rewardIcon || !clubData) return;

    // 2. Calcular o dinheiro de performance líquido disponível
    const dayOfMonth = new Date().getDate();
    const currentWeek = Math.floor((dayOfMonth - 1) / 7) + 1;

    const pontos = clubData.pontos || 0;
    const pontosGastos = clubData.pontosGastosNestaTemporada || 0; // Lê quanto já foi gasto
    const recompensaPotencialTotal = Math.floor(pontos / 2);
    const dinheiroDisponivel = recompensaPotencialTotal - pontosGastos; // Calcula o valor líquido

    // 3. Atualizar sempre o ícone para mostrar o valor líquido disponível
    rewardIcon.style.display = 'flex';
    rewardValueEl.textContent = dinheiroDisponivel;

    // 4. Determinar se o prémio pode ser resgatado
    const lastViewed = clubData.lastWeekViewed;
    const hasSimulatedWeek4 = lastViewed && lastViewed.season === seasonId && lastViewed.week === 4;
    const alreadyClaimed = clubData.winningsClaimed === true;
    
    // O prémio é resgatável SE: for a 4ª semana, o utilizador tiver simulado essa semana, E ainda não tiver resgatado.
    const isClaimable = (currentWeek === 4 && hasSimulatedWeek4 && !alreadyClaimed && dinheiroDisponivel > 0);

    if (isClaimable) {
        // Se for resgatável, ativa a animação e a funcionalidade de clique
        rewardIcon.classList.add('is-claimable');
        
        rewardIcon.onclick = () => {
            claimAmountEl.textContent = dinheiroDisponivel; // Mostra o valor a ser resgatado no popup
            claimPopup.style.display = 'flex';
        };

        claimBtn.onclick = async () => {
            claimBtn.disabled = true;
            claimBtn.textContent = "A Processar...";

            try {
                // Chama a Cloud Function segura para processar o pagamento
                const claimReward = firebase.functions().httpsCallable('claimEndlessSeasonWinnings');
                const result = await claimReward();
                
                // Mostra a mensagem de sucesso do backend e recarrega a página
                alert(result.data.message);
                location.reload();

            } catch (error) {
                console.error("Erro ao resgatar prémio:", error);
                alert("Erro: " + error.message); // Mostra o erro ao utilizador
                claimBtn.disabled = false;
                claimBtn.textContent = "Resgatar Recompensa";
            }
        };

    } else {
        // Se não for resgatável, garante que o ícone está estático e sem funcionalidade de clique
        rewardIcon.classList.remove('is-claimable');
        rewardIcon.onclick = null;
    }
    
    // 5. Configurar os métodos para fechar o popup de resgate (deve ser executado sempre)
    const closeBtn = claimPopup.querySelector('.popup-close');
    if(closeBtn) {
        closeBtn.onclick = () => claimPopup.style.display = 'none';
    }
    claimPopup.onclick = (e) => {
         if (e.target === claimPopup) claimPopup.style.display = 'none';
    };
}


      async function showInitialSquadSelection(userId, clubName) {
    const popup = document.getElementById('initial-squad-popup');
    const title = popup.querySelector('h2');
    const packButtonsContainer = document.getElementById('pack-buttons-container');
    const optionsContainer = document.getElementById('squad-options-container');
    const statusText = document.getElementById('squad-selection-status');

    let generatedOptions = [];
    let chosenSquad = null;
    let chosenCoach = null;
    let chosenStadium = null;
    let preGeneratedStadiums = [];

    const allDbPlayerNames = await fetchAllPlayerNamesFromDB();
    const sessionGeneratedPlayerNames = new Set();

    const handlePackOpenClick = async (event) => {
        const button = event.target;
        button.disabled = true;
        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

        let newOption;
        if (!chosenSquad) {
            const namesToExclude = new Set([...allDbPlayerNames, ...sessionGeneratedPlayerNames]);
            newOption = await generateUniquePlayers(namesToExclude);
            newOption.forEach(player => sessionGeneratedPlayerNames.add(normalizePlayerName(player.name)));
        } else if (!chosenCoach) {
            newOption = await generateRandomCoach();
        } else {
            if (preGeneratedStadiums.length > 0) {
                newOption = preGeneratedStadiums.shift();
            } else {
                newOption = { name: "Estádio de Fallback", ambiente: 0 };
            }
        }
        
        generatedOptions.push(newOption);
        renderOptions();
        statusText.textContent = 'Excelente! Reveja as suas opções abaixo e escolha uma para continuar.';
    };

    const setupPackButtons = () => {
        packButtonsContainer.innerHTML = '';
        for (let i = 1; i <= 3; i++) {
            const button = document.createElement('button');
            button.textContent = `Abrir Pack ${i}`;
            button.className = 'pack-opener-btn';
            button.onclick = handlePackOpenClick;
            packButtonsContainer.appendChild(button);
        }
    };
    
    const updateWizardUI = async () => {
        optionsContainer.innerHTML = '';
        packButtonsContainer.style.display = 'flex';
        generatedOptions = [];

        if (!chosenSquad) {
            title.textContent = 'Passo 1: Escolha o Seu Plantel Inicial';
            statusText.textContent = 'Abra os packs para revelar as suas opções de plantel. Depois, escolha uma.';
            setupPackButtons();
        } else if (!chosenCoach) {
            title.textContent = 'Passo 2: Escolha o Seu Treinador';
            statusText.textContent = 'Agora, revele e escolha um treinador para liderar a sua equipa.';
            setupPackButtons();
        } else if (!chosenStadium) {
            title.textContent = 'Passo 3: Escolha o Seu Estádio';
            statusText.textContent = 'Finalmente, descubra e escolha a sua casa.';
            preGeneratedStadiums = await generateUniqueStadiumOptions(3);
            setupPackButtons();
        } else {
            title.textContent = 'Confirme a Fundação do Clube';
            statusText.textContent = 'Excelente! Reveja as suas escolhas. Se estiver tudo correto, clique em "Fundar Clube".';
            packButtonsContainer.style.display = 'none';

            const avgOverall = (chosenSquad.reduce((sum, p) => sum + p.overall, 0) / chosenSquad.length).toFixed(1);
            optionsContainer.innerHTML = `
                <div class="squad-option-card">
                    <h3>Plantel Escolhido</h3>
                    <p>Média de Overall</p>
                    <p style="font-size: 1.4em; font-weight: bold; color: var(--gold-color);">${avgOverall}</p>
                </div>
                <div class="squad-option-card">
                    <h3>Treinador</h3>
                    <p>${chosenCoach.name}</p>
                    <p>Overall: ${chosenCoach.overall}</p>
                </div>
                <div class="squad-option-card">
                    <h3>Estádio</h3>
                    <p>${chosenStadium.name}</p>
                    <p>Nível: 1</p>
                </div>
            `;
            
            const finalBtn = document.createElement('button');
            finalBtn.textContent = 'Fundar Clube';
            finalBtn.className = 'btn-create';
            finalBtn.style.width = '100%';
            finalBtn.style.marginTop = '20px';
            optionsContainer.appendChild(finalBtn);

            finalBtn.onclick = async () => {
                finalBtn.disabled = true;
                const popupContent = popup.querySelector('.popup-content');
                const animationHtml = document.querySelector('[data-content="founding-animation"]').innerHTML;
                popupContent.style.textAlign = 'center';
                popupContent.innerHTML = animationHtml;
        
                try {
                    const batch = writeBatch(db);
                    const { currentGameSeason, seasonIdentifier } = await getGameSeasonInfo();
                    
                    // --- PARTE A: Preparar os dados do clube do utilizador ---
                    const plantelOverall = chosenSquad.reduce((sum, p) => sum + p.overall, 0);
                    const totalOverall = plantelOverall + chosenCoach.overall + 5;
                    const totalQuimica = chosenCoach.quimica + 15;
                    const finalClubData = {
                        nome: clubName,
                        userId: userId,
                        dataDeCriacao: Timestamp.now(),
                        ativo: true,
                        plantel: chosenSquad,
                        treinador: { ...chosenCoach, formacaoAtual: "1-2-2-1" },
                        estadio: { ...chosenStadium, nivel: 1, ambiente: 15 },
                        overall: totalOverall, quimica: totalQuimica,
                        formacaoatualpontos: 5, numerorealtemporada: 1,
                        plantelLastUpdated: Timestamp.now(),
                        pontos: 0, vitorias: 0, empates: 0, derrotas: 0, jogosDisputados: 0,
                        golosMarcados: 0, golosSofridos: 0,
                        temporada: seasonIdentifier, seasonGame: currentGameSeason,
                        estado: "real"
                    };
                    const userClubRef = doc(db, 'endlessclubes', userId);
                    batch.set(userClubRef, finalClubData);
        


                    // --- PARTE B: Verificar a liga e gerar bots se necessário ---
                    const LEAGUE_SIZE = 20;
const clubsRef = collection(db, 'endlessclubes');
const activeClubsQuery = query(clubsRef, where("ativo", "==", true));
const activeClubsSnapshot = await getDocs(activeClubsQuery);
const currentLeagueSize = activeClubsSnapshot.size;

// Cenário 1: A liga está cheia ou a transbordar. É preciso substituir um bot.
if (currentLeagueSize >= LEAGUE_SIZE) {
    console.log("A liga está cheia. A procurar um bot para substituir...");
    
    // Procura por um bot ativo e temporário para desativar
    const botQuery = query(clubsRef, 
        where("estado", "==", "temporario"), 
        where("ativo", "==", true), 
        limit(1) // Apenas precisamos de um
    );
    const botSnapshot = await getDocs(botQuery);

    if (!botSnapshot.empty) {
        // Encontrou um bot, vamos desativá-lo
        const botToRemoveDoc = botSnapshot.docs[0];
        const botRef = doc(db, 'endlessclubes', botToRemoveDoc.id);
        console.log(`Bot encontrado para substituição: ${botToRemoveDoc.id}. A desativá-lo...`);
        
        // Adiciona a operação de atualização ao batch
        batch.update(botRef, { ativo: false });
        
        // Adicional: Chamar a função para anular os resultados dos jogos deste bot
        await adjustGamesForDeactivatedBot(botToRemoveDoc.id, seasonIdentifier);

    } else {
        // Caso raro mas importante: A liga está cheia apenas de jogadores reais.
        console.error("ERRO CRÍTICO: A liga está cheia e não foram encontrados bots para remover.");
        popupContent.innerHTML = `<h3 style="color: #ff6b6b;">Liga Cheia!</h3><p>De momento, a liga está preenchida com 20 jogadores reais. Não é possível entrar. Por favor, tente mais tarde.</p>`;
        return; // Interrompe a execução para não adicionar o 21º jogador.
    }
} 
// Cenário 2: A liga tem espaço. A lógica antiga de preencher com bots aplica-se.
else {
    const botsNeeded = LEAGUE_SIZE - (currentLeagueSize + 1); // +1 para o clube do user
    
    if (botsNeeded > 0) {
        console.log(`A gerar ${botsNeeded} bots para completar a liga...`);
        const allDbPlayerNames = await fetchAllPlayerNamesFromDB();
        const stadiumOptions = await generateUniqueStadiumOptions(botsNeeded);
        
        const shuffledFictitiousNames = fictitiousTeamNames.sort(() => 0.5 - Math.random());

        for (let i = 0; i < botsNeeded; i++) {
            const botSquad = await generateUniquePlayers(allDbPlayerNames);
            botSquad.forEach(player => allDbPlayerNames.add(normalizePlayerName(player.name)));
            const botCoach = await generateRandomCoach();
            const botStadium = stadiumOptions[i] || { name: `Estádio Bot ${Date.now() + i}`};
            const botPlantelOverall = botSquad.reduce((sum, p) => sum + p.overall, 0);
            const botTotalOverall = botPlantelOverall + botCoach.overall + 5;
            const botTotalQuimica = botCoach.quimica + 15;
            const botName = shuffledFictitiousNames[i % shuffledFictitiousNames.length] || `Bot Team ${i}`;

            const newBotData = {
                nome: botName,
                userId: null, dataDeCriacao: Timestamp.now(), ativo: true, plantel: botSquad,
                treinador: { ...botCoach, formacaoAtual: "1-2-2-1" },
                estadio: { ...botStadium, nivel: 1, ambiente: 15 },
                overall: botTotalOverall, quimica: botTotalQuimica, formacaoatualpontos: 5,
                numerorealtemporada: 1, plantelLastUpdated: Timestamp.now(),
                pontos: 0, vitorias: 0, empates: 0, derrotas: 0, jogosDisputados: 0,
                golosMarcados: 0, golosSofridos: 0,
                temporada: seasonIdentifier, seasonGame: currentGameSeason, estado: "temporario"
            };
            const newBotRef = doc(collection(db, 'endlessclubes'));
                 batch.set(newBotRef, newBotData);
        }
    }
}
  
                    // --- PARTE C: Executar todas as operações de uma vez ---
                    await batch.commit();
                    
                    setTimeout(() => location.reload(), 2000);
                } catch (error) {
                    console.error("Erro ao fundar o clube e gerar a liga:", error);
                    popupContent.innerHTML = `<p style="color: #ff6b6b;">Ocorreu um erro crítico. Por favor, tente novamente.</p>`;
                }
            };
        }
    };

    const renderOptions = () => {
        optionsContainer.innerHTML = '';
        if (!chosenSquad) {
            generatedOptions.forEach((squad, index) => {
                let playersHtml = squad.map(p => `<div class="player-entry"><span>${p.position} - ${p.name.split(' ')[0]}</span><span class="overall">${p.overall}</span></div>`).join('');
                optionsContainer.innerHTML += `<div class="squad-option-card"><h3>Opção de Plantel</h3><div class="players-list">${playersHtml}</div><button class="btn-create choose-btn" data-index="${index}">Escolher Plantel</button></div>`;
            });
        } else if (!chosenCoach) {
                generatedOptions.forEach((coach, index) => {
                optionsContainer.innerHTML += `<div class="squad-option-card"><h3>Opção de Treinador</h3><p>${coach.name}</p><p>Overall: <span class="overall">${coach.overall}</span></p><button class="btn-create choose-btn" data-index="${index}">Escolher Treinador</button></div>`;
            });
        } else if (!chosenStadium) {
            generatedOptions.forEach((stadium, index) => {
                optionsContainer.innerHTML += `<div class="squad-option-card"><h3>Opção de Estádio</h3><p>${stadium.name}</p><p>Nível: <span class="overall">1</span></p><button class="btn-create choose-btn" data-index="${index}">Escolher Estádio</button></div>`;
            });
        }

        document.querySelectorAll('.choose-btn').forEach(button => {
            button.onclick = async (e) => {
                const chosenIndex = parseInt(e.target.dataset.index, 10);
                if (!chosenSquad) {
                    chosenSquad = generatedOptions[chosenIndex];
                } else if (!chosenCoach) {
                    chosenCoach = generatedOptions[chosenIndex];
                } else {
                    chosenStadium = generatedOptions[chosenIndex];
                }
                await updateWizardUI();
            };
        });
    };

    popup.style.display = 'flex';
    updateWizardUI();
}



        function normalizePlayerName(name) {
    if (!name) return "";
    // Remove acentos, converte para minúsculas e remove tudo o que não for letra
    return name
        .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
        .toLowerCase()
        .replace(/[^a-z]/g, '');
}

// NOVA FUNÇÃO para carregar todos os nomes de jogadores da base de dados
async function fetchAllPlayerNamesFromDB() {
    const playerNames = new Set();
    const clubsQuery = query(collection(db, 'endlessclubes'));
    try {
        const querySnapshot = await getDocs(clubsQuery);
        querySnapshot.forEach(doc => {
            const clubData = doc.data();
            if (clubData.plantel && Array.isArray(clubData.plantel)) {
                clubData.plantel.forEach(player => {
                    if (player.name) {
                        playerNames.add(normalizePlayerName(player.name));
                    }
                });
            }
        });
        console.log(`Carregados ${playerNames.size} nomes de jogadores únicos da base de dados.`);
        return playerNames;
    } catch (error) {
        console.error("Erro ao carregar os nomes dos jogadores da base de dados:", error);
        return playerNames; // Retorna um set vazio em caso de erro
    }
}


 function render3DStadium(stadium, containerId) {
            const container = document.getElementById(containerId);
            if (!container || !stadium) return;

            const nivel = stadium.nivel || 1;
            
            let stadiumHTML = `<div class="stadium-scene">
                <div class="stadium-pitch">
                    <div class="stadium-goal goal-north"></div>
                    <div class="stadium-goal goal-south"></div>
                    <div class="player-marker team-a" style="top: 25%; left: 30%;"></div>
                    <div class="player-marker team-a" style="top: 45%; left: 60%;"></div>
                    <div class="player-marker team-b" style="top: 65%; left: 40%;"></div>
                    <div class="player-marker team-a" style="top: 75%; left: 20%;"></div>
                    <div class="player-marker team-b" style="top: 50%; left: 15%;"></div>
                    <div class="animated-ball"></div>
                </div>`;

            if (nivel > 1) {
                let flashesHTML = '';
                const numberOfFlashes = 25;

                for (let i = 0; i < numberOfFlashes; i++) {
                    const top = Math.random() * 100;
                    const left = Math.random() * 100;
                    const delay = Math.random() * 5;
                    
                    flashesHTML += `<div class="camera-flash" style="top: ${top}%; left: ${left}%; animation-delay: ${delay}s;"></div>`;
                }

                // A única alteração está aqui: envolvemos o flashesHTML no novo container.
                const flashContainer = `<div class="flash-container">${flashesHTML}</div>`;

                stadiumHTML += `
                    <div class="stadium-stand stand-north level-${nivel}">${flashContainer}</div>
                    <div class="stadium-stand stand-south level-${nivel}">${flashContainer}</div>
                    <div class="stadium-stand stand-west level-${nivel}">${flashContainer}</div>
                    <div class="stadium-stand stand-east level-${nivel}">${flashContainer}</div>
                `;
            }

            if (nivel === 4) {
                stadiumHTML += `
                    <div class="stadium-floodlight-pylon pylon-nw"></div>
                    <div class="stadium-floodlight-pylon pylon-ne"></div>
                    <div class="stadium-floodlight-pylon pylon-sw"></div>
                    <div class="stadium-floodlight-pylon pylon-se"></div>
                `;
            } else if (nivel >= 5) {
                stadiumHTML += `
                    <div class="stadium-roof-structure roof level-${nivel}">
                        <div class="roof-panel roof-panel-a"></div>
                        <div class="roof-panel roof-panel-b"></div>
                    </div>
                `;
            }

            stadiumHTML += `</div>`;
            container.innerHTML = stadiumHTML;
        }
        
        function renderSquadWidget(squad) {
            const container = document.getElementById('squad-summary-container');
            const countEl = document.getElementById('squad-player-count');
            if (!squad || squad.length === 0) {
                container.innerHTML = '<p>Sem jogadores.</p>';
                countEl.textContent = '0/6 Jogadores';
                return;
            }
            let squadHtml = '';
            let totalOverall = 0;
            squad.forEach(player => {
                totalOverall += player.overall;
                const positionColor = {'GR': '#e67e22', 'DEF': '#3498db', 'MED': '#2ecc71', 'AVA': '#e74c3c'};
                const initials = player.name.split(' ').map(n => n[0]).join('');
                squadHtml += `<div title="${player.name} (${player.position}) - Overall: ${player.overall}" style="width: 50px; height: 50px; border-radius: 50%; background-color: ${positionColor[player.position] || '#7f8c8d'}; display: flex; align-items: center; justify-content: center; font-weight: bold; border: 2px solid var(--accent-color);">${initials}</div>`;
            });
            container.innerHTML = squadHtml;
            const avgOverall = (totalOverall / squad.length).toFixed(1);
            countEl.innerHTML = `${squad.length}/6 Jogadores <br> (Overall Médio: ${avgOverall})`;
        }

        function renderCoachWidget(coach) {
            const coachWidgetContent = document.querySelector('.widget-card[data-widget="coach"] .widget-content');
            if (coachWidgetContent && coach) {
                const mainText = coachWidgetContent.querySelector('.card-main-text');
                const subText = coachWidgetContent.querySelector('.card-sub-text');
                mainText.textContent = coach.name;
                subText.innerHTML = `Overall: <b style="color: var(--gold-color);">${coach.overall}</b> | Química: <b style="color: var(--gold-color);">${coach.quimica}</b>`;
            }
        }

      function renderStadiumWidget(stadium) {
    const stadiumWidgetContent = document.querySelector('.widget-card[data-widget="stadium"] .widget-content');
    if (stadiumWidgetContent && stadium) {
        const mainText = stadiumWidgetContent.querySelector('.card-main-text');
        const subText = stadiumWidgetContent.querySelector('.card-sub-text');
        
        // --- ALTERAÇÃO AQUI ---
        // Em vez de calcular, lemos diretamente o nível do estádio guardado no Firebase.
        const nivel = stadium.nivel || 1; // Lê stadium.nivel, com fallback para 1 se não existir.
        
        mainText.textContent = stadium.name;
        subText.innerHTML = `Nível do Estádio: <b style="color: var(--gold-color);">${nivel}</b>`;
        
        // A renderização 3D precisa de ser ajustada para usar o nível real também.
        render3DStadium(stadium, 'stadium-widget-render-area');
    }
}

// SUBSTITUA A SUA FUNÇÃO INTEIRA POR ESTA
async function assembleLeague(userId, userClubData, temporada, userHasAlreadyViewed) {
    // A lógica do listener em tempo real continua a ser controlada por esta flag
    allowRealtimeLeagueRender = userHasAlreadyViewed;
    const q = query(collection(db, 'endlessclubes'), where("temporada", "==", temporada), where("ativo", "==", true));

    // Desliga qualquer listener anterior
    if (leagueListener) leagueListener(); 

    try {
        if (userHasAlreadyViewed) {
            // LÓGICA ANTIGA (CORRETA PARA ESTE CASO): Se já viu, mostra os dados atuais e ouve por updates.
            console.log("Modo Classificação: Ao Vivo");
            const initialSnapshot = await getDocs(q);
            leagueClubs = initialSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            renderLeagueTable(leagueClubs, userId);
        } else {
            // NOVA LÓGICA: Se ainda não viu, chama a nossa função para "rebobinar" o tempo.
            console.log("Modo Classificação: Congelado (Reconstruído)");
            const frozenClubs = await getFrozenLeagueTable(temporada);
            leagueClubs = frozenClubs;
            renderLeagueTable(leagueClubs, userId);
        }

        // O listener em tempo real continua a ser anexado em ambos os casos.
        // Ele atualiza a tabela "escondida" (liveLeagueClubs) e só afeta a tabela visível
        // se e quando `allowRealtimeLeagueRender` for verdadeiro (o que só acontecerá no próximo reload).
        leagueListener = onSnapshot(q, (querySnapshot) => {
            liveLeagueClubs = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            if (allowRealtimeLeagueRender) {
                leagueClubs = [...liveLeagueClubs];
                renderLeagueTable(leagueClubs, userId);
            }
        }, (error) => {
            console.error("Erro no listener da liga:", error);
        });

    } catch (error) {
        console.error("Erro ao montar a liga:", error);
    }
}



function renderLeagueTable(clubs, userId) {
    const tableBody = document.getElementById('league-table-body');
    const tableBodyPopup = document.getElementById('league-table-body-popup');
    let tableHTML = '';

    // Ordenar por pontos, depois por diferença de golos, depois por golos marcados
    clubs.sort((a, b) => {
        const pointsDiff = (b.pontos || 0) - (a.pontos || 0);
        if (pointsDiff !== 0) return pointsDiff;

        const goalDiffA = (a.golosMarcados || 0) - (a.golosSofridos || 0);
        const goalDiffB = (b.golosMarcados || 0) - (b.golosSofridos || 0);
        const goalDiff = goalDiffB - goalDiffA;
        if (goalDiff !== 0) return goalDiff;

        return (b.golosMarcados || 0) - (a.golosMarcados || 0);
    });

    clubs.forEach((club, index) => {
        const isUser = club.id === userId;
        tableHTML += `
            <tr ${isUser ? 'class="user-team-row"' : ''}>
                <td>${index + 1}</td>
                <td>${club.nome}</td>
                <td><b>${club.pontos || 0}</b></td>
                <td>${club.jogosDisputados || 0}</td>
                <td>${club.vitorias || 0}</td>
                <td>${club.empates || 0}</td>
                <td>${club.derrotas || 0}</td>
                <td>${club.golosMarcados || 0}</td>
                <td>${club.golosSofridos || 0}</td>
            </tr>`;
    });
    
    tableBody.innerHTML = tableHTML;
    tableBodyPopup.innerHTML = tableHTML;
    
    // --- LÓGICA DE SCROLL CORRIGIDA COM setTimeout ---
    // Adicionamos um pequeno atraso para garantir que o navegador já renderizou a tabela
    // antes de tentarmos calcular as posições dos elementos.
    setTimeout(() => {
        const scrollContainer = tableBody.closest('.widget-content');
        const userRow = tableBody.querySelector('.user-team-row');

        // A lógica de cálculo permanece a mesma, mas agora será executada no momento certo.
        if (userRow && scrollContainer) {
            const scrollTarget = userRow.offsetTop - (scrollContainer.clientHeight / 2) + (userRow.clientHeight / 2);
            
            scrollContainer.scrollTo({
                top: scrollTarget,
                behavior: 'smooth'
            });
        }
    }, 100); // Um atraso de 100 milissegundos é suficiente para o navegador renderizar.
}



    async function renderMatchResults(containerElement, userId, seasonId) {
    if (!containerElement) return;
    
    containerElement.innerHTML = '<div class="loading-spinner" style="width:40px; height:40px; border-width: 6px; margin-top: 20px;"></div>';

    try {
        // CORREÇÃO: Utiliza o 'seasonId' recebido como argumento.
        const dayOfMonth = new Date().getDate();
        const semanaAtual = Math.floor((dayOfMonth - 1) / 7) + 1;
        const startJornada = (semanaAtual - 1) * 7 + 1;
        const endJornada = startJornada + 6;

        const weekGamesQuery = query(collection(db, "endlessjogos"),
            where("seasonId", "==", seasonId),
            where("jornada", ">=", startJornada),
            where("jornada", "<=", endJornada));
        
        const weekGamesSnapshot = await getDocs(weekGamesQuery);

        // O resto da lógica da função permanece inalterada
        const promises = weekGamesSnapshot.docs.map(async (gameDoc) => {
            const gameData = gameDoc.data();
            const homeDocRef = doc(db, 'endlessclubes', gameData.homeTeamId);
            const awayDocRef = doc(db, 'endlessclubes', gameData.awayTeamId);
            const [homeDoc, awayDoc] = await Promise.all([getDoc(homeDocRef), getDoc(awayDocRef)]);
            const homeName = homeDoc.exists() ? homeDoc.data().nome : "Clube Desconhecido";
            const awayName = awayDoc.exists() ? awayDoc.data().nome : "Clube Desconhecido";
            return { ...gameData, homeTeam: homeName, awayTeam: awayName };
        });

        const gamesWithNames = await Promise.all(promises);
        let resultsHTML = '';
        if (gamesWithNames.length === 0) {
            resultsHTML = '<p style="text-align:center; padding: 20px;">Ainda não há jogos simulados para esta semana.</p>';
        } else {
            const gamesByJornada = {};
            gamesWithNames.forEach(game => {
                if (!gamesByJornada[game.jornada]) gamesByJornada[game.jornada] = [];
                gamesByJornada[game.jornada].push(game);
            });

            Object.keys(gamesByJornada).sort((a, b) => a - b).forEach(jornada => {
                resultsHTML += `<h5 style="text-align:center; margin:10px 0; color:var(--accent-color);">Jornada ${jornada}</h5>`;
                gamesByJornada[jornada].forEach(game => {
                    const isUserMatch = (game.homeTeamId === userId || game.awayTeamId === userId);
                    
               const matchClass = isUserMatch ? 'match-result user-match' : 'match-result';
                    resultsHTML += `<div class="${matchClass}"><span class="team-home">${game.homeTeam}</span><b>${game.homeScore} - ${game.awayScore}</b><span class="team-away">${game.awayTeam}</span></div>`;
                });
            });
        }
        containerElement.innerHTML = resultsHTML;

    } catch (error) {
        console.error("[ERRO EM renderMatchResults] A consulta falhou.", error);
        containerElement.innerHTML = `<p style="color: #ff6b6b; padding: 10px;">Ocorreu um erro ao carregar os resultados.</p>`;
    }
}


 async function setupGrandeJornadaWidget(seasonId, week, userId) {
    const preSimContent = document.getElementById('pre-simulation-content');
    const resultsContainerWidget = document.getElementById('grande-jornada-results');
    const simulateBtnWidget = document.getElementById('simulate-week-btn-widget');
    const weekTitle = document.getElementById('grande-jornada-week');

    const dayOfMonth = new Date().getDate();
    const semanaAtual = Math.floor((dayOfMonth - 1) / 7) + 1;
    weekTitle.textContent = `Semana ${semanaAtual} de 4`;

    // A variável global 'currentUserClubData' já está preenchida neste ponto
    const lastViewed = currentUserClubData?.lastWeekViewed;
    
    // A condição para determinar se o utilizador já viu os resultados desta semana
    const userHasAlreadyViewed = lastViewed && lastViewed.season === seasonId && lastViewed.week === semanaAtual;
    
    if (userHasAlreadyViewed) {
        // Se já viu, esconde o botão de simulação e mostra os resultados diretamente
        preSimContent.style.display = 'none';
        resultsContainerWidget.style.display = 'block';
        renderMatchResults(resultsContainerWidget, userId, seasonId);
    } else {
        // Se ainda não viu, verifica se os jogos já foram gerados para decidir o estado do botão
        const jornadaInicialDaSemana = (semanaAtual - 1) * 7 + 1;
        const q = query(collection(db, "endlessjogos"), where("seasonId", "==", seasonId), where("jornada", "==", jornadaInicialDaSemana));
        const querySnapshot = await getDocs(q);

        if (!querySnapshot.empty) {
            preSimContent.style.display = 'flex';
            resultsContainerWidget.style.display = 'none';
            
            const endlessConfigSnap = await getDoc(doc(db, 'paineis', 'endless_configuracoes'));
            const ultimaSemanaSimulada = endlessConfigSnap.exists() ? endlessConfigSnap.data().ultimaSemanaSimulada || 0 : 0;

            // Ativa ou desativa o botão com base no painel de controlo
            if (ultimaSemanaSimulada >= semanaAtual) {
                simulateBtnWidget.disabled = false;
                simulateBtnWidget.innerHTML = '<i class="fas fa-play-circle"></i> Ver/Simular Semana';
            } else {
                simulateBtnWidget.disabled = true;
                simulateBtnWidget.innerHTML = '<i class="fas fa-clock"></i> Aguardando Simulação';
            }
        } else {
             preSimContent.style.display = 'flex';
             resultsContainerWidget.style.display = 'none';
             simulateBtnWidget.disabled = true;
             simulateBtnWidget.innerHTML = '<i class="fas fa-clock"></i> Aguardando Simulação';
        }
    }
}


async function getFrozenLeagueTable(seasonId) {
    try {
        // 1. Obter o estado atual e completo da liga (com spoilers)
        const clubsQuery = query(collection(db, 'endlessclubes'), where("temporada", "==", seasonId), where("ativo", "==", true));
        const clubsSnapshot = await getDocs(clubsQuery);
        
        // Usar um Map para acesso rápido aos clubes por ID, é muito mais eficiente
        const clubsMap = new Map();
        clubsSnapshot.forEach(doc => {
            // Criamos uma cópia para não modificar os dados originais em cache
            clubsMap.set(doc.id, { id: doc.id, ...doc.data() });
        });

        // 2. Obter os jogos da semana atual que precisam de ser "desfeitos"
        const dayOfMonth = new Date().getDate();
        const semanaAtual = Math.floor((dayOfMonth - 1) / 7) + 1;
        const startJornada = (semanaAtual - 1) * 7 + 1;
        const endJornada = startJornada + 6;

        const weekGamesQuery = query(collection(db, "endlessjogos"),
            where("seasonId", "==", seasonId),
            where("jornada", ">=", startJornada),
            where("jornada", "<=", endJornada));
        const weekGamesSnapshot = await getDocs(weekGamesQuery);

        // 3. Reverter as estatísticas para cada jogo encontrado
        weekGamesSnapshot.forEach(gameDoc => {
            const gameData = gameDoc.data();
            const homeTeam = clubsMap.get(gameData.homeTeamId);
            const awayTeam = clubsMap.get(gameData.awayTeamId);

            if (homeTeam && awayTeam) {
                // Reverter estatísticas básicas
                homeTeam.jogosDisputados -= 1;
                awayTeam.jogosDisputados -= 1;
                homeTeam.golosMarcados -= gameData.homeScore;
                homeTeam.golosSofridos -= gameData.awayScore;
                awayTeam.golosMarcados -= gameData.awayScore;
                awayTeam.golosSofridos -= gameData.homeScore;

                // Reverter pontos, vitórias, empates e derrotas
                if (gameData.homeScore > gameData.awayScore) { // Vitória em casa
                    homeTeam.pontos -= 3;
                    homeTeam.vitorias -= 1;
                    awayTeam.derrotas -= 1;
                } else if (gameData.awayScore > gameData.homeScore) { // Vitória fora
                    awayTeam.pontos -= 3;
                    awayTeam.vitorias -= 1;
                    homeTeam.derrotas -= 1;
                } else { // Empate
                    homeTeam.pontos -= 1;
                    homeTeam.empates -= 1;
                    awayTeam.pontos -= 1;
                    awayTeam.empates -= 1;
                }
            }
        });

        // 4. Retornar a lista de clubes com os dados "congelados"
        return Array.from(clubsMap.values());

    } catch (error) {
        console.error("Erro ao reconstruir a tabela de classificação congelada:", error);
        return []; // Retorna uma lista vazia em caso de erro
    }
}
 
        
 function setupInteractivity(userId, seasonId) {
    document.getElementById('simulate-week-btn-widget')?.addEventListener('click', (event) => handleSimulationClick(event));

    const widgetPopup = document.getElementById('widget-popup');

    document.querySelectorAll('.expand-icon').forEach(icon => {
        icon.addEventListener('click', async (e) => {
            const widgetCard = e.target.closest('.widget-card');
            const widget = widgetCard.dataset.widget;
            const popupBody = document.getElementById('popup-body');
            const popupContent = widgetPopup.querySelector('.popup-content');

            popupBody.innerHTML = ''; 

            if (widget === 'squad') {
                const content = document.querySelector('#widget-details [data-content="squad"]');
                if (content && currentUserClubData && currentUserClubData.plantel) {
                    popupBody.innerHTML = content.innerHTML;
                    const formationString = currentUserClubData.treinador.formacaoAtual || "1-2-2-1";
                    document.getElementById('popup-title').textContent = `O Meu Plantel (Tática: ${formationString})`;

                    const pitchAreas = {
                        goalkeeper: popupBody.querySelector('.goalkeeper-area'),
                        defense: popupBody.querySelector('.defense-area'),
                        midfield: popupBody.querySelector('.midfield-area'),
                        attack: popupBody.querySelector('.attack-area')
                    };
                    
                     Object.values(pitchAreas).forEach(area => { if(area) area.innerHTML = '' });

                    // --- ALGORITMO DE PRIORIDADE POSICIONAL ---

                    // 1. Obter os requisitos da formação
                    const formationParts = formationString.split('-').slice(1).map(num => parseInt(num, 10));
                    const [defNeeded = 0, medNeeded = 0, avaNeeded = 0] = formationParts;

                    // 2. Criar um "pool" único de jogadores de campo, ordenados por prioridade defensiva
                    const players = currentUserClubData.plantel;
                    const goalkeepers = players.filter(p => p.position === 'GR');
                    const defenders = players.filter(p => p.position === 'DEF');
                    const midfielders = players.filter(p => p.position === 'MED');
                    const attackers = players.filter(p => p.position === 'AVA');
                    
                    // A ordem de concatenação aqui é a chave: Defesas primeiro, Médios a seguir, Avançados no fim.
                    let fieldPlayersPool = [...defenders, ...midfielders, ...attackers];

                    // 3. "Convocar" os jogadores para cada linha do campo a partir do "pool" ordenado
                    // O método slice pega uma "fatia" do array sem o destruir.
                    const formationDefenders = fieldPlayersPool.slice(0, defNeeded);
                    const formationMidfielders = fieldPlayersPool.slice(defNeeded, defNeeded + medNeeded);
                    const formationAttackers = fieldPlayersPool.slice(defNeeded + medNeeded, defNeeded + medNeeded + avaNeeded);
                    
                    // 4. Função para desenhar os jogadores nas suas linhas corretas
                    const distributePlayers = (area, playerList) => {
                        if (!area) return;
                        playerList.forEach(player => {
                            const playerDot = document.createElement('div');
                            playerDot.className = 'player-dot';
                            playerDot.dataset.position = player.position; // Mantém a cor original do jogador
                            playerDot.textContent = player.overall;
                            
                            const tooltip = document.createElement('span');
                            tooltip.className = 'player-name-tooltip';
                            tooltip.textContent = `${player.name} (${player.position})`;
                            
                            playerDot.appendChild(tooltip);
                            area.appendChild(playerDot);
                        });
                    };

                    // 5. Desenhar a formação final no campo
                    distributePlayers(pitchAreas.goalkeeper, goalkeepers);
                    distributePlayers(pitchAreas.defense, formationDefenders);
                    distributePlayers(pitchAreas.midfield, formationMidfielders);
                    distributePlayers(pitchAreas.attack, formationAttackers);
                }
            }
            
            else if (widget === 'stadium') { await openStadiumPopup(popupBody); } 
            else if (widget === 'coach') { await openCoachPopup(popupBody); } 
            
            else if (widget === 'match') {
              const lastViewed = currentUserClubData?.lastWeekViewed;
        const dayOfMonth = new Date().getDate();
        const semanaAtual = Math.floor((dayOfMonth - 1) / 7) + 1;
        const userHasAlreadyViewed = lastViewed && lastViewed.season === seasonId && lastViewed.week === semanaAtual;

        if (userHasAlreadyViewed) {
            // Se o utilizador já viu, mostramos os resultados
            popupBody.innerHTML = '<div id="popup-match-results" class="match-results-container"></div>';
            const popupResultsContainer = popupBody.querySelector('#popup-match-results');
            renderMatchResults(popupResultsContainer, userId, seasonId);
        } else {
            // Se ainda não viu, mostramos uma mensagem de instrução
            popupBody.innerHTML = `
                <div style="text-align:center; padding: 40px 20px;">
                    <i class="fas fa-eye-slash card-big-icon"></i>
                    <p class="card-main-text" style="margin-top: 15px;">
                        Clique primeiro no botão "Ver/Simular Semana" no widget principal para revelar os resultados.
                    </p>
                </div>
            `;
        }
        // --- FIM DA CORREÇÃO ---
    }

            else if (widget === 'league') {
                document.getElementById('popup-title').textContent = "Classificação Completa";
                const content = document.querySelector('#widget-details [data-content="league"]');
                if (content) {
                    popupBody.innerHTML = content.innerHTML;
                    const popupTableBody = popupBody.querySelector('#league-table-body-popup');
                    if(popupTableBody) {
                        popupTableBody.innerHTML = document.getElementById('league-table-body').innerHTML;
                        popupTableBody.addEventListener('click', handleTeamRowClick);
                    }
                }
            }
            
            widgetPopup.style.display = 'flex';
            if (popupContent) popupContent.scrollTop = 0;
        });
    });

    const closePopup = (p) => () => p.style.display = 'none';
    const closeOnClickOutside = (p) => (e) => { if (e.target === p) p.style.display = 'none'; };

    [widgetPopup, shopPopup, document.getElementById('pack-opening-popup'), document.getElementById('initial-squad-popup')].forEach(p => {
        if(p) {
            p.querySelector('.popup-close')?.addEventListener('click', closePopup(p));
            p.addEventListener('click', closeOnClickOutside(p));
        }
    });

shopIcon.addEventListener('click', () => {
    // Em vez de abrir a loja, agora mostra uma notificação informativa.
    showNotification("Mercado Fechado", "O mercado de alterações estruturais só abre no final da temporada, quando a opção 'Fazer Alterações' estiver disponível.");
});

    document.getElementById('league-table-body').addEventListener('click', handleTeamRowClick);
}




async function openStadiumPopup(popupBody) {
    const content = document.querySelector('#widget-details [data-content="stadium"]');
    if (content) popupBody.innerHTML = content.innerHTML;
    
    render3DStadium(currentUserClubData.estadio, 'stadium-3d-container');
    document.getElementById('popup-title').textContent = `Estádio (Nível ${currentUserClubData.estadio.nivel})`;

    const stadiumInfoRef = doc(db, 'paineis', 'infoestadios');
    const stadiumInfoSnap = await getDoc(stadiumInfoRef);
    const niveisEstadio = stadiumInfoSnap.data().niveis;

    const upgradeBtn = document.getElementById('upgrade-stadium-btn');
    const statusText = upgradeBtn.nextElementSibling;

    // --- LÓGICA DE CUSTO ---
    const pontosGastos = currentUserClubData.pontosGastosNestaTemporada || 0;
    const dinheiroDisponivel = Math.floor((currentUserClubData.pontos || 0) / 2) - pontosGastos;
    const custoBase = Math.floor(dinheiroDisponivel * (2/3));
    const custoFinal = Math.max(45, custoBase);
    
    // Mostra o dinheiro disponível no popup para o utilizador
    statusText.innerHTML = `<b>Dinheiro de Performance Disponível: ${dinheiroDisponivel}</b><br><br>Aqui poderá ver o seu estádio...`;
    // --- FIM DA LÓGICA DE CUSTO ---

    const currentLevel = currentUserClubData.estadio.nivel;
    const currentSeason = currentUserClubData.numerorealtemporada;
    const nextLevel = currentLevel + 1;

    if (niveisEstadio[nextLevel]) {
        const requiredSeason = niveisEstadio[nextLevel].temporadaReq;
        if (currentSeason >= requiredSeason) {
            if (dinheiroDisponivel >= custoFinal) {
                upgradeBtn.disabled = false;
                upgradeBtn.textContent = `Melhorar para Nível ${nextLevel} (Custo: ${custoFinal})`;
            } else {
                upgradeBtn.disabled = true;
                upgradeBtn.textContent = `Fundos Insuficientes (Precisa de ${custoFinal})`;
            }
        } else {
            upgradeBtn.disabled = true;
            upgradeBtn.textContent = `Desbloqueia na Temporada ${requiredSeason}`;
        }
    } else {
        upgradeBtn.disabled = true;
        upgradeBtn.textContent = 'Nível Máximo Atingido';
    }

    upgradeBtn.onclick = async () => {
        upgradeBtn.disabled = true;
        upgradeBtn.textContent = 'A Processar Compra...';

        try {
            const purchase = firebase.functions().httpsCallable('purchaseUpgrade');
            const result = await purchase({ upgradeType: 'stadium' });
            alert(result.data.message);
            location.reload(); // Recarrega para refletir as mudanças
        } catch (error) {
            console.error("Erro ao comprar melhoria de estádio:", error);
            alert("Erro: " + error.message);
            // Recarrega o popup para reverter para o estado anterior
            await openStadiumPopup(popupBody);
        }
    };
}


async function openCoachPopup(popupBody) {
    const coach = currentUserClubData.treinador;
    const contentTemplate = document.querySelector('#widget-details [data-content="coach"]');
    popupBody.innerHTML = contentTemplate ? contentTemplate.innerHTML : '<p>Detalhes do treinador.</p>';
    document.getElementById('popup-title').textContent = "Treinador e Táticas";

    // Obter as regras das formações do Firebase (master list)
    const formationsInfoRef = doc(db, 'paineis', 'infoformacoes');
    const formationsInfoSnap = await getDoc(formationsInfoRef);
    if (!formationsInfoSnap.exists()) {
        popupBody.innerHTML = '<p>Erro: Não foi possível carregar as informações das táticas.</p>';
        return;
    }
    const formacoes = formationsInfoSnap.data().formacoes;

    const currentSeason = currentUserClubData.numerorealtemporada;
    const activeFormation = coach.formacaoAtual;
    
    // --- LÓGICA DE CUSTO (calculada uma vez no início) ---
    const pontosGastos = currentUserClubData.pontosGastosNestaTemporada || 0;
    const dinheiroDisponivel = Math.floor((currentUserClubData.pontos || 0) / 2) - pontosGastos;
    const custoBase = Math.floor(dinheiroDisponivel * (2/3));
    const custoFinal = Math.max(45, custoBase); // Custo mínimo de 45

    // --- CONSTRUÇÃO DINÂMICA DOS BOTÕES ---
    let tacticsHtml = `<div class="tactic-selection-container">
        <h4>Táticas Disponíveis (Dinheiro de Performance: ${dinheiroDisponivel})</h4>`;
    
    const formacoesPossuidas = coach.formacoesDisponiveis || [];

    Object.entries(formacoes).forEach(([formation, data]) => {
        const isUnlockedBySeason = currentSeason >= data.temporadaReq;
        const isOwned = formacoesPossuidas.includes(formation);

        if (isOwned) {
            // Caso 1: O utilizador JÁ POSSUI a tática
            const isActive = formation === activeFormation;
            tacticsHtml += `<button class="tactic-btn ${isActive ? 'active-tactic' : ''}" 
                                    data-formation="${formation}" 
                                    ${isActive ? 'disabled' : ''}>${formation}</button>`;
        } else if (isUnlockedBySeason) {
            // Caso 2: A tática está DESBLOQUEADA pela temporada, mas não foi comprada
            if (dinheiroDisponivel >= custoFinal) {
                // Tem dinheiro para comprar
                tacticsHtml += `<button class="tactic-btn buy-tactic-btn" data-formation="${formation}">Comprar ${formation} (Custo: ${custoFinal})</button>`;
            } else {
                // Não tem dinheiro suficiente
                tacticsHtml += `<button class="tactic-btn" disabled 
                                        title="Fundos Insuficientes. Precisa de ${custoFinal}.">Comprar ${formation}</button>`;
            }
        } else {
            // Caso 3: A tática está BLOQUEADA
            tacticsHtml += `<button class="tactic-btn" disabled 
                                    title="Desbloqueia na temporada ${data.temporadaReq}">${formation} <i class="fas fa-lock"></i></button>`;
        }
    });
    tacticsHtml += '</div><p id="tactic-status" style="text-align:center; margin-top:10px;"></p>';
    popupBody.innerHTML += tacticsHtml;

    // --- LÓGICA DE CLIQUE PARA MUDAR DE TÁTICA (para táticas já possuídas) ---
    popupBody.querySelectorAll('.tactic-btn:not(.buy-tactic-btn):not([disabled])').forEach(button => {
        button.addEventListener('click', async (e) => {
            const selectedFormation = e.target.dataset.formation;
            const statusEl = document.getElementById('tactic-status');
            
            popupBody.querySelectorAll('.tactic-btn').forEach(btn => btn.disabled = true);
            statusEl.textContent = 'A atualizar tática...';

            try {
                const oldFormationPoints = currentUserClubData.formacaoatualpontos;
                const newFormationPoints = formacoes[selectedFormation].pontos;
                const newTotalOverall = (currentUserClubData.overall - oldFormationPoints) + newFormationPoints;

                const clubRef = doc(db, 'endlessclubes', auth.currentUser.uid);
                await updateDoc(clubRef, {
                    'treinador.formacaoAtual': selectedFormation,
                    'formacaoatualpontos': newFormationPoints,
                    'overall': newTotalOverall
                });

                currentUserClubData.treinador.formacaoAtual = selectedFormation;
                currentUserClubData.formacaoatualpontos = newFormationPoints;
                currentUserClubData.overall = newTotalOverall;

                statusEl.textContent = `Tática alterada para ${selectedFormation}!`;
                setTimeout(() => openCoachPopup(popupBody), 1500); // Recarrega o popup
            } catch (error) {
                console.error("Erro ao atualizar tática:", error);
                statusEl.textContent = "Erro ao guardar. Tente novamente.";
                popupBody.querySelectorAll('.tactic-btn').forEach(btn => btn.disabled = false);
            }
        });
    });

    // --- LÓGICA DE CLIQUE PARA COMPRAR NOVA TÁTICA ---
    popupBody.querySelectorAll('.buy-tactic-btn').forEach(button => {
        button.addEventListener('click', async (e) => {
            const formationToBuy = e.target.dataset.formation;
            const btn = e.target;
            btn.disabled = true;
            btn.textContent = 'A Processar Compra...';

            try {
                const purchase = firebase.functions().httpsCallable('purchaseUpgrade');
                const result = await purchase({ upgradeType: 'tactic', itemId: formationToBuy });
                
                alert(result.data.message);
                location.reload(); // Recarrega a página para atualizar todos os dados
            } catch (error) {
                console.error("Erro ao comprar tática:", error);
                alert("Erro: " + error.message);
                await openCoachPopup(popupBody); // Recarrega apenas o popup em caso de erro
            }
        });
    });
}


   async function getGameSeasonInfo() {
    // CORREÇÃO: Lê de ambos os documentos de configuração em paralelo.
    const globalConfigSnap = await getDoc(doc(db, 'paineis', 'configuracoes_gerais'));
    const endlessConfigSnap = await getDoc(doc(db, 'paineis', 'endless_configuracoes'));

    const seasonIdentifier = globalConfigSnap.exists() ? globalConfigSnap.data().temporadaAtual : 'default_season';
    const JORNADAS_PER_SEASON = endlessConfigSnap.exists() ? endlessConfigSnap.data().jornadasPorTemporada : 28;
    
    // O resto da lógica da função para calcular a temporada do jogo não muda
    const TEAMS_IN_LEAGUE = 20;
    const GAMES_PER_JORNADA = TEAMS_IN_LEAGUE / 2;

    const gamesQuery = query(collection(db, "endlessjogos"), where("seasonId", "==", seasonIdentifier));
    const gamesSnapshot = await getDocs(gamesQuery);
    const totalGamesSimulated = gamesSnapshot.size;

    const totalJornadasSimulated = Math.floor(totalGamesSimulated / GAMES_PER_JORNADA);
    
    const currentGameSeason = Math.floor(totalJornadasSimulated / JORNADAS_PER_SEASON) + 1;
    const currentJornadaInSeason = totalJornadasSimulated % JORNADAS_PER_SEASON;

    return {
        currentGameSeason,
        currentJornadaInSeason,
        seasonIdentifier,
        JORNADAS_PER_SEASON
    };
}

async function handleSimulationClick(event) {
    const clickedButton = event.currentTarget;
    if (!clickedButton) return;

    // Desativar ambos os botões para segurança
    const btnWidget = document.getElementById('simulate-week-btn-widget');
    const btnPopup = document.getElementById('simulate-week-btn');
    if (btnWidget) btnWidget.disabled = true;
    if (btnPopup) btnPopup.disabled = true;

    // Ativar animações
    clickedButton.classList.add('simulating');
    clickedButton.innerHTML = `<i class="fas fa-spinner fa-spin"></i> A Simular...`;

    // Criar explosão de confetti
    const buttonRect = clickedButton.getBoundingClientRect();
    const confettiCount = 30;
    const confettiColors = ['var(--gold-color)', 'var(--accent-color)', '#ffffff', '#ff6b6b'];
    for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.classList.add('confetti-piece');
        confetti.style.left = `${buttonRect.left + buttonRect.width / 2}px`;
        confetti.style.top = `${buttonRect.top + buttonRect.height / 2}px`;
        const xEnd = (Math.random() - 0.5) * 350;
        const yEnd = (Math.random() - 0.7) * 400;
        const rotateEnd = Math.random() * 540;
        confetti.style.setProperty('--x-end', `${xEnd}px`);
        confetti.style.setProperty('--y-end', `${yEnd}px`);
        confetti.style.setProperty('--rotate-end', `${rotateEnd}deg`);
        confetti.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
        document.body.appendChild(confetti);
        setTimeout(() => { confetti.remove(); }, 1000);
    }
    
    // Tentar guardar os dados no Firebase
    try {
        const globalConfigSnap = await getDoc(doc(db, 'paineis', 'configuracoes_gerais'));
        const seasonIdentifier = globalConfigSnap.exists() ? globalConfigSnap.data().temporadaAtual : 'default_season';
        
        if (!seasonIdentifier || seasonIdentifier === 'default_season') {
             throw new Error("Identificador de temporada inválido.");
        }

        const dayOfMonth = new Date().getDate();
        const semanaAtual = Math.floor((dayOfMonth - 1) / 7) + 1;

        const lastWeekViewedData = {
            season: seasonIdentifier,
            week: semanaAtual
        };
        
        const clubRef = doc(db, 'endlessclubes', auth.currentUser.uid);
        await updateDoc(clubRef, {
            lastWeekViewed: lastWeekViewedData
        });

        if(currentUserClubData) {
            currentUserClubData.lastWeekViewed = lastWeekViewedData;
        }

    } catch (error) {
        console.error("Erro ao guardar a última semana vista:", error);
        if (btnWidget) btnWidget.disabled = false;
        if (btnPopup) btnPopup.disabled = false;
        clickedButton.classList.remove('simulating');
        clickedButton.innerHTML = `<i class="fas fa-play-circle"></i> Simular Semana`;
        alert("Ocorreu um erro ao guardar a sua ação. Por favor, tente novamente.");
        return; // Este return está DENTRO do catch, o que é correto.
    }
    
    // Se tudo correu bem, recarregar a página após a animação
    setTimeout(() => {
        location.reload();
    }, 1500);
}




// Variável para controlar o temporizador do toast
        let ownerToastTimer;

        // Nova função para mostrar o toast
        function showOwnerToast(clubName, ownerName) {
            const toastElement = document.getElementById('owner-toast');
            const toastContent = document.getElementById('owner-toast-content');

            // Limpa qualquer temporizador anterior para que o toast não se feche prematuramente
            clearTimeout(ownerToastTimer);

            // Define o conteúdo do toast
            toastContent.innerHTML = `
                <h3 style="color: var(--accent-color);">${clubName}</h3>
                <p>Treinador-Chefe:</p>
                <h4>${ownerName}</h4>
            `;

            // Mostra o toast adicionando a classe .show
            toastElement.classList.add('show');

            // Define um temporizador para esconder o toast após 4 segundos
            ownerToastTimer = setTimeout(() => {
                toastElement.classList.remove('show');
            }, 4000);
        }

        // Nova função de clique, otimizada para o toast
        async function handleTeamRowClick(event) {
            const row = event.target.closest('tr');
            if (!row || !row.cells[1]) return;

            const teamName = row.cells[1].textContent;
            const club = leagueClubs.find(c => c.nome === teamName);
            if (!club) return;

            // Mostra o toast com um spinner enquanto procura
            const spinner = '<div class="loading-spinner" style="width:25px; height:25px; border-width: 4px;"></div>';
            showOwnerToast(teamName, spinner);

            if (!club.userId) {
                showOwnerToast(teamName, "Boot");
            } else {
                try {
                    const userDocRef = doc(db, 'users', club.userId);
                    const userSnap = await getDoc(userDocRef);
                    const ownerName = userSnap.exists() ? userSnap.data().nometabela : "Utilizador Desconhecido";
                    showOwnerToast(teamName, ownerName);
                } catch (error) {
                    console.error("Erro ao procurar o dono do clube:", error);
                    showOwnerToast(teamName, "Erro ao carregar");
                }
            }
        }



        async function openPlayerPack() {
            const packPopup = document.getElementById('pack-opening-popup');
            const cardsContainer = document.getElementById('player-cards-container');
            cardsContainer.innerHTML = '<div class="loading-spinner" style="width:60px; height:60px; border-width: 8px;"></div>';
            packPopup.style.display = 'flex';
            try {
                const players = await generateUniquePlayers();
                renderPlayerCards(players, cardsContainer);
            } catch (error) {
                console.error("Erro ao gerar jogadores:", error);
                cardsContainer.innerHTML = '<p style="color: #ff6b6b;">Ocorreu um erro ao abrir o pack.</p>';
            }
        }
        
        function renderPlayerCards(players, container) {
            let html = '';
            players.forEach(player => {
                const flagUrl = `https://flagcdn.com/w40/${player.countryCode.toLowerCase()}.png`;
                html += `<div class="player-card"><div class="position">${player.position}</div><div class="name">${player.name}</div><div class="nationality"><img src="${flagUrl}" alt="Bandeira"><span>${player.countryCode}</span></div><p style="margin-top: 15px; font-size: 1.3em; color: var(--gold-color); font-weight: bold;">${player.overall}</p></div>`;
            });
            container.innerHTML = html;
        }

    </script>
</body>
</html>
