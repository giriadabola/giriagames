<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mitos e Lendas - Ggames</title>
        <link rel="icon" type="image/png" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTl6Ljabwgx-VXdZz8FcAoygQprujSsCoXc32Y_iU0FjYVPu1B6MffWwp8gcCVuV8TWn39FRk9OIe1nc-esubVJYmdLsTptAoR9GyqNuw4R5MBaeaoWXTc3JaqH2YVNtEmfReQqohvQKvHiI0XwE5na2ty2B9Bt4oELxYv2BaZ7R3UmeylpiVEiIbiLnCB/s320/soccer-ball-png.webp">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* --- Estilos CSS --- */
        @import url(https://fonts.googleapis.com/css?family=Lato:400,700,900);
        @import url('https://fonts.googleapis.com/css2?family=Alfa+Slab+One&display=swap');


* { margin: 0; padding: 0; box-sizing: border-box; }
body { min-height: 100vh; background: radial-gradient(ellipse at center, #1a1a2e 0%, #0f0f1a 100%); font-family: 'Lato', 'Segoe UI', sans-serif; overflow-x: hidden; color: #9E9E9E; }
#loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #1a1a2e; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 1001; padding: 20px; text-align: center; transition: opacity 0.5s ease-out; }
#loading-screen.hidden { opacity: 0; pointer-events: none; }
.loading-spinner { border: 16px solid #2a2a4a; border-top: 16px solid #6c63ff; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; margin-bottom: 30px; }
@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
.rules-container { max-width: 600px; background: linear-gradient(145deg, #3b3b5c, #1f1f30); border-radius: 10px; padding: 20px; box-shadow: 0 0 10px #6c63ff; margin-bottom: 20px; max-height: 60vh; overflow-y: auto; color: white; }
.rules-container h2 { color: #6c63ff; margin-bottom: 15px; font-size: 24px; text-align: center; }
.rules-container p { margin-bottom: 15px; line-height: 1.6; color: #9E9E9E; }
.rules-container ul { margin-left: 20px; margin-bottom: 15px; }
.rules-container li { margin-bottom: 8px; line-height: 1.5; color: #9E9E9E; }
.bottom-menu { position: fixed; bottom: 0; left: 0; width: 100%; background: linear-gradient(145deg, #3b3b5c, #1f1f30); box-shadow: 0 -2px 10px rgba(108, 99, 255, 0.2); padding: 12px 0; display: flex; justify-content: center; gap: 32px; align-items: center; z-index: 1000; }
.menu-item { display: flex; flex-direction: column; align-items: center; text-decoration: none; color: #9E9E9E; transition: color 0.3s ease; }
.menu-item:hover, .menu-item.active { color: #6c63ff; }
.menu-item i { font-size: 24px; margin-bottom: 4px; }
.empire-icon { font-size: 42px; color: #6c63ff; transform: translateY(-3px); filter: drop-shadow(0 0 8px rgba(108, 99, 255, 0.4)); transition: all 0.3s ease; }
.empire-icon:hover, .menu-item.active .empire-icon { color: #5a52cc; transform: translateY(-8px); filter: drop-shadow(0 0 12px rgba(108, 99, 255, 0.6)); }
.content { padding: 20px; margin-bottom: 80px; display: none; opacity: 0; transition: opacity 0.5s ease-in; }
.content.visible { display: block; opacity: 1; }
.myths-header { text-align: center; margin-bottom: 30px; color: #6c63ff; }
.glow { text-shadow: 0 0 10px #fff, 0 0 20px #6c63ff, 0 0 30px #6c63ff; }
.pack-container { background: linear-gradient(145deg, #3b3b5c, #1f1f30); position: relative; width: 200px; height: 250px; cursor: pointer; border-radius: 1rem; overflow: hidden; box-shadow: 0 0 10px #6c63ff; z-index: 10; transition: opacity 0.5s ease; margin: 0 auto; }
.pack-container.animating { pointer-events: none; }
.pack-top, .pack-bottom { background: transparent; width: 100%; height: 50%; display: flex; align-items: center; justify-content: center; position: absolute; left: 0; transition: transform 1s ease, opacity 1s ease, clip-path 0.5s ease, display 0s ease 1s; color: white; background-size: cover; background-repeat: no-repeat; background-position: center center; }
.pack-top { top: 0; z-index: 10; }
.pack-bottom { bottom: 0; }
.separar .pack-top { clip-path: polygon(0 0, 100% 0, 100% 70%, 95% 68%, 90% 72%, 85% 68%, 80% 72%, 75% 68%, 70% 72%, 65% 68%, 60% 72%, 55% 68%, 50% 72%, 45% 68%, 40% 72%, 35% 68%, 30% 72%, 25% 68%, 20% 72%, 15% 68%, 10% 72%, 5% 68%, 0 70%); transform: translateY(-120%); opacity: 0; }
.separar .pack-bottom { clip-path: polygon(0 30%, 5% 32%, 10% 28%, 15% 32%, 20% 28%, 25% 32%, 30% 28%, 35% 32%, 40% 28%, 45% 32%, 50% 28%, 55% 32%, 60% 28%, 65% 32%, 70% 28%, 75% 32%, 80% 28%, 85% 32%, 90% 28%, 95% 32%, 100% 30%, 100% 100%, 0 100%); transform: translateY(120%); opacity: 0; }
.sumir-pack { opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
.sumir-pack .pack-top, .sumir-pack .pack-bottom { display: none; }
.flash-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle, rgba(255,255,255,0.9), rgba(255,255,255,0)); opacity: 0; pointer-events: none; z-index: 60; }
.flash-overlay.active { animation: overlayFlash 1s ease-out forwards; }
@keyframes overlayFlash { 0% { opacity: 0; } 20% { opacity: 1; } 100% { opacity: 0; } }
.card-reveal { width: 200px; height: 250px; position: absolute; top: 0; left: 50%; transform: translateX(-50%); z-index: 20; display: none; opacity: 0; }
@keyframes cardAppear { 0% { opacity: 0; transform: translateX(-50%) scale(0.5) rotateX(90deg); } 50% { opacity: 1; transform: translateX(-50%) scale(1.05) rotateX(0deg); } 100% { opacity: 1; transform: translateX(-50%) scale(1) rotateX(0deg); } }
.card-reveal.visible { display: block !important; opacity: 1 ! important; animation: cardAppear 0.6s ease-out forwards; }
.card-reveal.visible::before { content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(circle at center, rgba(255, 255, 255, 0.8) 0%, rgba(255, 255, 255, 0.2) 40%, transparent 80%); opacity: 0; animation: cardFlash 1s ease-out forwards; z-index: 25; pointer-events: none; border-radius: 1rem; }
@keyframes cardFlash { 0% { opacity: 0; transform: scale(0.7) rotate(0deg); } 40% { opacity: 1; transform: scale(1.2) rotate(5deg); } 60% { opacity: 0.8; transform: scale(1.1) rotate(-3deg); } 100% { opacity: 0; transform: scale(1) rotate(0deg); } }

/* --- Clash Card Styles (COM AJUSTES DE Z-INDEX) --- */
.clash-card {
    background: transparent;
    border-radius: 14px;
    position: relative; /* Necessário para o contexto de z-index dos filhos */
    text-align: center;
    box-shadow: 0 0 20px rgba(0, 100, 255, 0.8);
    z-index: 1; /* Define o contexto de empilhamento base para o card */
    user-select: none;
    height: 100%;
    display: flex;
    flex-direction: column;
    overflow: visible; /* Permite que a imagem do personagem saia para fora */
    padding-top: 0;
    box-sizing: border-box;
    border: 3px solid #0088ff;
    animation: cardGlow 2s infinite alternate;
}

@keyframes cardGlow {
  0% { box-shadow: 0 0 15px rgba(0, 100, 255, 0.6); }
  100% { box-shadow: 0 0 25px rgba(0, 150, 255, 0.9); }
}

/* 1. Container da Imagem de Fundo */
.clash-card__image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%; /* Cobre toda a área do card */
    border-radius: 14px; /* Mantém cantos arredondados */
    overflow: hidden; /* Importante para a máscara funcionar bem com border-radius */
    z-index: 1; /* Camada 1: Fundo (mais baixo) */
    background-size: cover;
    background-repeat: no-repeat;
    background-position: center center;
    background-color: #006600; /* Fundo verde como na imagem de referência */
    box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.5);
    /* Masking removido daqui, pois os efeitos foram movidos */
    mask-image: linear-gradient(
        to bottom,                      /* Gradiente de cima para baixo */
        rgba(0,0,0, 0.8) 0%,            /* Começa 80% opaco no topo (leve fade-in) */
        rgba(0,0,0, 1.0) 5%,            /* Atinge 100% opaco aos 5% da altura */
        rgba(0,0,0, 1.0) 35%,           /* Permanece 100% opaco até 55% da altura */
        rgba(0,0,0, 0.1) 100%           /* Desvanece até 10% opaco na base (100% da altura) */
    );
    /* Prefixo Webkit para compatibilidade */
    -webkit-mask-image: linear-gradient(
        to bottom,
        rgba(0,0,0, 0.8) 0%,
        rgba(0,0,0, 1.0) 5%,
        rgba(0,0,0, 1.0) 35%,
        rgba(0,0,0, 0.1) 100%
    );
}

/* 2. Efeitos de Fumaça (Nuvens) - Agora filhos diretos de .clash-card */
.background_image-smoke-cloud1,
.background_image-smoke-cloud2,
.background_image-smoke-cloud3 {
    position: absolute;
    /* opacity é definido por .smoke-image abaixo */
    max-width: 70%; /* Ou ajuste conforme necessário */
    z-index: 2;   /* Camada 2: Acima do fundo */
    pointer-events: none;
}
/* Definição de @keyframes wave (Exemplo simples se não estiver definido em outro lugar) */
@keyframes wave {
    0%, 100% { transform: translateX(0) translateY(0) rotate(0deg); }
    50% { transform: translateX(5px) translateY(-5px) rotate(2deg); }
}
.background_image-smoke-cloud1 { animation: wave 8s 0.1s infinite linear; right: 40%; bottom: 25%; } /* Exemplo: Mais alto */
.background_image-smoke-cloud2 { animation: wave 9s 0.1s infinite linear; left: -10%; bottom: 20%; } /* Exemplo: Mais alto */
.background_image-smoke-cloud3 { animation: wave 10s 0.1s infinite linear; right: -0%; bottom: 35%; }  /* Exemplo: Mais alto */

/* Estilo específico para as imagens de fumo */
.smoke-image {
    opacity: 0.7; /* Opacidade das nuvens */
    max-width: 90%; /* Tamanho máximo das nuvens */
}

/* 3. Efeito de Névoa - Agora filho direto de .clash-card */
.fog {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 50px; /* Altura reduzida da área de névoa */
    overflow: hidden;
    pointer-events: none;
    z-index: 3; /* Camada 3: Acima das nuvens de fumo */
}
.fog span {
    position: absolute;
    bottom: 0;
    width: 50px;
    height: 50px;
    background: radial-gradient(circle, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0) 70%);
    filter: blur(10px);
    border-radius: 50%;
    animation: fogRise 5s linear infinite;
    animation-delay: calc(-1s * var(--i));
    left: calc(var(--i) * 25%);
}
/* Variáveis para delay e posicionamento horizontal da névoa */
.fog span:nth-child(1) { --i: 1; }
.fog span:nth-child(2) { --i: 2; }
.fog span:nth-child(3) { --i: 3; }
/* Animação da névoa subindo */
@keyframes fogRise {
    0% { transform: translateY(0) scale(1); opacity: 0.3; }
    50% { opacity: 0.5; }
    100% { transform: translateY(-80px) scale(1.4); opacity: 0; }
}

/* 4. Imagem Principal (Personagem) */
.character-image {
    position: absolute;
    width: 650px; /* Aumentado para ter uma imagem ainda maior */
    top: -90px;   /* Ajustado para posicionar mais alto */
    left: 50%;
    transform: translateX(-50%) scale(0.7); /* Aumentado a escala para uma imagem maior */
    z-index: 4;   /* Camada 4: Acima da fumaça/névoa */
    pointer-events: none;
    filter: brightness(1.8) contrast(1.0); /* Ajustado para melhor visibilidade */
}

/* 5. Conteúdo Textual e Stats (Camada mais alta) */
.clash-card__level {
    text-transform: uppercase;
    font-size: 8px;
    font-weight: 700;
    margin-bottom: 1px;
    padding-top: 3px;
    flex-shrink: 0;
    color: #555;
    transition: color 0.3s ease;
    position: relative; /* Mantém no fluxo, mas permite z-index */
    z-index: 5; /* Camada 5: Mais alta */
    margin-top: 80px; /* Espaço reduzido para a imagem do personagem */
}
.clash-card__unit-name {
    font-size: 20px;
    color: #FFD700;
    font-weight: 900;
    text-transform: uppercase;
    position: absolute;
    z-index: 10;
    top: 130px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(to bottom, #a86c1d, #5c3b1e); /* tons de madeira escura */
    border: 4px solid #f5d76e;
    border-radius: 8px;
    padding: 6px 12px;
    width: fit-content;
    box-shadow:
        inset 0 2px 4px rgba(0,0,0,0.6), /* sombra interna */
        0 3px 6px rgba(0,0,0,0.4),       /* sombra externa */
        0 0 12px rgba(255, 215, 0, 0.4); /* glow dourado */
    text-shadow:
        1px 1px 0 #6b4e15,
        -1px -1px 0 #6b4e15,
        0 2px 4px rgba(0,0,0,0.6);
}

.clash-card__unit-description {
    font-size: 11px;
    padding: 5px 10px;
    margin-bottom: 5px;
    flex-grow: 1;
    overflow: hidden;
    color: #444;
    line-height: 1.4;
    position: relative;
    z-index: 5; /* Camada 5 */
}
.clash-card__unit-stats {
    position: relative; /* Necessário para z-index funcionar corretamente aqui */
    color: white;
    font-weight: 700;
    border-bottom-left-radius: 14px;
    border-bottom-right-radius: 14px;
    z-index: 5; /* Camada 5 */
    flex-shrink: 0;
    margin-top: auto; /* Empurra para baixo */
    background: #003366 !important; /* Fundo azul escuro como na imagem de referência */
    transition: background 0.3s ease;
    border-top: 2px solid #0066cc;
}
.clash-card__unit-stats .one-quarter {
    width: 25%;
    float: left;
    padding: 8px 2px;
    text-align: center;
    box-sizing: border-box;
}
.clash-card__unit-stats .one-quarter:last-child {
    border-right: none;
}
.clash-card__unit-stats .one-quarter img {
    width: 36px;
    height: 36px;
    display: block;
    margin: 0 auto;
    background-color: transparent;
    padding: 0;
    filter: drop-shadow(0 0 3px rgba(255, 255, 255, 0.5));
}
.clearfix::after {
    content: "";
    display: table;
    clear: both;
}

/* --- Message Banner Styles (Se ainda usar) --- */
.message-banner { background: linear-gradient(145deg, #5c3b3b, #301f1f); color: white; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3); text-align: center; }
.message-banner.offline { background: linear-gradient(145deg, #3b3b5c, #1f1f30); }
.message-banner h3 { font-weight: bold; margin-bottom: 0.5rem; color: #ff6b6b; }
.message-banner.offline h3 { color: #6c63ff; }
.message-banner p { font-size: 0.9rem; margin-bottom: 0.8rem; }
.message-banner button { padding: 0.5rem 1rem; background-color: #6c63ff; border: none; border-radius: 5px; color: white; cursor: pointer; transition: background-color 0.3s ease; }
.message-banner button:hover { background-color: #5a52cc; }
.message-banner.offline button { background-color: #4a4a7a; }
.message-banner.offline button:hover { background-color: #3a3a6a; }
  
#cardLevel { /* Selects the element with ID cardLevel */
    display: none;
}

#cardDescription { /* Selects the element with ID cardDescription */
    display: none;
}
  
  
  
  
  </style>
</head>
<body class="text-white">
    <!-- Loading Screen with Rules -->
    <div id="loading-screen">
        <div class="loading-spinner"></div>
        <div class="rules-container">
            <h2>Regras do Mitos e Lendas</h2>
            <p>Bem-vindo ao Mitos e Lendas...</p>
            <!-- Rest of rules content -->
             <ul>
                <li><strong>Famílias:</strong> Os mitos são organizados em famílias...</li>
                <li><strong>Castas:</strong> Dentro de cada família...</li>
                <li><strong>Coleção:</strong> Colecione mitos...</li>
                <li><strong>Pontos:</strong> Cada mito possui pontos...</li>
                <li><strong>Batalhas:</strong> Use seus mitos em batalhas...</li>
                <li><strong>Equipes:</strong> Forme equipes...</li>
            </ul>
            <p>Explore o mundo dos mitos, descubra lendas raras e torne-se o maior colecionador do G EMPIRE!</p>
        </div>
    </div>

    <!-- Main Content -->
    <main class="content" id="main-content">
        <div class="myths-header">
            <h1 class="text-5xl font-bold glow">Mitos e Lendas</h1>
        
        </div>

        <!-- Pack and Card Section -->
        <section class="flex flex-col justify-start items-center h-[80vh] relative overflow-visible mb-10 mt-20">
            <!-- O Pack clicável -->
            <div class="pack-container" id="pack">
                <div class="pack-top" style="background-image: url('https://lh3.googleusercontent.com/pw/AP1GczMH8UvxqDwObtdJAz-fCT0v7EfKUrQzULQ9KlcMg3Mr4ZphFntPuH0I1D-3ONaMT79KMGX2mUdkKFNpZN_iOEy3Rhm5_sPMY-jvD2JC2cpxmTDY1fEm_Irsl406n5LI-aUf-8RPHYSTG_6weRa_fMxE=w1005-h880-s-no-gm?authuser=1');"></div>
                <div class="pack-bottom" style="background-image: url('https://lh3.googleusercontent.com/pw/AP1GczMEI-1B21mGHy90cqyjoOoYvT9vFK_ZMCd9P3KnluBCD8jaXIfrWSq8Sb5hbXucTkJihmW-PB9dNDiHur0QTtSB9N9_OkFkFJZemZKPrEd7q_4u6ihVD2u0TcccgAN9Yz-BK1zfo7cj8_A9mVrinw3L=w1005-h880-s-no-gm?authuser=1');"></div>
                <div class="flash-overlay" id="flashOverlay"></div>
            </div>

             <!-- Container onde a carta dinâmica será revelada -->
             <div class="card-reveal" id="cardReveal">
                <div class="clash-card" id="dynamicCard">
                    <!-- 1. Imagem de Fundo (Camada mais baixa) -->
                    <div class="clash-card__image" id="cardBackgroundImage">
                        <!-- Efeitos visuais NÃO ficam mais aqui -->
                    </div>

                    <!-- 2. Efeitos de Fumaça (Acima do fundo) -->
                    <img class="background_image-smoke-cloud1 smoke-image" alt="smoke-image1" src="https://oleksandrpavlyshch.github.io/mouse-move-parallax_demo/img/smoke1.png">
                    <img class="background_image-smoke-cloud2 smoke-image" alt="smoke-image2" src="https://oleksandrpavlyshch.github.io/mouse-move-parallax_demo/img/smoke2.png">
                    <img class="background_image-smoke-cloud3 smoke-image" alt="smoke-image3" src="https://oleksandrpavlyshch.github.io/mouse-move-parallax_demo/img/smoke3.png">
                    <div class="fog">
                        <span></span><span></span><span></span>
                    </div>

                    <!-- 3. Imagem Principal (Acima da fumaça) -->
                    <img class="character-image" id="cardMainImage" src="" alt="Character" />

                    <!-- 4. Texto e Stats (Camada mais alta) -->
                    <div class="clash-card__level" id="cardLevel"></div>
                    <div class="clash-card__unit-name" id="cardName">A Abrir...</div>
                    <div class="clash-card__unit-description" id="cardDescription"></div>
                    <div class="clash-card__unit-stats clearfix" id="cardStats">
                        <!-- Ícones estáticos -->
                        <div class="one-quarter"><img src="https://sortitoutsi.b-cdn.net/uploads/team/97207966.png" alt="Training Icon"></div>
                        <div class="one-quarter"><img src="https://sortitoutsi.b-cdn.net/uploads/team/5627098.png" alt="Speed Icon"></div>
                        <div class="one-quarter"><img src="https://sortitoutsi.b-cdn.net/uploads/team/23078012.png" alt="Cost Icon"></div>
                        <div class="one-quarter"><img src="https://sortitoutsi.b-cdn.net/uploads/team/23199255.png" alt="Attack Icon"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Elemento da grelha REMOVIDO -->
        <!-- <div class="myths-grid" id="myths-grid"></div> -->

    </main>

    <!-- Bottom Menu -->
    <nav class="bottom-menu">
        <a href="1x.html" class="menu-item"> <i class="fas fa-home"></i> </a>
        <a href="market.html" class="menu-item"> <i class="fas fa-shopping-cart"></i> </a>
        <a href="team.html" class="menu-item"> <i class="fas fa-users"></i> </a>
        <a href="empire.html" class="menu-item"> <i class="fas fa-landmark empire-icon"></i> </a>
        <a href="rankings.html" class="menu-item"> <i class="fas fa-list"></i> </a>
        <a href="profile.html" class="menu-item"> <i class="fas fa-user"></i> </a>
    </nav>

    <!-- Firebase Scripts -->
     <script src="config.js"></script>
    <script type="module">
        // Import Firebase modules
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
        import {
            getFirestore, collection, getDocs, doc, getDoc, query, where, enableIndexedDbPersistence, terminate
        } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
        import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';
let db;
        let auth;
        let app;

        // --- Inicialização Firebase ---
        try {
            // A variável 'firebaseConfig' vem do ficheiro config.js
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            enableIndexedDbPersistence(db)
                .then(() => console.log("Persistência offline habilitada."))
                .catch((err) => console.error("Erro persistência offline:", err.code));
        } catch (error) {
            console.error("Erro Crítico ao Inicializar Firebase:", error);
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) loadingScreen.classList.add('hidden');
        }

        // --- Elementos do DOM ---
        const loadingScreen = document.getElementById('loading-screen');
        const content = document.getElementById('main-content');
        const pack = document.getElementById('pack');
        const cardReveal = document.getElementById('cardReveal');
        const flashOverlay = document.getElementById('flashOverlay');
        const dynamicCard = document.getElementById('dynamicCard');
        const cardBackgroundImage = document.getElementById('cardBackgroundImage');
        const cardMainImage = document.getElementById('cardMainImage');
        const cardLevel = document.getElementById('cardLevel');
        const cardName = document.getElementById('cardName');
        const cardDescription = document.getElementById('cardDescription');
        const cardStats = document.getElementById('cardStats');
       

        // --- Funções Auxiliares ---

        function preloadImages(containerElement) {
            // ... (código da função preloadImages como definido anteriormente) ...
             if (!containerElement) return Promise.resolve();
             const images = containerElement.querySelectorAll('img');
             const promises = [];
             let bgImageUrl = null;
             // Tenta pegar do estilo inline primeiro (mais provável após JS definir)
             if (containerElement.style.backgroundImage && containerElement.style.backgroundImage !== 'none') {
                 const urlMatch = containerElement.style.backgroundImage.match(/url\(["']?(.*?)["']?\)/);
                 if (urlMatch && urlMatch[1]) bgImageUrl = urlMatch[1];
             }

             if (bgImageUrl) {
                  console.log(`[preloadImages] Encontrado background para pré-carregar: ${bgImageUrl}`);
                 const bgPromise = new Promise((resolve) => {
                     const img = new Image();
                     img.onload = () => { console.log(` -> Background ${bgImageUrl} pré-carregado.`); resolve(); };
                     img.onerror = () => { console.error(` -> Erro pré-carregar background: ${bgImageUrl}`); resolve(); };
                     img.src = bgImageUrl;
                 });
                 promises.push(bgPromise);
             } else {
                  // console.log("[preloadImages] Nenhum background image encontrado no estilo inline do container.");
             }

             if (images.length > 0) {
                 images.forEach(img => {
                     if (!img.src || img.src.includes('placeholder.png') || img.src.startsWith('data:')) return;
                     const promise = new Promise((resolve) => {
                         if (img.complete) { resolve(); }
                         else {
                             img.onload = () => { /* console.log(` -> Imagem ${img.src} pré-carregada.`); */ resolve(); };
                             img.onerror = () => { console.error(` -> Erro carregar imagem: ${img.src}`); resolve(); };
                             img.src = img.src; // Garante que o load é disparado
                         }
                     });
                     promises.push(promise);
                 });
             }
             if (promises.length === 0) { return Promise.resolve(); }
             console.log(`[preloadImages] Tentando pré-carregar ${promises.length} recursos...`);
             return Promise.all(promises);
        }


         async function getUserData(userId) {
            if (!db || !userId) {
                console.error("DB ou User ID inválido para getUserData.");
                return null;
            }
            try {
                const userRef = doc(db, 'users', userId);
                const userDoc = await getDoc(userRef);
                if (userDoc.exists()) {
                    return userDoc.data();
                } else {
                    console.warn(`Nenhum documento encontrado para o utilizador: ${userId}`);
                    return null;
                }
            } catch (error) {
                console.error('Erro ao buscar dados do utilizador:', error);
                return null;
            }
        }


        // --- Funções da Lógica do Pack Dinâmico (com logs) ---

        async function fetchActiveRules() {
            // ... (código da função fetchActiveRules como antes, com logs) ...
            console.log("[fetchActiveRules] Iniciando busca por regras ativas...");
            if (!db) { console.error("[fetchActiveRules] Erro: Firestore DB não inicializado."); throw new Error("Firestore DB not initialized."); }
            const collectionName = 'mitosgameRegras'; const fieldName = 'ativo'; const targetValue = true;
            console.log(`[fetchActiveRules] Coleção: '${collectionName}', Campo: '${fieldName}', Valor: ${targetValue}`);
            const regrasRef = collection(db, collectionName); const q = query(regrasRef, where(fieldName, '==', targetValue));
            try {
                console.log("[fetchActiveRules] Executando a query...");
                const snapshot = await getDocs(q);
                console.log(`[fetchActiveRules] Query executada. Tamanho: ${snapshot.size}, Vazio: ${snapshot.empty}`);
                if (snapshot.empty) { console.warn("[fetchActiveRules] Nenhuma regra ativa encontrada."); return []; }
                const rules = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                console.log("[fetchActiveRules] Retornando regras ativas:", rules);
                return rules;
            } catch (error) { console.error("[fetchActiveRules] Erro:", error); throw error; }
        }

        async function fetchCompetitionNames(competitionIds) {
            // ... (código da função fetchCompetitionNames como antes, com logs) ...
            if (!db) throw new Error("Firestore DB not initialized.");
            const uniqueIds = [...new Set(competitionIds.filter(id => id))];
            if (uniqueIds.length === 0) { /* console.log("[fetchCompetitionNames] Nenhum ID válido."); */ return new Map(); }
            console.log("[fetchCompetitionNames] Buscando nomes para IDs:", uniqueIds);
            const nameMap = new Map(); const promises = [];
            const competitionCollectionName = 'competicoes'; // <<< VERIFIQUE NOME COLEÇÃO
            uniqueIds.forEach(id => {
                const docRef = doc(db, competitionCollectionName, id);
                promises.push( getDoc(docRef).then(docSnap => {
                    if (docSnap.exists()) {
                        const data = docSnap.data(); const name = data.nome; // <<< VERIFIQUE CAMPO NOME
                        if (name) { nameMap.set(id, name); } else { console.warn(`[fetchCompNames] Comp ID ${id} sem campo 'nome'.`); }
                    } else { console.warn(`[fetchCompNames] Comp ID ${id} não encontrado.`); }
                }).catch(error => { console.error(`[fetchCompNames] Erro buscar ID ${id}:`, error); }) );
            });
            await Promise.all(promises);
            console.log("[fetchCompetitionNames] Mapeamento ID->Nome:", nameMap);
            return nameMap;
        }

        async function fetchAndSelectItem(activeRules) {
            // ... (código da função fetchAndSelectItem como antes, com logs) ...
            console.log("[fetchAndSelectItem] Iniciando...");
            if (!db) throw new Error("DB not initialized."); if (!activeRules || activeRules.length === 0) return null;
            const validPatamares = [...new Set(activeRules.map(rule => rule.patamar).filter(p => p))];
            const validCompeticaoNames = [...new Set(activeRules.map(rule => rule.competicao).filter(c => c))];
            console.log("[fetchAndSelectItem] Patamares Válidos:", validPatamares); console.log("[fetchAndSelectItem] Nomes Competição Válidos:", validCompeticaoNames);
            if (validPatamares.length === 0 || validCompeticaoNames.length === 0) { console.warn("[fetchAndSelectItem] Faltam patamares ou nomes de competições."); return null; }
            const itensRef = collection(db, 'mitosgameItens'); let q = query(itensRef, where('ativo', '==', true)); let filteringPatamarServerSide = false;
            if (validPatamares.length <= 30) { q = query(itensRef, where('ativo', '==', true), where('patamar', 'in', validPatamares)); filteringPatamarServerSide = true; console.log("[fetchAndSelectItem] Query: ativo E patamar IN", validPatamares); }
            else { console.log("[fetchAndSelectItem] Query: apenas ativo"); }
            try {
                const snapshot = await getDocs(q); console.log(`[fetchAndSelectItem] Snapshot Query Inicial: ${snapshot.size} itens`); if (snapshot.empty) return null;
                let potentialItems = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() })); console.log(`[fetchAndSelectItem] Itens após query: ${potentialItems.length}`);
                if (!filteringPatamarServerSide) { const c = potentialItems.length; potentialItems = potentialItems.filter(item => validPatamares.includes(item.patamar)); console.log(`[fetchAndSelectItem] Filtro Patamar (cliente): ${c} -> ${potentialItems.length}`); if (potentialItems.length === 0) return null; }
                const allItemCompIds = new Set(); potentialItems.forEach(item => { [item.competicao1Id, item.competicao2Id, item.competicao3Id, item.competicao4Id].filter(id => id).forEach(id => allItemCompIds.add(id)); });
                console.log(`[fetchAndSelectItem] Coletados ${allItemCompIds.size} CompIDs únicos.`);
                const competitionIdToNameMap = await fetchCompetitionNames(Array.from(allItemCompIds));
                const cBeforeCompFilter = potentialItems.length; console.log("[fetchAndSelectItem] Iniciando filtro competição por NOME...");
                const matchingItems = potentialItems.filter(item => {
                    const itemCompIds = [item.competicao1Id, item.competicao2Id, item.competicao3Id, item.competicao4Id].filter(id => id);
                    const itemCompNames = itemCompIds.map(id => competitionIdToNameMap.get(id)).filter(name => name);
                    const match = itemCompNames.some(itemCompName => validCompeticaoNames.includes(itemCompName));
                    console.log(` -> Filtro Nome Comp: Item ${item.id} (Pat: ${item.patamar}) IDs[${itemCompIds.join(',')}] -> Nomes[${itemCompNames.join(',')}] vs Regra[${validCompeticaoNames.join(',')}]. Match? ${match}`);
                    return match;
                });
                console.log(`[fetchAndSelectItem] Filtro Comp Nome (cliente): ${cBeforeCompFilter} -> ${matchingItems.length}`);
                if (matchingItems.length === 0) { console.warn("[fetchAndSelectItem] Nenhum item sobreviveu filtro nome competição."); return null; }
                const randomIndex = Math.floor(Math.random() * matchingItems.length); const selectedItem = matchingItems[randomIndex];
                console.log(`[fetchAndSelectItem] Selecionado: ID ${selectedItem.id}, Nome: ${selectedItem.nome || '(sem nome)'}`);
                return selectedItem;
            } catch (error) { console.error("[fetchAndSelectItem] Erro:", error); throw error; }
        }

        // --- fetchFamiliaData COM LOGS ADICIONAIS ---
        async function fetchFamiliaData(familiaId) {
        console.log(`[fetchFamiliaData] Iniciando busca para familiaId: ${familiaId}`);
        if (!db) { console.error("[fetchFamiliaData] Erro: DB não inicializado."); throw new Error("Firestore DB not initialized."); }
        if (!familiaId) {
            console.warn("[fetchFamiliaData] ID da família não fornecido (null ou undefined).");
            return null;
        }

        // --- ALTERAÇÃO AQUI ---
        const familiaCollectionName = 'mitosgameItens'; // <<< ALTERADO de 'mitosgameFamilias'
        // ----------------------

        const imagemFieldName = 'imagem'; // <<< VERIFIQUE O NOME DO CAMPO DA IMAGEM neste documento

        console.log(`[fetchFamiliaData] Procurando na coleção '${familiaCollectionName}' pelo documento com ID '${familiaId}'`);
        try {
            const familiaRef = doc(db, familiaCollectionName, familiaId);
            const docSnap = await getDoc(familiaRef);

            if (docSnap.exists()) {
                console.log(`[fetchFamiliaData] Documento (supostamente da família) ${familiaId} encontrado dentro de '${familiaCollectionName}'.`);
                const familiaData = docSnap.data();
                console.log("[fetchFamiliaData] Dados completos:", JSON.stringify(familiaData));
                const imageUrl = familiaData[imagemFieldName];
                console.log(`[fetchFamiliaData] Valor do campo '${imagemFieldName}':`, imageUrl);

                if (!imageUrl) {
                     console.warn(`[fetchFamiliaData] Campo '${imagemFieldName}' está vazio ou não existe no documento ${familiaId} em '${familiaCollectionName}'.`);
                }
                // Retorna os dados encontrados, assumindo que representam a família
                return { id: docSnap.id, ...familiaData };
            } else {
                console.warn(`[fetchFamiliaData] Documento com ID ${familiaId} NÃO encontrado na coleção '${familiaCollectionName}'.`);
                return null;
            }
        } catch (error) {
             console.error(`[fetchFamiliaData] Erro ao buscar ID ${familiaId} em '${familiaCollectionName}':`, error);
             return null;
        }
    }
        // --- FIM de fetchFamiliaData com logs adicionais ---

        // --- Função para buscar imagens de clubes das competições ---
        async function fetchClubImagesFromCompetitions(itemData) {
            console.log("[fetchClubImagesFromCompetitions] Iniciando busca de imagens de clubes...");
            if (!db || !itemData) {
                console.error("[fetchClubImagesFromCompetitions] DB não inicializado ou itemData inválido.");
                return [];
            }
            
            // Obter IDs das competições do item (mito)
            // Verificar o nível do mito para determinar quais competições mostrar
            const nivel = itemData.nivel || 'Nivel 1';
            console.log(`[fetchClubImagesFromCompetitions] Nível do mito: ${nivel}`);
            
            // Imagem placeholder para substituir imagens não disponíveis pelo nível
            const placeholderImage = 'https://lh3.googleusercontent.com/pw/AP1GczPiqT86eHKMxOqxzkXTF1sOZkH3NuWtELu04zT0ANLpdA9MHuPdguJHyYoRgSKSbiM0el-8UZ8qZuEQbWT8heJR2GPglnZdJRfnVqjdFUItX2deOQVy9RPgqTa02vXF36nUz2iM3oDD7EjuI0HOwps1=w880-h880-s-no-gm?authuser=1';
            
            // Aplicar lógica condicional baseada no nível
            let competicao3Id = null;
            let competicao4Id = null;
            
            // Competição 3 só aparece se nível for 2 ou 3
            if (nivel === 'Nivel 2' || nivel === 'Nivel 3') {
                competicao3Id = itemData.competicao3Id;
            }
            
            // Competição 4 só aparece se nível for 3
            if (nivel === 'Nivel 3') {
                competicao4Id = itemData.competicao4Id;
            }
            
            const competitionIds = [
                itemData.competicao1Id,
                itemData.competicao2Id,
                competicao3Id,
                competicao4Id
            ].filter(id => id); // Filtra valores nulos/undefined
            
            console.log(`[fetchClubImagesFromCompetitions] IDs de competições encontrados: ${competitionIds.join(', ')}`);
            
            if (competitionIds.length === 0) {
                console.warn("[fetchClubImagesFromCompetitions] Nenhum ID de competição encontrado no item.");
                return [];
            }
            
            const clubImages = [];
            const usedClubIds = new Set(); // Para evitar repetições
            
            // Verificar quais clubes já estão no mercado
            async function checkClubInMarket(clubId) {
                try {
                    console.log(`[checkClubInMarket] Verificando se clube ${clubId} está no mercado...`);
                    const mercadoRef = collection(db, 'mitosgameMercado');
                    const q1 = query(mercadoRef, where('competicao1Id', '==', clubId));
                    const q2 = query(mercadoRef, where('competicao2Id', '==', clubId));
                    const q3 = query(mercadoRef, where('competicao3Id', '==', clubId));
                    const q4 = query(mercadoRef, where('competicao4Id', '==', clubId));
                    
                    const [snap1, snap2, snap3, snap4] = await Promise.all([
                        getDocs(q1),
                        getDocs(q2),
                        getDocs(q3),
                        getDocs(q4)
                    ]);
                    
                    const isInMarket = !snap1.empty || !snap2.empty || !snap3.empty || !snap4.empty;
                    console.log(`[checkClubInMarket] Clube ${clubId} ${isInMarket ? 'está' : 'não está'} no mercado.`);
                    return isInMarket;
                } catch (error) {
                    console.error(`[checkClubInMarket] Erro ao verificar clube ${clubId} no mercado:`, error);
                    return false; // Em caso de erro, assumimos que não está no mercado
                }
            }
            
            // Para cada competição, buscar seus clubes e selecionar um aleatoriamente
            for (const competitionId of competitionIds) {
                try {
                    // Buscar documento da competição
                    const competitionDoc = await getDoc(doc(db, 'competicoes', competitionId));
                    
                    if (!competitionDoc.exists()) {
                        console.warn(`[fetchClubImagesFromCompetitions] Competição ${competitionId} não encontrada.`);
                        continue;
                    }
                    
                    const competitionData = competitionDoc.data();
                    console.log(`[fetchClubImagesFromCompetitions] Competição ${competitionId} (${competitionData.nome}) encontrada.`);
                    
                    // Verificar se a competição tem clubes associados
                    if (!competitionData.clubes || !Array.isArray(competitionData.clubes) || competitionData.clubes.length === 0) {
                        console.warn(`[fetchClubImagesFromCompetitions] Competição ${competitionId} não tem clubes associados.`);
                        continue;
                    }
                    
                    // Filtrar clubes que já foram usados
                    const availableClubs = competitionData.clubes.filter(clubId => !usedClubIds.has(clubId));
                    
                    if (availableClubs.length === 0) {
                        console.warn(`[fetchClubImagesFromCompetitions] Todos os clubes da competição ${competitionId} já foram usados.`);
                        continue;
                    }
                    
                    // Tentar encontrar um clube que não esteja no mercado
                    let selectedClubId = null;
                    let clubData = null;
                    
                    // Embaralhar a lista de clubes disponíveis para seleção aleatória
                    const shuffledClubs = [...availableClubs].sort(() => Math.random() - 0.5);
                    
                    for (const clubId of shuffledClubs) {
                        // Verificar se o clube já está no mercado
                        const isInMarket = await checkClubInMarket(clubId);
                        
                        if (isInMarket) {
                            console.log(`[fetchClubImagesFromCompetitions] Clube ${clubId} já está no mercado, tentando outro...`);
                            continue;
                        }
                        
                        // Buscar dados do clube selecionado
                        const clubDoc = await getDoc(doc(db, 'clubes', clubId));
                        
                        if (!clubDoc.exists()) {
                            console.warn(`[fetchClubImagesFromCompetitions] Clube ${clubId} não encontrado.`);
                            continue;
                        }
                        
                        clubData = clubDoc.data();
                        
                        // Verificar se o clube tem imagem
                        if (clubData.imagem) {
                            selectedClubId = clubId;
                            usedClubIds.add(selectedClubId); // Marcar como usado
                            break; // Encontramos um clube válido, sair do loop
                        } else {
                            console.warn(`[fetchClubImagesFromCompetitions] Clube ${clubId} (${clubData.nome}) não tem imagem.`);
                        }
                    }
                    
                    // Se encontramos um clube válido, adicionar à lista de imagens
                    if (selectedClubId && clubData && clubData.imagem) {
                        console.log(`[fetchClubImagesFromCompetitions] Imagem do clube ${selectedClubId} (${clubData.nome}): ${clubData.imagem}`);
                        clubImages.push({
                            id: selectedClubId,
                            name: clubData.nome,
                            image: clubData.imagem,
                            competitionId: competitionId,
                            competitionName: competitionData.nome
                        });
                    } else {
                        console.warn(`[fetchClubImagesFromCompetitions] Não foi possível encontrar um clube válido para a competição ${competitionId}.`);
                    }
                    
                } catch (error) {
                    console.error(`[fetchClubImagesFromCompetitions] Erro ao buscar dados da competição ${competitionId}:`, error);
                }
            }
            
            console.log(`[fetchClubImagesFromCompetitions] Total de imagens de clubes encontradas: ${clubImages.length}`);
            return clubImages;
        }
        
        // --- updateCardElements COM LOGS ADICIONAIS ---
        async function updateCardElements(itemData, familiaData) {
            console.log("[updateCardElements] Iniciando atualização dos elementos do card.");
            if (!dynamicCard || !cardMainImage || !cardBackgroundImage || !cardName || !cardDescription || !cardLevel || !cardStats) {
                console.error("[updateCardElements] Elementos essenciais do card não encontrados na DOM!");
                return;
            }

            // --- Log: Dados recebidos ---
            console.log("[updateCardElements] Dados do Item recebidos:", JSON.stringify(itemData));
            console.log("[updateCardElements] Dados da Família recebidos:", JSON.stringify(familiaData)); // Pode ser null

            // Reset
            dynamicCard.className = 'clash-card'; cardBackgroundImage.className = 'clash-card__image'; cardStats.className = 'clash-card__unit-stats clearfix'; cardLevel.className = 'clash-card__level'; cardBackgroundImage.style.backgroundImage = 'none'; cardBackgroundImage.style.backgroundColor = 'transparent'; cardStats.style.background = '';

            // Imagem Principal
            cardMainImage.src = itemData?.imagem || 'placeholder.png'; cardMainImage.alt = itemData?.nome || 'Item Mítico';
            console.log(`[updateCardElements] Imagem principal definida para: ${cardMainImage.src}`);

            // Imagem Background (Família)
            const imagemFieldName = 'imagem'; // <<< VERIFIQUE NOME DO CAMPO
            const backgroundImageUrl = familiaData?.[imagemFieldName]; // Usa optional chaining e nome do campo
            // --- Log: URL da imagem de fundo extraída ---
            console.log(`[updateCardElements] URL da imagem de fundo extraída de familiaData.${imagemFieldName}: ${backgroundImageUrl}`);

            if (backgroundImageUrl) {
                cardBackgroundImage.style.backgroundImage = `url('${backgroundImageUrl}')`;
                 // --- Log: Aplicação do estilo background-image ---
                console.log(`[updateCardElements] Definindo background-image para: url('${backgroundImageUrl}')`);
            } else {
                cardBackgroundImage.style.backgroundColor = '#333'; // Fallback
                 // --- Log: Imagem de fundo não encontrada/aplicada ---
                console.log("[updateCardElements] Nenhuma URL de imagem de fundo encontrada ou válida. Aplicando cor de fallback.");
            }

            // Textos
            cardName.textContent = itemData?.nome || 'Desconhecido'; cardDescription.textContent = itemData?.descricao || 'Sem detalhes.'; cardLevel.textContent = familiaData?.nome || itemData?.patamar || 'N/A';

            // Estilos Condicionais
            let lvlColor = '#CCCCCC'; let statsGrad = 'linear-gradient(to bottom, #555, #222)';
            const famCor = familiaData?.cor; const pat = itemData?.patamar?.toLowerCase();
            if (famCor) { lvlColor = famCor; statsGrad = `linear-gradient(to bottom, ${familiaData.corClara || famCor}, ${familiaData.corEscura || '#222'})`; }
            else if (pat) { switch (pat) { /* ... cases ... */
                 case 'lendário': lvlColor = '#FFD700'; statsGrad = 'linear-gradient(to bottom, #FFEC8B, #B8860B)'; break;
                 case 'divino': lvlColor = '#ADD8E6'; statsGrad = 'linear-gradient(to bottom, #E0FFFF, #4682B4)'; break;
                 case 'comum': lvlColor = '#A9A9A9'; statsGrad = 'linear-gradient(to bottom, #D3D3D3, #696969)'; break;
                 case 'patamar 1': lvlColor = '#B8860B'; statsGrad = 'linear-gradient(to bottom, #FFD700, #A0522D)'; break;
            } }
            cardLevel.style.color = lvlColor; cardStats.style.background = statsGrad;
            
            // Buscar e atualizar imagens dos clubes para os ícones de estatísticas
            try {
                const clubImages = await fetchClubImagesFromCompetitions(itemData);
                console.log("[updateCardElements] Imagens de clubes obtidas:", clubImages);
                
                // Atualizar os ícones de estatísticas com as imagens dos clubes
                const statIcons = cardStats.querySelectorAll('.one-quarter img');
                
                // Imagem placeholder para substituir imagens não disponíveis pelo nível
                const placeholderImage = 'https://lh3.googleusercontent.com/pw/AP1GczPiqT86eHKMxOqxzkXTF1sOZkH3NuWtELu04zT0ANLpdA9MHuPdguJHyYoRgSKSbiM0el-8UZ8qZuEQbWT8heJR2GPglnZdJRfnVqjdFUItX2deOQVy9RPgqTa02vXF36nUz2iM3oDD7EjuI0HOwps1=w880-h880-s-no-gm?authuser=1';
                
                // Verificar o nível do mito
                const nivel = itemData.nivel || 'Nivel 1';
                console.log(`[updateCardElements] Nível do mito para exibição de imagens: ${nivel}`);
                
                // Para cada ícone de estatística, atribuir uma imagem de clube (se disponível)
                for (let i = 0; i < statIcons.length; i++) {
                    // Verificar condições especiais para os ícones 3 e 4
                    if (i === 2) { // Ícone 3 (índice 2)
                        if (nivel === 'Nivel 2' || nivel === 'Nivel 3') {
                            // Mostrar imagem do clube se disponível
                            if (i < clubImages.length && clubImages[i] && clubImages[i].image) {
                                statIcons[i].src = clubImages[i].image;
                                statIcons[i].alt = clubImages[i].name;
                                console.log(`[updateCardElements] Ícone ${i+1} atualizado com imagem do clube ${clubImages[i].name}`);
                            }
                        } else {
                            // Mostrar placeholder para Nivel 1
                            statIcons[i].src = placeholderImage;
                            statIcons[i].alt = 'Bloqueado';
                            console.log(`[updateCardElements] Ícone ${i+1} bloqueado (nível insuficiente)`);
                        }
                    } else if (i === 3) { // Ícone 4 (índice 3)
                        if (nivel === 'Nivel 3') {
                            // Mostrar imagem do clube se disponível
                            if (i < clubImages.length && clubImages[i] && clubImages[i].image) {
                                statIcons[i].src = clubImages[i].image;
                                statIcons[i].alt = clubImages[i].name;
                                console.log(`[updateCardElements] Ícone ${i+1} atualizado com imagem do clube ${clubImages[i].name}`);
                            }
                        } else {
                            // Mostrar placeholder para Nivel 1 e 2
                            statIcons[i].src = placeholderImage;
                            statIcons[i].alt = 'Bloqueado';
                            console.log(`[updateCardElements] Ícone ${i+1} bloqueado (nível insuficiente)`);
                        }
                    } else {
                        // Ícones 1 e 2 sempre mostram a imagem do clube se disponível
                        if (i < clubImages.length && clubImages[i] && clubImages[i].image) {
                            statIcons[i].src = clubImages[i].image;
                            statIcons[i].alt = clubImages[i].name;
                            console.log(`[updateCardElements] Ícone ${i+1} atualizado com imagem do clube ${clubImages[i].name}`);
                        }
                    }
                }
            } catch (error) {
                console.error("[updateCardElements] Erro ao buscar imagens de clubes:", error);
            }
            
            console.log("[updateCardElements] Elementos atualizados para:", itemData?.nome || 'Item Desconhecido');
        }
        // --- FIM de updateCardElements com logs adicionais ---


        // --- prepareDynamicCard COM LOGS ADICIONAIS ---
        async function prepareDynamicCard() {
            console.log("[prepareDynamicCard] Iniciando...");
            if (!cardReveal) { console.error("[prepareDynamicCard] Erro: #cardReveal não encontrado."); return false; }
            if (cardMainImage) cardMainImage.src = ''; if (cardBackgroundImage) cardBackgroundImage.style.backgroundImage = 'none'; if (cardName) cardName.textContent = 'A Abrir...'; if(cardDescription) cardDescription.textContent = ''; if(cardLevel) cardLevel.textContent = '';
            try {
                console.log("[prepareDynamicCard] Passo 1: Buscando Regras...");
                const activeRules = await fetchActiveRules();
                console.log(`[prepareDynamicCard] Regras encontradas: ${activeRules ? activeRules.length : 'null'}`);
                if (!activeRules || activeRules.length === 0) { console.error("[prepareDynamicCard] Falha: Nenhuma regra ativa."); return false; }

                console.log("[prepareDynamicCard] Passo 2: Selecionando Item...");
                const selectedItem = await fetchAndSelectItem(activeRules);
                console.log(`[prepareDynamicCard] Item selecionado retornado: ${selectedItem ? selectedItem.id : 'null'}`);
                if (!selectedItem) { console.error("[prepareDynamicCard] Falha: Nenhum item selecionado."); return false; }

                // --- Log: ID da família a ser buscado ---
                const familiaIdParaBuscar = selectedItem.familiaId;
                console.log(`[prepareDynamicCard] Passo 3: Buscando Família com ID: ${familiaIdParaBuscar}...`);
                const familiaData = await fetchFamiliaData(familiaIdParaBuscar); // Chama a versão com logs
                // --- Log: Resultado da busca da família ---
                console.log(`[prepareDynamicCard] Resultado da busca da Família (fetchFamiliaData retornou):`, familiaData ? `ID ${familiaData.id}`: 'null');

                console.log("[prepareDynamicCard] Passo 4: Atualizando Elementos...");
                // Agora updateCardElements é assíncrono, então precisamos aguardar sua conclusão
                await updateCardElements(selectedItem, familiaData); // Chama a versão com logs

                console.log("[prepareDynamicCard] Passo 5: Pré-carregando Imagens...");
                // Passa o elemento específico onde o background foi definido para preloadImages
                await preloadImages(cardBackgroundImage);
                await preloadImages(cardReveal); // Também verifica <img> dentro de cardReveal
                console.log("[prepareDynamicCard] Preparação concluída com sucesso.");
                return true;
            } catch (error) { console.error("[prepareDynamicCard] Erro GERAL:", error); return false; }
        }
        // --- FIM de prepareDynamicCard com logs adicionais ---


        async function animatePackReveal() {
            // ... (código da função animatePackReveal como antes) ...
            if (!pack || !cardReveal || !flashOverlay) { return; } if (pack.classList.contains('animating')) return; pack.classList.add('animating'); pack.style.pointerEvents = 'none';
            cardReveal.classList.remove('visible'); cardReveal.style.opacity = '0'; cardReveal.style.display = 'none'; flashOverlay.classList.remove('active'); void flashOverlay.offsetWidth; pack.classList.remove('separar', 'sumir-pack'); pack.style.opacity = '1'; const packTop = pack.querySelector('.pack-top'); const packBottom = pack.querySelector('.pack-bottom'); if(packTop) packTop.style.display = 'flex'; if(packBottom) packBottom.style.display = 'flex';
            console.log("[animatePackReveal] Iniciando preparação do card...");
            const cardPrepared = await prepareDynamicCard(); // Chama a versão com logs
            if (!cardPrepared) { console.error("[animatePackReveal] Preparação falhou. Abortando animação."); pack.classList.remove('animating'); pack.style.pointerEvents = 'auto'; if(cardName) cardName.textContent = "Erro ao Abrir"; return; }
            console.log("[animatePackReveal] Preparação concluída. Iniciando animação do pack...");
            pack.classList.add('separar'); flashOverlay.classList.add('active');
            setTimeout(() => {
                console.log("[animatePackReveal] Animação do pack concluída (timeout). Escondendo pack e revelando card...");
                pack.classList.add('sumir-pack'); cardReveal.style.display = 'block'; cardReveal.style.opacity = '0';
                requestAnimationFrame(() => { cardReveal.style.opacity = ''; cardReveal.classList.add('visible'); });
                setTimeout(() => { pack.classList.remove('animating'); pack.style.pointerEvents = 'auto'; console.log("[animatePackReveal] Animação de revelação concluída (timeout final). Pack reativado.");}, 1500);
            }, 600);
        }

         // --- Inicialização e Autenticação ---
        function initializeAppLogic() {
            if (!auth) {
                console.error("Auth não inicializado.");
                if (loadingScreen) loadingScreen.classList.add('hidden');
                return;
            }

            onAuthStateChanged(auth, async (user) => { // A função agora é async
                if (user) {
                    console.log("Utilizador autenticado:", user.uid);
                    if (!db) { console.error("DB não disponível!"); return; }

                    // <<< INÍCIO DAS NOVAS VERIFICAÇÕES DE ACESSO >>>
                    const userData = await getUserData(user.uid);

                    if (!userData) {
                        // Se não há dados do utilizador no Firestore, nega o acesso
                        console.log("Acesso negado. Dados do utilizador não encontrados no Firestore.");
                        window.location.href = '404.html'; // Redireciona para página de erro
                        return;
                    }

                    const isRuler = userData.estatuto === 'ruler';
                    // Usa optional chaining (?) para evitar erros se 'permissoes' não existir
                    const hasPermission = userData.permissoes?.myths === 'yes';

                    // Se o utilizador for 'ruler' OU tiver a permissão, concede o acesso
                 if (isRuler || hasPermission) {
                        console.log(`Acesso concedido. Motivo: ${isRuler ? 'É um ruler' : 'Possui a permissão myths'}.`);
                        
                        // --- INÍCIO DA ALTERAÇÃO ---
                        // Busca as configurações globais do menu
                        const paineisMenuRef = doc(db, 'paineis', 'paineis menu');
                        const paineisMenuDoc = await getDoc(paineisMenuRef);
                        if (paineisMenuDoc.exists()) {
                            // Chama a função global que está em menu-component.js
                            updateMenuVisibility(paineisMenuDoc.data());
                        }
                        // --- FIM DA ALTERAÇÃO ---

                        if (loadingScreen) loadingScreen.classList.add('hidden');
                        if (content) content.classList.add('visible');

                    } else {
                        // Se não for 'ruler' E não tiver a permissão, nega o acesso
                        console.log("Acesso negado. Permissões insuficientes.");
                        window.location.href = '404.html'; // Redireciona para página de erro
                        return;
                    }
                    // <<< FIM DAS NOVAS VERIFICAÇÕES DE ACESSO >>>

                } else {
                    console.log("Utilizador deslogado. Redirecionando...");
                    if (window.location.pathname !== '/index.html' && window.location.pathname !== '/') {
                        window.location.href = 'index.html';
                    } else {
                        if (loadingScreen) loadingScreen.classList.add('hidden');
                    }
                }
            });

            if (pack) {
                pack.addEventListener('click', animatePackReveal);
            } else {
                console.warn("Elemento #pack não encontrado.");
            }
        }

        // --- Execução Inicial ---
        document.addEventListener('DOMContentLoaded', () => {
            if (app) { initializeAppLogic(); }
            else { console.error("Falha inicialização Firebase."); /* Mostrar erro UI? */ if (loadingScreen) loadingScreen.classList.add('hidden'); }
        });

    </script>
    <script src="menu-component.js"></script> 
</body>
</html>
