<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calendário - Ggames</title>
        <link rel="icon" type="image/png" href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTl6Ljabwgx-VXdZz8FcAoygQprujSsCoXc32Y_iU0FjYVPu1B6MffWwp8gcCVuV8TWn39FRk9OIe1nc-esubVJYmdLsTptAoR9GyqNuw4R5MBaeaoWXTc3JaqH2YVNtEmfReQqohvQKvHiI0XwE5na2ty2B9Bt4oELxYv2BaZ7R3UmeylpiVEiIbiLnCB/s320/soccer-ball-png.webp">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* ESTILOS GERAIS E MENU */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            min-height: 100vh;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
        }
        .content { padding: 10px; margin-bottom: 80px; }
        h1 { color: #333; margin-bottom: 20px; text-align: center; }
        #loading-screen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #f0f0f0; display: flex; justify-content: center; align-items: center; z-index: 1001; }
        .loading-spinner { border: 16px solid #f3f3f3; border-top: 16px solid #3498db; border-radius: 50%; width: 120px; height: 120px; animation: spin 2s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* ESTILOS ESPECÍFICOS DO CALENDÁRIO */
        #calendar-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .round-container {
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .round-header {
            padding: 15px;
            background-color: #343a40;
            color: #ffffff;
            font-size: 1.3em;
            text-align: center;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* ESTILO PARA A RONDA ATUAL */
        .round-container.current-round {
            background-color: #e7f5ff;
            border: 2px solid #2176ff;
            box-shadow: 0 6px 20px rgba(33, 118, 255, 0.2);
        }
        .round-container.current-round .round-header {
             background-color: #2176ff;
        }

        /* ESTILO PARA A PRÓXIMA RONDA */
        .round-container.next-round {
            background-color: #fffbe6;
            border: 2px solid #ffc107;
            box-shadow: 0 6px 20px rgba(255, 193, 7, 0.2);
        }
        .round-container.next-round .round-header {
             background-color: #ffc107;
             color: #333;
        }
        
        /* NOVO: Estilo combinado para os ícones "Now" e "Next" */
        .round-container.current-round .round-header h2 i,
        .round-container.next-round .round-header h2 i {
            margin-right: 10px; /* Adiciona espaço entre o ícone e o texto */
        }

        /* ESTILOS PARA O TOGGLE (ABRIR/FECHAR) */
        .toggle-icon {
             transition: transform 0.3s ease-in-out;
        }
        .round-content-wrapper {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
        }
        .round-container.collapsed .round-content-wrapper {
            max-height: 0;
        }
        .round-container.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }

        .competition-list { padding: 10px 15px; border-bottom: 1px solid #f0f0f0; }
        .round-container .competition-list:last-child { border-bottom: none; }
        .competition-header { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .competition-header img { width: 25px; height: 25px; object-fit: contain; }
        .competition-header h3 { font-size: 1.1em; color: #333; }
        .game-list-item { display: flex; align-items: center; justify-content: space-between; padding: 12px 0 12px 35px; border-top: 1px solid #eee; }
        .game-teams { display: flex; align-items: center; gap: 8px; font-size: 0.95em; }
        .game-teams .vs { color: #888; font-weight: bold; }
        .game-datetime { font-size: 0.85em; color: #666; text-align: right; flex-shrink: 0; }
        .no-games { text-align: center; color: #666; padding: 20px; background: white; border-radius: 8px; margin: 20px 0; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loading-spinner"></div>
    </div>

    <div id="main-content-wrapper" style="display: none;">
        <div class="content">
            <h1>Calendário de Jogos</h1>
            <div id="calendar-container"></div>
        </div>

<script src="config.js"></script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
import { getFirestore, collection, getDocs, doc, getDoc, query, orderBy, addDoc, serverTimestamp, updateDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);

    async function logUserAction(actionDescription) {
    if (!auth.currentUser) {
        console.log("Nenhum utilizador logado para registar a ação.");
        return;
    }
    
    try {
        const eyeCollection = collection(db, 'eye');
        await addDoc(eyeCollection, {
            dataacao: serverTimestamp(),
            acao: actionDescription,
            userId: auth.currentUser.uid
        });
    } catch (error) {
        console.error("Erro ao registar ação na coleção 'eye':", error);
    }
}

    const loadingScreen = document.getElementById('loading-screen');
    const mainContentWrapper = document.getElementById('main-content-wrapper');

    async function getUserStatus(userId) { return getDoc(doc(db, 'users', userId)).then(d => d.exists() ? { estatuto: d.data().estatuto, aceite: d.data().aceite } : null); }
    async function loadMenuSettings() { return getDoc(doc(db, 'paineis', 'paineis menu')).then(d => d.exists() ? d.data() : {}); }
    function checkPageAccess(userStatus, menuSettings) { return (menuSettings['calendario'] === 'on' || userStatus === 'ruler'); }

    async function loadCalendar() {
        const container = document.getElementById('calendar-container');
        container.innerHTML = '';
        const now = new Date();
        const dataCache = new Map();

        try {
            const gamesQuery = query(collection(db, 'jogos'), orderBy("dataJogo", "asc"));
            const querySnapshot = await getDocs(gamesQuery);
            const allGames = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            if (allGames.length === 0) {
                container.innerHTML = '<p class="no-games">Nenhum jogo encontrado no calendário.</p>';
                return;
            }

         let currentRoundNumber = null;
let nextRoundNumber = null;

// 1. Tenta encontrar uma ronda ATUAL (lógica ligeiramente melhorada)
let potentialCurrentRounds = [];
allGames.forEach(game => {
    if (game.inicioIntervalo && game.fimIntervalo) {
        const inicio = game.inicioIntervalo.toDate();
        const fim = game.fimIntervalo.toDate();
        if (now >= inicio && now <= fim) {
            potentialCurrentRounds.push(game.ronda);
        }
    }
});
if (potentialCurrentRounds.length > 0) {
    currentRoundNumber = Math.min(...potentialCurrentRounds); // Pega a de menor número
}

// 2. Se NENHUMA ronda for atual, então procuramos a última e a próxima
if (currentRoundNumber === null) {

    // 2a. ENCONTRA A ÚLTIMA RONDA QUE ESTEVE ATIVA
    let lastActiveRoundNumber = null;
    let latestEndTime = new Date(0); // Uma data muito antiga para começar a comparação

    allGames.forEach(game => {
        if (game.fimIntervalo) {
            const endTime = game.fimIntervalo.toDate();
            // Se o intervalo já terminou e foi mais recente que o último que guardamos
            if (endTime < now && endTime > latestEndTime) {
                latestEndTime = endTime;
                lastActiveRoundNumber = game.ronda;
            }
        }
    });

    // 2b. PROCURA A PRÓXIMA RONDA, EXCLUINDO A QUE JÁ FOI "NOW"
    for (const game of allGames) {
        // A condição agora é dupla:
        // 1. O jogo tem que ser no futuro
        // 2. A ronda do jogo NÃO PODE ser a última que esteve ativa
        if (game.dataJogo.toDate() > now && game.ronda !== lastActiveRoundNumber) {
            nextRoundNumber = game.ronda; // Encontrou a verdadeira próxima ronda
            break; // Para a busca
        }
    }
}

            const groupedData = {};
            for (const game of allGames) {
                if (!game.ronda || !game.competicaoId) continue;
                if (!groupedData[game.ronda]) groupedData[game.ronda] = {};
                if (!groupedData[game.ronda][game.competicaoId]) {
                    groupedData[game.ronda][game.competicaoId] = { name: game.competicao, image: '', games: [] };
                }
                groupedData[game.ronda][game.competicaoId].games.push(game);
            }

            const sortedRounds = Object.keys(groupedData).sort((a, b) => Number(a) - Number(b));
            for (const roundNumber of sortedRounds) {
                const isCurrent = (Number(roundNumber) === currentRoundNumber);
                const isNext = (Number(roundNumber) === nextRoundNumber);

                const roundContainer = document.createElement('div');
                let roundClasses = 'round-container';
                if (isCurrent) roundClasses += ' current-round';
                else if (isNext) roundClasses += ' next-round';

                if (!isCurrent && !isNext) {
                    roundClasses += ' collapsed';
                }
                roundContainer.className = roundClasses;
                
                const roundHeader = document.createElement('div');
                roundHeader.className = 'round-header';
                
                // --- NOVO: Lógica de cabeçalho com "Now" e "Next" ---
                let headerHTML = '';
                if (isCurrent) {
                    headerHTML = `<h2><i class="fas fa-play-circle"></i> Now: Ronda ${roundNumber}</h2>`;
                } else if (isNext) {
                    headerHTML = `<h2><i class="fas fa-forward"></i> Next: Ronda ${roundNumber}</h2>`;
                } else {
                    headerHTML = `<h2>Ronda ${roundNumber}</h2>`;
                }
                roundHeader.innerHTML = `${headerHTML} <i class="fas fa-chevron-down toggle-icon"></i>`;
                roundContainer.appendChild(roundHeader);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'round-content-wrapper';

                const competitionsInRound = groupedData[roundNumber];
                for (const compId in competitionsInRound) {
                    const competition = competitionsInRound[compId];
                    
                    if (!dataCache.has(compId)) {
                        const compDoc = await getDoc(doc(db, 'competicoes', compId));
                        dataCache.set(compId, compDoc.exists() ? compDoc.data() : { imagem: '' });
                    }
                    competition.image = dataCache.get(compId).imagem;

                    const competitionList = document.createElement('div');
                    competitionList.className = 'competition-list';
                    competitionList.innerHTML = `<div class="competition-header"><img src="${competition.image}" alt="${competition.name}"><h3>${competition.name}</h3></div>`;

                    for (const game of competition.games) {
                        const gameDate = game.dataJogo.toDate();
                        const formattedDate = gameDate.toLocaleDateString('pt-PT', { day: '2-digit', month: '2-digit' });
                        const formattedTime = gameDate.toLocaleTimeString('pt-PT', { hour: '2-digit', minute: '2-digit' });
                        const gameElement = document.createElement('div');
                        gameElement.className = 'game-list-item';
                        gameElement.innerHTML = `<div class="game-teams"><span>${game.equipaCasa}</span><span class="vs">vs</span><span>${game.equipaFora}</span></div><div class="game-datetime">${formattedDate} - ${formattedTime}</div>`;
                        competitionList.appendChild(gameElement);
                    }
                    contentWrapper.appendChild(competitionList);
                }
                roundContainer.appendChild(contentWrapper);
                container.appendChild(roundContainer);
            }

            document.querySelectorAll('.round-header').forEach(header => {
                header.addEventListener('click', () => {
                    header.closest('.round-container').classList.toggle('collapsed');
                });
            });

            const highlightedRound = document.querySelector('.current-round, .next-round');
            if (highlightedRound) {
                highlightedRound.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }

        } catch (error) {
            console.error("Erro ao carregar o calendário: ", error);
            container.innerHTML = '<p class="error">Não foi possível carregar o calendário. Tente novamente mais tarde.</p>';
        } finally {
            loadingScreen.style.display = 'none';
        }
    }

  onAuthStateChanged(auth, async (user) => {
    if (user) {
        // Atualiza o último acesso do utilizador
        try {
            await updateDoc(doc(db, 'users', user.uid), {
                ultimoacesso: serverTimestamp()
            });
        } catch (error) {
            console.error("Erro ao atualizar o campo ultimoacesso: ", error);
        }

        const userInfo = await getUserStatus(user.uid);
        if (userInfo && userInfo.aceite === "Yes") {
            const menuSettings = await loadMenuSettings();
            if (checkPageAccess(userInfo.estatuto, menuSettings)) {
                
                // Regista a entrada na página no log
                await logUserAction(`Entrou em ${document.title}`);

                mainContentWrapper.style.display = 'block';
                updateMenuVisibility(menuSettings);
                await loadCalendar();
            } else {
                window.location.href = '404.html';
            }
        } else {
            window.location.href = 'index.html';
        }
    } else {
        window.location.href = 'index.html';
    }
});

document.addEventListener('click', async (event) => {
    const clickableElement = event.target.closest('.round-header, a.menu-item');

    if (!clickableElement) return;

    let actionName = '';

    if (clickableElement.matches('.round-header')) {
        const roundTitle = clickableElement.querySelector('h2')?.textContent.trim();
        actionName = `Interagiu com: ${roundTitle || 'uma ronda'}`;
    } else if (clickableElement.matches('a.menu-item')) {
        actionName = `Navegou para: ${clickableElement.querySelector('.menu-text')?.textContent.trim() || 'Menu'}`;
    }

    if (!actionName) return;

    // Lida com a navegação para outras páginas (menu inferior)
    const isNavLink = clickableElement.tagName === 'A' && clickableElement.href && clickableElement.target !== '_blank';
    
    if (isNavLink) {
        event.preventDefault();
        await logUserAction(actionName);
        window.location.href = clickableElement.href;
    } else {
        // Para cliques que não causam navegação (abrir/fechar rondas)
        await logUserAction(actionName);
    }
});

</script>
<script src="menu-component.js"></script> 
</body>
</html>
